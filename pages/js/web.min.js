var LeaferUI = function(t) {
    "use strict";
    const e = {
        toURL(t, e) {
            let i = encodeURIComponent(t);
            return "text" === e ? i = "data:text/plain;charset=utf-8," + i : "svg" === e && (i = "data:image/svg+xml," + i),
            i
        },
        image: {
            hitCanvasSize: 100,
            maxCacheSize: 4096e3,
            maxPatternSize: 8847360,
            crossOrigin: "anonymous",
            getRealURL(t) {
                const {prefix: i, suffix: s} = e.image;
                return !s || t.startsWith("data:") || t.startsWith("blob:") || (t += (t.includes("?") ? "&" : "?") + s),
                i && "/" === t[0] && (t = i + t),
                t
            }
        }
    }
      , i = {}
      , s = {
        RUNTIME: "runtime",
        LEAF: "leaf",
        TASK: "task",
        CNAVAS: "canvas",
        IMAGE: "image",
        types: {},
        create(t) {
            const {types: e} = n;
            return e[t] ? e[t]++ : (e[t] = 1,
            0)
        }
    }
      , n = s
      , {round: o, pow: r, PI: a} = Math
      , h = {
        within: (t, e, i) => ("object" == typeof e && (i = e.max,
        e = e.min),
        void 0 !== e && t < e && (t = e),
        void 0 !== i && t > i && (t = i),
        t),
        fourNumber(t, e) {
            let i;
            if (t instanceof Array)
                switch (t.length) {
                case 4:
                    i = void 0 === e ? t : [...t];
                    break;
                case 2:
                    i = [t[0], t[1], t[0], t[1]];
                    break;
                case 3:
                    i = [t[0], t[1], t[2], t[1]];
                    break;
                case 1:
                    t = t[0];
                    break;
                default:
                    t = 0
                }
            if (i || (i = [t, t, t, t]),
            e)
                for (let t = 0; t < 4; t++)
                    i[t] > e && (i[t] = e);
            return i
        },
        formatRotation: (t, e) => (t %= 360,
        e ? t < 0 && (t += 360) : (t > 180 && (t -= 360),
        t < -180 && (t += 360)),
        h.float(t)),
        getGapRotation(t, e, i=0) {
            let s = t + i;
            if (e > 1) {
                const t = Math.abs(s % e);
                (t < 1 || t > e - 1) && (s = Math.round(s / e) * e)
            }
            return s - i
        },
        float(t, e) {
            const i = void 0 !== e ? r(10, e) : 1e12;
            return -0 === (t = o(t * i) / i) ? 0 : t
        },
        getScaleData: (t, e, i, s) => (s || (s = {}),
        e ? (s.scaleX = ("number" == typeof e ? e : e.width) / i.width,
        s.scaleY = ("number" == typeof e ? e : e.height) / i.height) : t && h.assignScale(s, t),
        s),
        assignScale(t, e) {
            "number" == typeof e ? t.scaleX = t.scaleY = e : (t.scaleX = e.x,
            t.scaleY = e.y)
        }
    }
      , l = a / 180
      , d = 2 * a
      , c = a / 2;
    function u() {
        return {
            x: 0,
            y: 0
        }
    }
    function p() {
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    }
    function _() {
        return {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        }
    }
    const {sin: g, cos: f, acos: y, sqrt: m} = Math
      , {float: v} = h
      , w = {};
    function x() {
        return Object.assign(Object.assign(Object.assign({}, {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        }), {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), {
            scaleX: 1,
            scaleY: 1,
            rotation: 0,
            skewX: 0,
            skewY: 0
        })
    }
    const b = {
        defaultMatrix: {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        },
        defaultWorld: x(),
        tempMatrix: {},
        set(t, e=1, i=0, s=0, n=1, o=0, r=0) {
            t.a = e,
            t.b = i,
            t.c = s,
            t.d = n,
            t.e = o,
            t.f = r
        },
        get: _,
        getWorld: x,
        copy(t, e) {
            t.a = e.a,
            t.b = e.b,
            t.c = e.c,
            t.d = e.d,
            t.e = e.e,
            t.f = e.f
        },
        translate(t, e, i) {
            t.e += e,
            t.f += i
        },
        translateInner(t, e, i, s) {
            t.e += t.a * e + t.c * i,
            t.f += t.b * e + t.d * i,
            s && (t.e -= e,
            t.f -= i)
        },
        scale(t, e, i=e) {
            t.a *= e,
            t.b *= e,
            t.c *= i,
            t.d *= i
        },
        scaleOfOuter(t, e, i, s) {
            E.toInnerPoint(t, e, w),
            E.scaleOfInner(t, w, i, s)
        },
        scaleOfInner(t, e, i, s=i) {
            E.translateInner(t, e.x, e.y),
            E.scale(t, i, s),
            E.translateInner(t, -e.x, -e.y)
        },
        rotate(t, e) {
            const {a: i, b: s, c: n, d: o} = t
              , r = f(e *= l)
              , a = g(e);
            t.a = i * r - s * a,
            t.b = i * a + s * r,
            t.c = n * r - o * a,
            t.d = n * a + o * r
        },
        rotateOfOuter(t, e, i) {
            E.toInnerPoint(t, e, w),
            E.rotateOfInner(t, w, i)
        },
        rotateOfInner(t, e, i) {
            E.translateInner(t, e.x, e.y),
            E.rotate(t, i),
            E.translateInner(t, -e.x, -e.y)
        },
        skew(t, e, i) {
            const {a: s, b: n, c: o, d: r} = t;
            i && (i *= l,
            t.a = s + o * i,
            t.b = n + r * i),
            e && (e *= l,
            t.c = o + s * e,
            t.d = r + n * e)
        },
        skewOfOuter(t, e, i, s) {
            E.toInnerPoint(t, e, w),
            E.skewOfInner(t, w, i, s)
        },
        skewOfInner(t, e, i, s=0) {
            E.translateInner(t, e.x, e.y),
            E.skew(t, i, s),
            E.translateInner(t, -e.x, -e.y)
        },
        multiply(t, e) {
            const {a: i, b: s, c: n, d: o, e: r, f: a} = t;
            t.a = e.a * i + e.b * n,
            t.b = e.a * s + e.b * o,
            t.c = e.c * i + e.d * n,
            t.d = e.c * s + e.d * o,
            t.e = e.e * i + e.f * n + r,
            t.f = e.e * s + e.f * o + a
        },
        multiplyParent(t, e, i, s, n, o) {
            let {e: r, f: a} = t;
            if (o && (r += o.scrollX,
            a += o.scrollY),
            i || (i = t),
            void 0 === s && (s = 1 !== t.a || t.b || t.c || 1 !== t.d),
            s) {
                const {a: s, b: o, c: r, d: a} = t;
                i.a = s * e.a + o * e.c,
                i.b = s * e.b + o * e.d,
                i.c = r * e.a + a * e.c,
                i.d = r * e.b + a * e.d,
                n && (i.scaleX = e.scaleX * n.scaleX,
                i.scaleY = e.scaleY * n.scaleY)
            } else
                i.a = e.a,
                i.b = e.b,
                i.c = e.c,
                i.d = e.d,
                n && (i.scaleX = e.scaleX,
                i.scaleY = e.scaleY);
            i.e = r * e.a + a * e.c + e.e,
            i.f = r * e.b + a * e.d + e.f
        },
        divide(t, e) {
            E.multiply(t, E.tempInvert(e))
        },
        divideParent(t, e) {
            E.multiplyParent(t, E.tempInvert(e))
        },
        tempInvert(t) {
            const {tempMatrix: e} = E;
            return E.copy(e, t),
            E.invert(e),
            e
        },
        invert(t) {
            const {a: e, b: i, c: s, d: n, e: o, f: r} = t;
            if (i || s) {
                const a = 1 / (e * n - i * s);
                t.a = n * a,
                t.b = -i * a,
                t.c = -s * a,
                t.d = e * a,
                t.e = -(o * n - r * s) * a,
                t.f = -(r * e - o * i) * a
            } else if (1 === e && 1 === n)
                t.e = -o,
                t.f = -r;
            else {
                const i = 1 / (e * n);
                t.a = n * i,
                t.d = e * i,
                t.e = -o * n * i,
                t.f = -r * e * i
            }
        },
        toOuterPoint(t, e, i, s) {
            const {x: n, y: o} = e;
            i || (i = e),
            i.x = n * t.a + o * t.c,
            i.y = n * t.b + o * t.d,
            s || (i.x += t.e,
            i.y += t.f)
        },
        toInnerPoint(t, e, i, s) {
            const {a: n, b: o, c: r, d: a} = t
              , h = 1 / (n * a - o * r)
              , {x: l, y: d} = e;
            if (i || (i = e),
            i.x = (l * a - d * r) * h,
            i.y = (d * n - l * o) * h,
            !s) {
                const {e: e, f: s} = t;
                i.x -= (e * a - s * r) * h,
                i.y -= (s * n - e * o) * h
            }
        },
        setLayout(t, e, i, s, n) {
            const {x: o, y: r, scaleX: a, scaleY: h} = e;
            if (void 0 === n && (n = e.rotation || e.skewX || e.skewY),
            n) {
                const {rotation: i, skewX: s, skewY: n} = e
                  , o = i * l
                  , r = f(o)
                  , d = g(o);
                if (s || n) {
                    const e = s * l
                      , i = n * l;
                    t.a = (r + i * -d) * a,
                    t.b = (d + i * r) * a,
                    t.c = (e * r - d) * h,
                    t.d = (r + e * d) * h
                } else
                    t.a = r * a,
                    t.b = d * a,
                    t.c = -d * h,
                    t.d = r * h
            } else
                t.a = a,
                t.b = 0,
                t.c = 0,
                t.d = h;
            t.e = o,
            t.f = r,
            (i = i || s) && E.translateInner(t, -i.x, -i.y, !s)
        },
        getLayout(t, e, i, s) {
            const {a: n, b: o, c: r, d: a, e: h, f: d} = t;
            let u, p, _, w, x, b = h, E = d;
            if (o || r) {
                const t = n * a - o * r;
                if (r && !s) {
                    u = m(n * n + o * o),
                    p = t / u;
                    const e = n / u;
                    _ = o > 0 ? y(e) : -y(e)
                } else {
                    p = m(r * r + a * a),
                    u = t / p;
                    const e = r / p;
                    _ = c - (a > 0 ? y(-e) : -y(e))
                }
                const e = v(f(_))
                  , i = g(_);
                u = v(u),
                p = v(p),
                w = e ? v((r / p + i) / e / l, 9) : 0,
                x = e ? v((o / u - i) / e / l, 9) : 0,
                _ = v(_ / l)
            } else
                u = n,
                p = a,
                _ = w = x = 0;
            return (e = i || e) && (b += e.x * n + e.y * r,
            E += e.x * o + e.y * a,
            i || (b -= e.x,
            E -= e.y)),
            {
                x: b,
                y: E,
                scaleX: u,
                scaleY: p,
                rotation: _,
                skewX: w,
                skewY: x
            }
        },
        withScale(t, e, i=e) {
            const s = t;
            if (!e || !i) {
                const {a: s, b: n, c: o, d: r} = t;
                n || o ? i = (s * r - n * o) / (e = m(s * s + n * n)) : (e = s,
                i = r)
            }
            return s.scaleX = e,
            s.scaleY = i,
            s
        },
        reset(t) {
            E.set(t)
        }
    }
      , E = b
      , {toInnerPoint: k, toOuterPoint: T} = b
      , {sin: B, cos: L, abs: P, sqrt: C, atan2: R, min: S, PI: O} = Math
      , D = {
        defaultPoint: {
            x: 0,
            y: 0
        },
        tempPoint: {},
        tempRadiusPoint: {},
        set(t, e=0, i=0) {
            t.x = e,
            t.y = i
        },
        setRadius(t, e, i) {
            t.radiusX = e,
            t.radiusY = void 0 === i ? e : i
        },
        copy(t, e) {
            t.x = e.x,
            t.y = e.y
        },
        copyFrom(t, e, i) {
            t.x = e,
            t.y = i
        },
        move(t, e, i) {
            t.x += e,
            t.y += i
        },
        scale(t, e, i=e) {
            t.x && (t.x *= e),
            t.y && (t.y *= i)
        },
        scaleOf(t, e, i, s=i) {
            t.x += (t.x - e.x) * (i - 1),
            t.y += (t.y - e.y) * (s - 1)
        },
        rotate(t, e, i) {
            i || (i = M.defaultPoint);
            const s = L(e *= l)
              , n = B(e)
              , o = t.x - i.x
              , r = t.y - i.y;
            t.x = i.x + o * s - r * n,
            t.y = i.y + o * n + r * s
        },
        tempToInnerOf(t, e) {
            const {tempPoint: i} = M;
            return A(i, t),
            k(e, i, i),
            i
        },
        tempToOuterOf(t, e) {
            const {tempPoint: i} = M;
            return A(i, t),
            T(e, i, i),
            i
        },
        tempToInnerRadiusPointOf(t, e) {
            const {tempRadiusPoint: i} = M;
            return A(i, t),
            M.toInnerRadiusPointOf(t, e, i),
            i
        },
        toInnerRadiusPointOf(t, e, i) {
            i || (i = t),
            k(e, t, i),
            i.radiusX = Math.abs(t.radiusX / e.scaleX),
            i.radiusY = Math.abs(t.radiusY / e.scaleY)
        },
        toInnerOf(t, e, i) {
            k(e, t, i)
        },
        toOuterOf(t, e, i) {
            T(e, t, i)
        },
        getCenter: (t, e) => ({
            x: t.x + (e.x - t.x) / 2,
            y: t.y + (e.y - t.y) / 2
        }),
        getCenterX: (t, e) => t + (e - t) / 2,
        getCenterY: (t, e) => t + (e - t) / 2,
        getDistance: (t, e) => I(t.x, t.y, e.x, e.y),
        getDistanceFrom(t, e, i, s) {
            const n = P(i - t)
              , o = P(s - e);
            return C(n * n + o * o)
        },
        getMinDistanceFrom: (t, e, i, s, n, o) => S(I(t, e, i, s), I(i, s, n, o)),
        getAngle: (t, e) => W(t, e) / l,
        getRotation: (t, e, i, s) => (s || (s = e),
        M.getRadianFrom(t.x, t.y, e.x, e.y, i.x, i.y, s.x, s.y) / l),
        getRadianFrom(t, e, i, s, n, o, r, a) {
            void 0 === r && (r = i,
            a = s);
            let h = R(e - s, t - i);
            const l = R(o - a, n - r) - h;
            return l < -O ? l + d : l
        },
        getAtan2: (t, e) => R(e.y - t.y, e.x - t.x),
        getDistancePoint(t, e, i, s) {
            const n = W(t, e);
            return (e = s ? e : {}).x = t.x + L(n) * i,
            e.y = t.y + B(n) * i,
            e
        },
        toNumberPoints(t) {
            let e = t;
            return "object" == typeof t[0] && (e = [],
            t.forEach((t => e.push(t.x, t.y)))),
            e
        },
        reset(t) {
            M.reset(t)
        }
    }
      , M = D
      , {getDistanceFrom: I, copy: A, getAtan2: W} = M;
    class z {
        constructor(t, e) {
            this.set(t, e)
        }
        set(t, e) {
            return "object" == typeof t ? D.copy(this, t) : D.set(this, t, e),
            this
        }
        get() {
            const {x: t, y: e} = this;
            return {
                x: t,
                y: e
            }
        }
        clone() {
            return new z(this)
        }
        move(t, e) {
            return D.move(this, t, e),
            this
        }
        scale(t, e) {
            return D.scale(this, t, e),
            this
        }
        scaleOf(t, e, i) {
            return D.scaleOf(this, t, e, i),
            this
        }
        rotate(t, e) {
            return D.rotate(this, t, e),
            this
        }
        rotateOf(t, e) {
            return D.rotate(this, e, t),
            this
        }
        getRotation(t, e, i) {
            return D.getRotation(this, t, e, i)
        }
        toInnerOf(t, e) {
            return D.toInnerOf(this, t, e),
            this
        }
        toOuterOf(t, e) {
            return D.toOuterOf(this, t, e),
            this
        }
        getCenter(t) {
            return new z(D.getCenter(this, t))
        }
        getDistance(t) {
            return D.getDistance(this, t)
        }
        getDistancePoint(t, e, i) {
            return new z(D.getDistancePoint(this, t, e, i))
        }
        getAngle(t) {
            return D.getAngle(this, t)
        }
        getAtan2(t) {
            return D.getAtan2(this, t)
        }
        reset() {
            return D.reset(this),
            this
        }
    }
    const F = new z;
    class U {
        constructor(t, e, i, s, n, o) {
            this.set(t, e, i, s, n, o)
        }
        set(t, e, i, s, n, o) {
            return "object" == typeof t ? b.copy(this, t) : b.set(this, t, e, i, s, n, o),
            this
        }
        setWith(t) {
            return b.copy(this, t),
            this.scaleX = t.scaleX,
            this.scaleY = t.scaleY,
            this
        }
        get() {
            const {a: t, b: e, c: i, d: s, e: n, f: o} = this;
            return {
                a: t,
                b: e,
                c: i,
                d: s,
                e: n,
                f: o
            }
        }
        clone() {
            return new U(this)
        }
        translate(t, e) {
            return b.translate(this, t, e),
            this
        }
        translateInner(t, e) {
            return b.translateInner(this, t, e),
            this
        }
        scale(t, e) {
            return b.scale(this, t, e),
            this
        }
        scaleWith(t, e) {
            return b.scale(this, t, e),
            this.scaleX *= t,
            this.scaleY *= e || t,
            this
        }
        scaleOfOuter(t, e, i) {
            return b.scaleOfOuter(this, t, e, i),
            this
        }
        scaleOfInner(t, e, i) {
            return b.scaleOfInner(this, t, e, i),
            this
        }
        rotate(t) {
            return b.rotate(this, t),
            this
        }
        rotateOfOuter(t, e) {
            return b.rotateOfOuter(this, t, e),
            this
        }
        rotateOfInner(t, e) {
            return b.rotateOfInner(this, t, e),
            this
        }
        skew(t, e) {
            return b.skew(this, t, e),
            this
        }
        skewOfOuter(t, e, i) {
            return b.skewOfOuter(this, t, e, i),
            this
        }
        skewOfInner(t, e, i) {
            return b.skewOfInner(this, t, e, i),
            this
        }
        multiply(t) {
            return b.multiply(this, t),
            this
        }
        multiplyParent(t) {
            return b.multiplyParent(this, t),
            this
        }
        divide(t) {
            return b.divide(this, t),
            this
        }
        divideParent(t) {
            return b.divideParent(this, t),
            this
        }
        invert() {
            return b.invert(this),
            this
        }
        invertWith() {
            return b.invert(this),
            this.scaleX = 1 / this.scaleX,
            this.scaleY = 1 / this.scaleY,
            this
        }
        toOuterPoint(t, e, i) {
            b.toOuterPoint(this, t, e, i)
        }
        toInnerPoint(t, e, i) {
            b.toInnerPoint(this, t, e, i)
        }
        setLayout(t, e, i) {
            return b.setLayout(this, t, e, i),
            this
        }
        getLayout(t, e, i) {
            return b.getLayout(this, t, e, i)
        }
        withScale(t, e) {
            return b.withScale(this, t, e)
        }
        reset() {
            b.reset(this)
        }
    }
    const H = new U
      , N = {
        tempPointBounds: {},
        setPoint(t, e, i) {
            t.minX = t.maxX = e,
            t.minY = t.maxY = i
        },
        addPoint(t, e, i) {
            t.minX = e < t.minX ? e : t.minX,
            t.minY = i < t.minY ? i : t.minY,
            t.maxX = e > t.maxX ? e : t.maxX,
            t.maxY = i > t.maxY ? i : t.maxY
        },
        addBounds(t, e, i, s, n) {
            Y(t, e, i),
            Y(t, e + s, i + n)
        },
        copy(t, e) {
            t.minX = e.minX,
            t.minY = e.minY,
            t.maxX = e.maxX,
            t.maxY = e.maxY
        },
        addPointBounds(t, e) {
            t.minX = e.minX < t.minX ? e.minX : t.minX,
            t.minY = e.minY < t.minY ? e.minY : t.minY,
            t.maxX = e.maxX > t.maxX ? e.maxX : t.maxX,
            t.maxY = e.maxY > t.maxY ? e.maxY : t.maxY
        },
        toBounds(t, e) {
            e.x = t.minX,
            e.y = t.minY,
            e.width = t.maxX - t.minX,
            e.height = t.maxY - t.minY
        }
    }
      , {addPoint: Y} = N
      , {tempPointBounds: X, setPoint: V, addPoint: j, toBounds: G} = N
      , {toOuterPoint: Z} = b
      , {float: K, fourNumber: q} = h
      , {floor: J, ceil: $} = Math;
    let Q, tt, et, it;
    const st = {}
      , nt = {}
      , ot = {
        tempBounds: {},
        set(t, e=0, i=0, s=0, n=0) {
            t.x = e,
            t.y = i,
            t.width = s,
            t.height = n
        },
        copy(t, e) {
            t.x = e.x,
            t.y = e.y,
            t.width = e.width,
            t.height = e.height
        },
        copyAndSpread(t, e, i, s, n) {
            const {x: o, y: r, width: a, height: h} = e;
            if (i instanceof Array) {
                const e = q(i);
                s ? rt.set(t, o + e[3], r + e[0], a - e[1] - e[3], h - e[2] - e[0]) : rt.set(t, o - e[3], r - e[0], a + e[1] + e[3], h + e[2] + e[0])
            } else
                s && (i = -i),
                rt.set(t, o - i, r - i, a + 2 * i, h + 2 * i);
            n && ("width" === n ? (t.y = r,
            t.height = h) : (t.x = o,
            t.width = a))
        },
        minX: t => t.width > 0 ? t.x : t.x + t.width,
        minY: t => t.height > 0 ? t.y : t.y + t.height,
        maxX: t => t.width > 0 ? t.x + t.width : t.x,
        maxY: t => t.height > 0 ? t.y + t.height : t.y,
        move(t, e, i) {
            t.x += e,
            t.y += i
        },
        getByMove: (t, e, i) => (t = Object.assign({}, t),
        rt.move(t, e, i),
        t),
        toOffsetOutBounds(t, e, i) {
            e ? ht(e, t) : e = t,
            i ? (e.offsetX = -(rt.maxX(i) - t.x),
            e.offsetY = -(rt.maxY(i) - t.y)) : (e.offsetX = t.x + t.width,
            e.offsetY = t.y + t.height),
            rt.move(e, -e.offsetX, -e.offsetY)
        },
        scale(t, e, i=e) {
            D.scale(t, e, i),
            t.width *= e,
            t.height *= i
        },
        scaleOf(t, e, i, s=i) {
            D.scaleOf(t, e, i, s),
            t.width *= i,
            t.height *= s
        },
        tempToOuterOf: (t, e) => (rt.copy(rt.tempBounds, t),
        rt.toOuterOf(rt.tempBounds, e),
        rt.tempBounds),
        getOuterOf: (t, e) => (t = Object.assign({}, t),
        rt.toOuterOf(t, e),
        t),
        toOuterOf(t, e, i) {
            if (i || (i = t),
            0 === e.b && 0 === e.c) {
                const {a: s, d: n} = e;
                s > 0 ? (i.width = t.width * s,
                i.x = e.e + t.x * s) : (i.width = t.width * -s,
                i.x = e.e + t.x * s - i.width),
                n > 0 ? (i.height = t.height * n,
                i.y = e.f + t.y * n) : (i.height = t.height * -n,
                i.y = e.f + t.y * n - i.height)
            } else
                st.x = t.x,
                st.y = t.y,
                Z(e, st, nt),
                V(X, nt.x, nt.y),
                st.x = t.x + t.width,
                Z(e, st, nt),
                j(X, nt.x, nt.y),
                st.y = t.y + t.height,
                Z(e, st, nt),
                j(X, nt.x, nt.y),
                st.x = t.x,
                Z(e, st, nt),
                j(X, nt.x, nt.y),
                G(X, i)
        },
        toInnerOf(t, e, i) {
            i || (i = t),
            rt.move(i, -e.e, -e.f),
            rt.scale(i, 1 / e.a, 1 / e.d)
        },
        getFitMatrix(t, e, i=1) {
            const s = Math.min(i, Math.min(t.width / e.width, t.height / e.height));
            return new U(s,0,0,s,-e.x * s,-e.y * s)
        },
        getSpread(t, e, i) {
            const s = {};
            return rt.copyAndSpread(s, t, e, !1, i),
            s
        },
        spread(t, e, i) {
            rt.copyAndSpread(t, t, e, !1, i)
        },
        shrink(t, e, i) {
            rt.copyAndSpread(t, t, e, !0, i)
        },
        ceil(t) {
            const {x: e, y: i} = t;
            t.x = J(t.x),
            t.y = J(t.y),
            t.width = e > t.x ? $(t.width + e - t.x) : $(t.width),
            t.height = i > t.y ? $(t.height + i - t.y) : $(t.height)
        },
        unsign(t) {
            t.width < 0 && (t.x += t.width,
            t.width = -t.width),
            t.height < 0 && (t.y += t.height,
            t.height = -t.height)
        },
        float(t, e) {
            t.x = K(t.x, e),
            t.y = K(t.y, e),
            t.width = K(t.width, e),
            t.height = K(t.height, e)
        },
        add(t, e, i) {
            Q = t.x + t.width,
            tt = t.y + t.height,
            et = e.x,
            it = e.y,
            i || (et += e.width,
            it += e.height),
            Q = Q > et ? Q : et,
            tt = tt > it ? tt : it,
            t.x = t.x < e.x ? t.x : e.x,
            t.y = t.y < e.y ? t.y : e.y,
            t.width = Q - t.x,
            t.height = tt - t.y
        },
        addList(t, e) {
            rt.setListWithFn(t, e, void 0, !0)
        },
        setList(t, e, i=!1) {
            rt.setListWithFn(t, e, void 0, i)
        },
        addListWithFn(t, e, i) {
            rt.setListWithFn(t, e, i, !0)
        },
        setListWithFn(t, e, i, s=!1) {
            let n, o = !0;
            for (let r = 0, a = e.length; r < a; r++)
                n = i ? i(e[r]) : e[r],
                n && (n.width || n.height) && (o ? (o = !1,
                s || ht(t, n)) : at(t, n));
            o && rt.reset(t)
        },
        setPoints(t, e) {
            e.forEach(( (t, e) => 0 === e ? V(X, t.x, t.y) : j(X, t.x, t.y))),
            G(X, t)
        },
        setPoint(t, e) {
            rt.set(t, e.x, e.y)
        },
        addPoint(t, e) {
            at(t, e, !0)
        },
        getPoints(t) {
            const {x: e, y: i, width: s, height: n} = t;
            return [{
                x: e,
                y: i
            }, {
                x: e + s,
                y: i
            }, {
                x: e + s,
                y: i + n
            }, {
                x: e,
                y: i + n
            }]
        },
        hitRadiusPoint: (t, e, i) => (i && (e = D.tempToInnerRadiusPointOf(e, i)),
        e.x >= t.x - e.radiusX && e.x <= t.x + t.width + e.radiusX && e.y >= t.y - e.radiusY && e.y <= t.y + t.height + e.radiusY),
        hitPoint: (t, e, i) => (i && (e = D.tempToInnerOf(e, i)),
        e.x >= t.x && e.x <= t.x + t.width && e.y >= t.y && e.y <= t.y + t.height),
        hit: (t, e, i) => (i && (e = rt.tempToOuterOf(e, i)),
        !(t.y + t.height < e.y || e.y + e.height < t.y || t.x + t.width < e.x || e.x + e.width < t.x)),
        includes: (t, e, i) => (i && (e = rt.tempToOuterOf(e, i)),
        t.x <= e.x && t.y <= e.y && t.x + t.width >= e.x + e.width && t.y + t.height >= e.y + e.height),
        getIntersectData(t, e, i) {
            if (i && (e = rt.tempToOuterOf(e, i)),
            !rt.hit(t, e))
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            let {x: s, y: n, width: o, height: r} = e;
            return Q = s + o,
            tt = n + r,
            et = t.x + t.width,
            it = t.y + t.height,
            s = s > t.x ? s : t.x,
            n = n > t.y ? n : t.y,
            Q = Q < et ? Q : et,
            tt = tt < it ? tt : it,
            o = Q - s,
            r = tt - n,
            {
                x: s,
                y: n,
                width: o,
                height: r
            }
        },
        intersect(t, e, i) {
            rt.copy(t, rt.getIntersectData(t, e, i))
        },
        isSame: (t, e) => t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height,
        isEmpty: t => 0 === t.x && 0 === t.y && 0 === t.width && 0 === t.height,
        reset(t) {
            rt.set(t)
        }
    }
      , rt = ot
      , {add: at, copy: ht} = rt;
    class lt {
        get minX() {
            return ot.minX(this)
        }
        get minY() {
            return ot.minY(this)
        }
        get maxX() {
            return ot.maxX(this)
        }
        get maxY() {
            return ot.maxY(this)
        }
        constructor(t, e, i, s) {
            this.set(t, e, i, s)
        }
        set(t, e, i, s) {
            return "object" == typeof t ? ot.copy(this, t) : ot.set(this, t, e, i, s),
            this
        }
        get() {
            const {x: t, y: e, width: i, height: s} = this;
            return {
                x: t,
                y: e,
                width: i,
                height: s
            }
        }
        clone() {
            return new lt(this)
        }
        move(t, e) {
            return ot.move(this, t, e),
            this
        }
        scale(t, e) {
            return ot.scale(this, t, e),
            this
        }
        scaleOf(t, e, i) {
            return ot.scaleOf(this, t, e, i),
            this
        }
        toOuterOf(t, e) {
            return ot.toOuterOf(this, t, e),
            this
        }
        toInnerOf(t, e) {
            return ot.toInnerOf(this, t, e),
            this
        }
        getFitMatrix(t, e) {
            return ot.getFitMatrix(this, t, e)
        }
        spread(t, e) {
            return ot.spread(this, t, e),
            this
        }
        shrink(t, e) {
            return ot.shrink(this, t, e),
            this
        }
        ceil() {
            return ot.ceil(this),
            this
        }
        unsign() {
            return ot.unsign(this),
            this
        }
        float(t) {
            return ot.float(this, t),
            this
        }
        add(t) {
            return ot.add(this, t),
            this
        }
        addList(t) {
            return ot.setList(this, t, !0),
            this
        }
        setList(t) {
            return ot.setList(this, t),
            this
        }
        addListWithFn(t, e) {
            return ot.setListWithFn(this, t, e, !0),
            this
        }
        setListWithFn(t, e) {
            return ot.setListWithFn(this, t, e),
            this
        }
        setPoint(t) {
            return ot.setPoint(this, t),
            this
        }
        setPoints(t) {
            return ot.setPoints(this, t),
            this
        }
        addPoint(t) {
            return ot.addPoint(this, t),
            this
        }
        getPoints() {
            return ot.getPoints(this)
        }
        hitPoint(t, e) {
            return ot.hitPoint(this, t, e)
        }
        hitRadiusPoint(t, e) {
            return ot.hitRadiusPoint(this, t, e)
        }
        hit(t, e) {
            return ot.hit(this, t, e)
        }
        includes(t, e) {
            return ot.includes(this, t, e)
        }
        intersect(t, e) {
            return ot.intersect(this, t, e),
            this
        }
        getIntersect(t, e) {
            return new lt(ot.getIntersectData(this, t, e))
        }
        isSame(t) {
            return ot.isSame(this, t)
        }
        isEmpty() {
            return ot.isEmpty(this)
        }
        reset() {
            ot.reset(this)
        }
    }
    const dt = new lt;
    class ct {
        constructor(t, e, i, s, n, o) {
            "object" == typeof t ? this.copy(t) : this.set(t, e, i, s, n, o)
        }
        set(t=0, e=0, i=0, s=0, n=0, o=0) {
            this.top = t,
            this.right = e,
            this.bottom = i,
            this.left = s,
            this.width = n,
            this.height = o
        }
        copy(t) {
            const {top: e, right: i, bottom: s, left: n, width: o, height: r} = t;
            this.set(e, i, s, n, o, r)
        }
        getBoundsFrom(t) {
            const {top: e, right: i, bottom: s, left: n, width: o, height: r} = this;
            return new lt(n,e,o || t.width - n - i,r || t.height - e - s)
        }
    }
    var ut, pt;
    t.Direction4 = void 0,
    (ut = t.Direction4 || (t.Direction4 = {}))[ut.top = 0] = "top",
    ut[ut.right = 1] = "right",
    ut[ut.bottom = 2] = "bottom",
    ut[ut.left = 3] = "left",
    t.Direction9 = void 0,
    (pt = t.Direction9 || (t.Direction9 = {}))[pt.topLeft = 0] = "topLeft",
    pt[pt.top = 1] = "top",
    pt[pt.topRight = 2] = "topRight",
    pt[pt.right = 3] = "right",
    pt[pt.bottomRight = 4] = "bottomRight",
    pt[pt.bottom = 5] = "bottom",
    pt[pt.bottomLeft = 6] = "bottomLeft",
    pt[pt.left = 7] = "left",
    pt[pt.center = 8] = "center",
    pt[pt["top-left"] = 0] = "top-left",
    pt[pt["top-right"] = 2] = "top-right",
    pt[pt["bottom-right"] = 4] = "bottom-right",
    pt[pt["bottom-left"] = 6] = "bottom-left";
    const _t = [{
        x: 0,
        y: 0
    }, {
        x: .5,
        y: 0
    }, {
        x: 1,
        y: 0
    }, {
        x: 1,
        y: .5
    }, {
        x: 1,
        y: 1
    }, {
        x: .5,
        y: 1
    }, {
        x: 0,
        y: 1
    }, {
        x: 0,
        y: .5
    }, {
        x: .5,
        y: .5
    }];
    _t.forEach((t => t.type = "percent"));
    const gt = {
        directionData: _t,
        tempPoint: {},
        get: ft,
        toPoint(t, e, i, s, n) {
            const o = ft(t);
            i.x = o.x,
            i.y = o.y,
            "percent" === o.type && (i.x *= e.width,
            i.y *= e.height,
            n && (i.x -= n.x,
            i.y -= n.y,
            o.x && (i.x -= 1 === o.x ? n.width : .5 === o.x ? o.x * n.width : 0),
            o.y && (i.y -= 1 === o.y ? n.height : .5 === o.y ? o.y * n.height : 0))),
            s || (i.x += e.x,
            i.y += e.y)
        }
    };
    function ft(e) {
        return "string" == typeof e ? _t[t.Direction9[e]] : e
    }
    const {toPoint: yt} = gt
      , mt = {
        toPoint(t, e, i, s, n) {
            yt(t, i, s, n, e)
        }
    }
      , vt = {
        0: 1,
        1: 1,
        2: 1,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        ".": 1,
        e: 1,
        E: 1
    };
    class wt {
        constructor(t) {
            this.repeatMap = {},
            this.name = t
        }
        static get(t) {
            return new wt(t)
        }
        static set filter(t) {
            this.filterList = xt(t)
        }
        static set exclude(t) {
            this.excludeList = xt(t)
        }
        log(...t) {
            if (bt.enable) {
                if (bt.filterList.length && bt.filterList.every((t => t !== this.name)))
                    return;
                if (bt.excludeList.length && bt.excludeList.some((t => t === this.name)))
                    return;
                console.log("%c" + this.name, "color:#21ae62", ...t)
            }
        }
        tip(...t) {
            bt.enable && this.warn(...t)
        }
        warn(...t) {
            bt.showWarn && console.warn(this.name, ...t)
        }
        repeat(t, ...e) {
            this.repeatMap[t] || (this.warn("repeat:" + t, ...e),
            this.repeatMap[t] = !0)
        }
        error(...t) {
            try {
                throw new Error
            } catch (e) {
                console.error(this.name, ...t, e)
            }
        }
    }
    function xt(t) {
        return t ? "string" == typeof t && (t = [t]) : t = [],
        t
    }
    wt.filterList = [],
    wt.excludeList = [],
    wt.showWarn = !0;
    const bt = wt
      , Et = wt.get("RunTime")
      , kt = {
        currentId: 0,
        currentName: "",
        idMap: {},
        nameMap: {},
        nameToIdMap: {},
        start(t, e) {
            const i = s.create(s.RUNTIME);
            return Tt.currentId = Tt.idMap[i] = e ? performance.now() : Date.now(),
            Tt.currentName = Tt.nameMap[i] = t,
            Tt.nameToIdMap[t] = i,
            i
        },
        end(t, e) {
            const i = Tt.idMap[t]
              , s = Tt.nameMap[t]
              , n = e ? (performance.now() - i) / 1e3 : Date.now() - i;
            Tt.idMap[t] = Tt.nameMap[t] = Tt.nameToIdMap[s] = void 0,
            Et.log(s, n, "ms")
        },
        endOfName(t, e) {
            const i = Tt.nameToIdMap[t];
            void 0 !== i && Tt.end(i, e)
        }
    }
      , Tt = kt
      , Bt = {
        list: {},
        add(t) {
            this.list[t] = !0
        },
        check(t, e) {
            const i = this.list[t];
            return !i && e && this.need(t),
            i
        },
        need(t) {
            console.error("need plugin: @leafer-in/" + t)
        }
    }
      , Lt = wt.get("UICreator")
      , Pt = {
        list: {},
        register(t) {
            const {__tag: e} = t.prototype;
            Ct[e] && Lt.repeat(e),
            Ct[e] = t
        },
        get(t, e, i, s, n, o) {
            Ct[t] || Lt.error("not register " + t);
            const r = new Ct[t](e);
            return void 0 !== i && (r.x = i,
            s && (r.y = s),
            n && (r.width = n),
            o && (r.height = o)),
            r
        }
    }
      , {list: Ct} = Pt
      , Rt = wt.get("EventCreator")
      , St = {
        nameList: {},
        register(t) {
            let e;
            Object.keys(t).forEach((i => {
                e = t[i],
                "string" == typeof e && (Ot[e] && Rt.repeat(e),
                Ot[e] = t)
            }
            ))
        },
        changeName(t, e) {
            const i = Ot[t];
            if (i) {
                const s = Object.keys(i).find((e => i[e] === t));
                s && (i[s] = e,
                Ot[e] = i)
            }
        },
        has(t) {
            return !!this.nameList[t]
        },
        get: (t, ...e) => new Ot[t](...e)
    }
      , {nameList: Ot} = St;
    class Dt {
        constructor() {
            this.list = []
        }
        add(t) {
            t.manager = this,
            this.list.push(t)
        }
        get(t) {
            let e;
            const {list: s} = this;
            for (let i = 0, n = s.length; i < n; i++)
                if (e = s[i],
                e.recycled && e.isSameSize(t))
                    return e.recycled = !1,
                    e.manager || (e.manager = this),
                    e;
            const n = i.canvas(t);
            return this.add(n),
            n
        }
        recycle(t) {
            t.recycled = !0
        }
        clearRecycled() {
            let t;
            const e = [];
            for (let i = 0, s = this.list.length; i < s; i++)
                t = this.list[i],
                t.recycled ? t.destroy() : e.push(t);
            this.list = e
        }
        clear() {
            this.list.forEach((t => {
                t.destroy()
            }
            )),
            this.list.length = 0
        }
        destroy() {
            this.clear()
        }
    }
    const Mt = {
        default: (t, e) => (It(e, t),
        It(t, e),
        t),
        assign(t, e, i) {
            let s;
            Object.keys(e).forEach((n => {
                var o, r;
                if (s = e[n],
                (null == s ? void 0 : s.constructor) === Object && (null === (o = t[n]) || void 0 === o ? void 0 : o.constructor) === Object)
                    return It(t[n], e[n], i && i[n]);
                i && n in i ? (null === (r = i[n]) || void 0 === r ? void 0 : r.constructor) === Object && It(t[n] = {}, e[n], i[n]) : t[n] = e[n]
            }
            ))
        },
        copyAttrs: (t, e, i) => (i.forEach((i => {
            void 0 !== e[i] && (t[i] = e[i])
        }
        )),
        t),
        clone: t => JSON.parse(JSON.stringify(t)),
        toMap(t) {
            const e = {};
            for (let i = 0, s = t.length; i < s; i++)
                e[t[i]] = !0;
            return e
        }
    }
      , {assign: It} = Mt;
    class At {
        get __useNaturalRatio() {
            return !0
        }
        get __isLinePath() {
            const {path: t} = this;
            return t && 6 === t.length && 1 === t[0]
        }
        get __blendMode() {
            if (this.eraser && "path" !== this.eraser)
                return "destination-out";
            const {blendMode: t} = this;
            return "pass-through" === t ? null : t
        }
        constructor(t) {
            this.__leaf = t
        }
        __get(t) {
            if (this.__input) {
                const e = this.__input[t];
                if (void 0 !== e)
                    return e
            }
            return this[t]
        }
        __getData() {
            const t = {
                tag: this.__leaf.tag
            }
              , {__input: e} = this;
            let i;
            for (let s in this)
                "_" !== s[0] && (i = e ? e[s] : void 0,
                t[s] = void 0 === i ? this[s] : i);
            return t
        }
        __setInput(t, e) {
            this.__input || (this.__input = {}),
            this.__input[t] = e
        }
        __getInput(t) {
            if (this.__input) {
                const e = this.__input[t];
                if (void 0 !== e)
                    return e
            }
            if ("path" !== t || this.__pathInputed)
                return this["_" + t]
        }
        __removeInput(t) {
            this.__input && void 0 !== this.__input[t] && (this.__input[t] = void 0)
        }
        __getInputData(t, e) {
            const i = {};
            if (t)
                if (t instanceof Array)
                    for (let e of t)
                        i[e] = this.__getInput(e);
                else
                    for (let e in t)
                        i[e] = this.__getInput(e);
            else {
                let t, e, {__input: s} = this;
                i.tag = this.__leaf.tag;
                for (let n in this)
                    if ("_" !== n[0] && (t = this["_" + n],
                    void 0 !== t)) {
                        if ("path" === n && !this.__pathInputed)
                            continue;
                        e = s ? s[n] : void 0,
                        i[n] = void 0 === e ? t : e
                    }
            }
            if (e && e.matrix) {
                const {a: t, b: e, c: s, d: n, e: o, f: r} = this.__leaf.__localMatrix;
                i.matrix = {
                    a: t,
                    b: e,
                    c: s,
                    d: n,
                    e: o,
                    f: r
                }
            }
            return i
        }
        __setMiddle(t, e) {
            this.__middle || (this.__middle = {}),
            this.__middle[t] = e
        }
        __getMiddle(t) {
            return this.__middle && this.__middle[t]
        }
        __checkSingle() {
            const t = this;
            if ("pass-through" === t.blendMode) {
                const e = this.__leaf;
                t.opacity < 1 && (e.isBranch || t.__hasMultiPaint) || e.__hasEraser || t.eraser ? t.__single = !0 : t.__single && (t.__single = !1)
            } else
                t.__single = !0
        }
        __removeNaturalSize() {
            this.__naturalWidth = this.__naturalHeight = void 0
        }
        destroy() {
            this.__input = this.__middle = null
        }
    }
    var Wt;
    t.Answer = void 0,
    (Wt = t.Answer || (t.Answer = {}))[Wt.No = 0] = "No",
    Wt[Wt.Yes = 1] = "Yes",
    Wt[Wt.NoAndSkip = 2] = "NoAndSkip",
    Wt[Wt.YesAndSkip = 3] = "YesAndSkip";
    function zt(t, e, i, s) {
        var n, o = arguments.length, r = o < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, i) : s;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            r = Reflect.decorate(t, e, i, s);
        else
            for (var a = t.length - 1; a >= 0; a--)
                (n = t[a]) && (r = (o < 3 ? n(r) : o > 3 ? n(e, i, r) : n(e, i)) || r);
        return o > 3 && r && Object.defineProperty(e, i, r),
        r
    }
    function Ft(t, e, i, s) {
        return new (i || (i = Promise))((function(n, o) {
            function r(t) {
                try {
                    h(s.next(t))
                } catch (t) {
                    o(t)
                }
            }
            function a(t) {
                try {
                    h(s.throw(t))
                } catch (t) {
                    o(t)
                }
            }
            function h(t) {
                var e;
                t.done ? n(t.value) : (e = t.value,
                e instanceof i ? e : new i((function(t) {
                    t(e)
                }
                ))).then(r, a)
            }
            h((s = s.apply(t, e || [])).next())
        }
        ))
    }
    function Ut(t) {
        return (e, i) => {
            t || (t = i),
            Object.defineProperty(e, i, {
                get() {
                    return this.context[t]
                },
                set(e) {
                    this.context[t] = e
                }
            })
        }
    }
    "function" == typeof SuppressedError && SuppressedError;
    const Ht = [];
    function Nt() {
        return (t, e) => {
            Ht.push(e)
        }
    }
    const Yt = [];
    class Xt {
        set blendMode(t) {
            "normal" === t && (t = "source-over"),
            this.context.globalCompositeOperation = t
        }
        get blendMode() {
            return this.context.globalCompositeOperation
        }
        set dashPattern(t) {
            this.context.setLineDash(t || Yt)
        }
        get dashPattern() {
            return this.context.getLineDash()
        }
        __bindContext() {
            let t;
            Ht.forEach((e => {
                t = this.context[e],
                t && (this[e] = t.bind(this.context))
            }
            )),
            this.textBaseline = "alphabetic"
        }
        setTransform(t, e, i, s, n, o) {}
        resetTransform() {}
        getTransform() {}
        save() {}
        restore() {}
        transform(t, e, i, s, n, o) {
            "object" == typeof t ? this.context.transform(t.a, t.b, t.c, t.d, t.e, t.f) : this.context.transform(t, e, i, s, n, o)
        }
        translate(t, e) {}
        scale(t, e) {}
        rotate(t) {}
        fill(t, e) {}
        stroke(t) {}
        clip(t, e) {}
        fillRect(t, e, i, s) {}
        strokeRect(t, e, i, s) {}
        clearRect(t, e, i, s) {}
        drawImage(t, e, i, s, n, o, r, a, h) {
            switch (arguments.length) {
            case 9:
                if (e < 0) {
                    const t = -e / s * a;
                    s += e,
                    e = 0,
                    o += t,
                    a -= t
                }
                if (i < 0) {
                    const t = -i / n * h;
                    n += i,
                    i = 0,
                    r += t,
                    h -= t
                }
                this.context.drawImage(t, e, i, s, n, o, r, a, h);
                break;
            case 5:
                this.context.drawImage(t, e, i, s, n);
                break;
            case 3:
                this.context.drawImage(t, e, i)
            }
        }
        beginPath() {}
        moveTo(t, e) {}
        lineTo(t, e) {}
        bezierCurveTo(t, e, i, s, n, o) {}
        quadraticCurveTo(t, e, i, s) {}
        closePath() {}
        arc(t, e, i, s, n, o) {}
        arcTo(t, e, i, s, n) {}
        ellipse(t, e, i, s, n, o, r, a) {}
        rect(t, e, i, s) {}
        roundRect(t, e, i, s, n) {}
        createConicGradient(t, e, i) {}
        createLinearGradient(t, e, i, s) {}
        createPattern(t, e) {}
        createRadialGradient(t, e, i, s, n, o) {}
        fillText(t, e, i, s) {}
        measureText(t) {}
        strokeText(t, e, i, s) {}
        destroy() {
            this.context = null
        }
    }
    zt([Ut("imageSmoothingEnabled")], Xt.prototype, "smooth", void 0),
    zt([Ut("imageSmoothingQuality")], Xt.prototype, "smoothLevel", void 0),
    zt([Ut("globalAlpha")], Xt.prototype, "opacity", void 0),
    zt([Ut()], Xt.prototype, "fillStyle", void 0),
    zt([Ut()], Xt.prototype, "strokeStyle", void 0),
    zt([Ut("lineWidth")], Xt.prototype, "strokeWidth", void 0),
    zt([Ut("lineCap")], Xt.prototype, "strokeCap", void 0),
    zt([Ut("lineJoin")], Xt.prototype, "strokeJoin", void 0),
    zt([Ut("lineDashOffset")], Xt.prototype, "dashOffset", void 0),
    zt([Ut()], Xt.prototype, "miterLimit", void 0),
    zt([Ut()], Xt.prototype, "shadowBlur", void 0),
    zt([Ut()], Xt.prototype, "shadowColor", void 0),
    zt([Ut()], Xt.prototype, "shadowOffsetX", void 0),
    zt([Ut()], Xt.prototype, "shadowOffsetY", void 0),
    zt([Ut()], Xt.prototype, "filter", void 0),
    zt([Ut()], Xt.prototype, "font", void 0),
    zt([Ut()], Xt.prototype, "fontKerning", void 0),
    zt([Ut()], Xt.prototype, "fontStretch", void 0),
    zt([Ut()], Xt.prototype, "fontVariantCaps", void 0),
    zt([Ut()], Xt.prototype, "textAlign", void 0),
    zt([Ut()], Xt.prototype, "textBaseline", void 0),
    zt([Ut()], Xt.prototype, "textRendering", void 0),
    zt([Ut()], Xt.prototype, "wordSpacing", void 0),
    zt([Ut()], Xt.prototype, "letterSpacing", void 0),
    zt([Ut()], Xt.prototype, "direction", void 0),
    zt([Nt()], Xt.prototype, "setTransform", null),
    zt([Nt()], Xt.prototype, "resetTransform", null),
    zt([Nt()], Xt.prototype, "getTransform", null),
    zt([Nt()], Xt.prototype, "save", null),
    zt([Nt()], Xt.prototype, "restore", null),
    zt([Nt()], Xt.prototype, "translate", null),
    zt([Nt()], Xt.prototype, "scale", null),
    zt([Nt()], Xt.prototype, "rotate", null),
    zt([Nt()], Xt.prototype, "fill", null),
    zt([Nt()], Xt.prototype, "stroke", null),
    zt([Nt()], Xt.prototype, "clip", null),
    zt([Nt()], Xt.prototype, "fillRect", null),
    zt([Nt()], Xt.prototype, "strokeRect", null),
    zt([Nt()], Xt.prototype, "clearRect", null),
    zt([Nt()], Xt.prototype, "beginPath", null),
    zt([Nt()], Xt.prototype, "moveTo", null),
    zt([Nt()], Xt.prototype, "lineTo", null),
    zt([Nt()], Xt.prototype, "bezierCurveTo", null),
    zt([Nt()], Xt.prototype, "quadraticCurveTo", null),
    zt([Nt()], Xt.prototype, "closePath", null),
    zt([Nt()], Xt.prototype, "arc", null),
    zt([Nt()], Xt.prototype, "arcTo", null),
    zt([Nt()], Xt.prototype, "ellipse", null),
    zt([Nt()], Xt.prototype, "rect", null),
    zt([Nt()], Xt.prototype, "roundRect", null),
    zt([Nt()], Xt.prototype, "createConicGradient", null),
    zt([Nt()], Xt.prototype, "createLinearGradient", null),
    zt([Nt()], Xt.prototype, "createPattern", null),
    zt([Nt()], Xt.prototype, "createRadialGradient", null),
    zt([Nt()], Xt.prototype, "fillText", null),
    zt([Nt()], Xt.prototype, "measureText", null),
    zt([Nt()], Xt.prototype, "strokeText", null);
    const {copy: Vt} = b
      , jt = {
        width: 1,
        height: 1,
        pixelRatio: 1
    }
      , Gt = ["width", "height", "pixelRatio"];
    class Zt extends Xt {
        get width() {
            return this.size.width
        }
        get height() {
            return this.size.height
        }
        get pixelRatio() {
            return this.size.pixelRatio
        }
        get pixelWidth() {
            return this.width * this.pixelRatio
        }
        get pixelHeight() {
            return this.height * this.pixelRatio
        }
        get allowBackgroundColor() {
            return this.view && this.parentView
        }
        constructor(t, i) {
            super(),
            this.size = {},
            this.worldTransform = {},
            t || (t = jt),
            t.pixelRatio || (t.pixelRatio = e.devicePixelRatio),
            this.manager = i,
            this.innerId = s.create(s.CNAVAS);
            const {width: n, height: o, pixelRatio: r} = t;
            this.autoLayout = !n || !o,
            this.size.pixelRatio = r,
            this.config = t,
            this.init()
        }
        init() {}
        __createContext() {
            const {view: t} = this
              , {contextSettings: e} = this.config;
            this.context = e ? t.getContext("2d", e) : t.getContext("2d"),
            this.__bindContext()
        }
        export(t, e) {}
        toBlob(t, e) {}
        toDataURL(t, e) {}
        saveAs(t, e) {}
        resize(t) {
            if (this.isSameSize(t))
                return;
            let e;
            this.context && !this.unreal && this.width && (e = this.getSameCanvas(),
            e.copyWorld(this));
            const i = this.size;
            Mt.copyAttrs(i, t, Gt),
            Gt.forEach((t => i[t] || (i[t] = 1))),
            this.bounds = new lt(0,0,this.width,this.height),
            this.context && !this.unreal && (this.updateViewSize(),
            this.smooth = this.config.smooth),
            this.updateClientBounds(),
            this.context && !this.unreal && e && (this.clearWorld(e.bounds),
            this.copyWorld(e),
            e.recycle())
        }
        updateViewSize() {}
        updateClientBounds() {}
        getClientBounds(t) {
            return t && this.updateClientBounds(),
            this.clientBounds || this.bounds
        }
        startAutoLayout(t, e) {}
        stopAutoLayout() {}
        setCursor(t) {}
        setWorld(t, e) {
            const {pixelRatio: i} = this
              , s = this.worldTransform;
            if (e) {
                const {a: n, b: o, c: r, d: a, e: h, f: l} = e;
                this.setTransform(s.a = (t.a * n + t.b * r) * i, s.b = (t.a * o + t.b * a) * i, s.c = (t.c * n + t.d * r) * i, s.d = (t.c * o + t.d * a) * i, s.e = (t.e * n + t.f * r + h) * i, s.f = (t.e * o + t.f * a + l) * i)
            } else
                this.setTransform(s.a = t.a * i, s.b = t.b * i, s.c = t.c * i, s.d = t.d * i, s.e = t.e * i, s.f = t.f * i)
        }
        useWorldTransform(t) {
            t && (this.worldTransform = t);
            const e = this.worldTransform;
            e && this.setTransform(e.a, e.b, e.c, e.d, e.e, e.f)
        }
        setStroke(t, e, i) {
            e && (this.strokeWidth = e),
            t && (this.strokeStyle = t),
            i && this.setStrokeOptions(i)
        }
        setStrokeOptions(t) {
            this.strokeCap = "none" === t.strokeCap ? "butt" : t.strokeCap,
            this.strokeJoin = t.strokeJoin,
            this.dashPattern = t.dashPattern,
            this.dashOffset = t.dashOffset,
            this.miterLimit = t.miterLimit
        }
        saveBlendMode(t) {
            this.savedBlendMode = this.blendMode,
            this.blendMode = t
        }
        restoreBlendMode() {
            this.blendMode = this.savedBlendMode
        }
        hitFill(t, e) {
            return !0
        }
        hitStroke(t, e) {
            return !0
        }
        hitPixel(t, e, i=1) {
            return !0
        }
        setWorldShadow(t, e, i, s) {
            const {pixelRatio: n} = this;
            this.shadowOffsetX = t * n,
            this.shadowOffsetY = e * n,
            this.shadowBlur = i * n,
            this.shadowColor = s || "black"
        }
        setWorldBlur(t) {
            const {pixelRatio: e} = this;
            this.filter = `blur(${t * e}px)`
        }
        copyWorld(t, e, i, s) {
            if (s && (this.blendMode = s),
            e) {
                const {pixelRatio: s} = this;
                i || (i = e),
                this.drawImage(t.view, e.x * s, e.y * s, e.width * s, e.height * s, i.x * s, i.y * s, i.width * s, i.height * s)
            } else
                this.drawImage(t.view, 0, 0);
            s && (this.blendMode = "source-over")
        }
        copyWorldToInner(t, e, i, s) {
            if (s && (this.blendMode = s),
            e.b || e.c)
                this.save(),
                this.resetTransform(),
                this.copyWorld(t, e, ot.tempToOuterOf(i, e)),
                this.restore();
            else {
                const {pixelRatio: s} = this;
                this.drawImage(t.view, e.x * s, e.y * s, e.width * s, e.height * s, i.x, i.y, i.width, i.height)
            }
            s && (this.blendMode = "source-over")
        }
        copyWorldByReset(t, e, i, s, n) {
            this.resetTransform(),
            this.copyWorld(t, e, i, s),
            n || this.useWorldTransform()
        }
        useGrayscaleAlpha(t) {
            let e, i;
            this.setTempBounds(t, !0, !0);
            const {context: s} = this
              , n = s.getImageData(dt.x, dt.y, dt.width, dt.height)
              , {data: o} = n;
            for (let t = 0, s = o.length; t < s; t += 4)
                i = .299 * o[t] + .587 * o[t + 1] + .114 * o[t + 2],
                (e = o[t + 3]) && (o[t + 3] = 255 === e ? i : e * (i / 255));
            s.putImageData(n, dt.x, dt.y)
        }
        useMask(t, e, i) {
            this.copyWorld(t, e, i, "destination-in")
        }
        useEraser(t, e, i) {
            this.copyWorld(t, e, i, "destination-out")
        }
        fillWorld(t, e, i) {
            i && (this.blendMode = i),
            this.fillStyle = e,
            this.setTempBounds(t),
            this.fillRect(dt.x, dt.y, dt.width, dt.height),
            i && (this.blendMode = "source-over")
        }
        strokeWorld(t, e, i) {
            i && (this.blendMode = i),
            this.strokeStyle = e,
            this.setTempBounds(t),
            this.strokeRect(dt.x, dt.y, dt.width, dt.height),
            i && (this.blendMode = "source-over")
        }
        clearWorld(t, e) {
            this.setTempBounds(t, e),
            this.clearRect(dt.x, dt.y, dt.width, dt.height)
        }
        clipWorld(t, e) {
            this.beginPath(),
            this.setTempBounds(t, e),
            this.rect(dt.x, dt.y, dt.width, dt.height),
            this.clip()
        }
        clear() {
            const {pixelRatio: t} = this;
            this.clearRect(0, 0, this.width * t + 2, this.height * t + 2)
        }
        setTempBounds(t, e, i) {
            dt.set(t),
            i && dt.intersect(this.bounds),
            dt.scale(this.pixelRatio),
            e && dt.ceil()
        }
        isSameSize(t) {
            return this.width === t.width && this.height === t.height && this.pixelRatio === t.pixelRatio
        }
        getSameCanvas(t, e) {
            const s = this.manager ? this.manager.get(this.size) : i.canvas(Object.assign({}, this.size));
            return s.save(),
            t && (Vt(s.worldTransform, this.worldTransform),
            s.useWorldTransform()),
            e && (s.smooth = this.smooth),
            s
        }
        recycle(t) {
            this.recycled || (this.restore(),
            t ? this.clearWorld(t, !0) : this.clear(),
            this.manager ? this.manager.recycle(this) : this.destroy())
        }
        updateRender(t) {}
        unrealCanvas() {}
        destroy() {
            this.manager = this.view = this.parentView = null
        }
    }
    const Kt = {
        creator: {},
        parse(t, e) {},
        convertToCanvasData(t, e) {}
    }
      , qt = {
        N: 21,
        D: 22,
        X: 23,
        G: 24,
        F: 25,
        O: 26,
        P: 27,
        U: 28
    }
      , Jt = Object.assign({
        M: 1,
        m: 10,
        L: 2,
        l: 20,
        H: 3,
        h: 30,
        V: 4,
        v: 40,
        C: 5,
        c: 50,
        S: 6,
        s: 60,
        Q: 7,
        q: 70,
        T: 8,
        t: 80,
        A: 9,
        a: 90,
        Z: 11,
        z: 11,
        R: 12
    }, qt)
      , $t = {
        M: 3,
        m: 3,
        L: 3,
        l: 3,
        H: 2,
        h: 2,
        V: 2,
        v: 2,
        C: 7,
        c: 7,
        S: 5,
        s: 5,
        Q: 5,
        q: 5,
        T: 3,
        t: 3,
        A: 8,
        a: 8,
        Z: 1,
        z: 1,
        N: 5,
        D: 9,
        X: 6,
        G: 9,
        F: 5,
        O: 7,
        P: 4,
        U: 6
    }
      , Qt = {
        m: 10,
        l: 20,
        H: 3,
        h: 30,
        V: 4,
        v: 40,
        c: 50,
        S: 6,
        s: 60,
        q: 70,
        T: 8,
        t: 80,
        A: 9,
        a: 90
    }
      , te = Object.assign(Object.assign({}, Qt), qt)
      , ee = Jt
      , ie = {};
    for (let t in ee)
        ie[ee[t]] = t;
    const se = {};
    for (let t in ee)
        se[ee[t]] = $t[t];
    const ne = {
        drawRoundRect(t, e, i, s, n, o) {
            const r = h.fourNumber(o, Math.min(s / 2, n / 2))
              , a = e + s
              , l = i + n;
            r[0] ? t.moveTo(e + r[0], i) : t.moveTo(e, i),
            r[1] ? t.arcTo(a, i, a, l, r[1]) : t.lineTo(a, i),
            r[2] ? t.arcTo(a, l, e, l, r[2]) : t.lineTo(a, l),
            r[3] ? t.arcTo(e, l, e, i, r[3]) : t.lineTo(e, l),
            r[0] ? t.arcTo(e, i, a, i, r[0]) : t.lineTo(e, i)
        }
    }
      , {sin: oe, cos: re, atan2: ae, ceil: he, abs: le, PI: de, sqrt: ce, pow: ue} = Math
      , {setPoint: pe, addPoint: _e} = N
      , {set: ge, toNumberPoints: fe} = D
      , {M: ye, L: me, C: ve, Q: we, Z: xe} = Jt
      , be = {}
      , Ee = {
        points(t, e, i, s) {
            let n = fe(e);
            if (t.push(ye, n[0], n[1]),
            i && n.length > 5) {
                let e, o, r, a, h, l, d, c, u, p, _, g, f, y = n.length;
                const m = !0 === i ? .5 : i;
                s && (n = [n[y - 2], n[y - 1], ...n, n[0], n[1], n[2], n[3]],
                y = n.length);
                for (let i = 2; i < y - 2; i += 2)
                    e = n[i - 2],
                    o = n[i - 1],
                    r = n[i],
                    a = n[i + 1],
                    h = n[i + 2],
                    l = n[i + 3],
                    _ = ce(ue(r - e, 2) + ue(a - o, 2)),
                    g = ce(ue(h - r, 2) + ue(l - a, 2)),
                    f = _ + g,
                    _ = m * _ / f,
                    g = m * g / f,
                    h -= e,
                    l -= o,
                    d = r - _ * h,
                    c = a - _ * l,
                    2 === i ? s || t.push(we, d, c, r, a) : t.push(ve, u, p, d, c, r, a),
                    u = r + g * h,
                    p = a + g * l;
                s || t.push(we, u, p, n[y - 2], n[y - 1])
            } else
                for (let e = 2, i = n.length; e < i; e += 2)
                    t.push(me, n[e], n[e + 1]);
            s && t.push(xe)
        },
        rect(t, e, i, s, n) {
            Kt.creator.path = t,
            Kt.creator.moveTo(e, i).lineTo(e + s, i).lineTo(e + s, i + n).lineTo(e, i + n).lineTo(e, i)
        },
        roundRect(t, e, i, s, n, o) {
            Kt.creator.path = [],
            ne.drawRoundRect(Kt.creator, e, i, s, n, o),
            t.push(...Kt.convertToCanvasData(Kt.creator.path, !0))
        },
        arcTo(t, e, i, s, n, o, r, a, h, u, p) {
            const _ = s - e
              , g = n - i
              , f = o - s
              , y = r - n;
            let m = ae(g, _)
              , v = ae(y, f)
              , w = v - m;
            if (w < 0 && (w += d),
            w === de || le(_ + g) < 1e-12 || le(f + y) < 1e-12)
                return t && t.push(me, s, n),
                h && (pe(h, e, i),
                _e(h, s, n)),
                p && ge(p, e, i),
                void (u && ge(u, s, n));
            const x = _ * y - f * g < 0
              , b = x ? -1 : 1
              , E = a / re(w / 2)
              , k = s + E * re(m + w / 2 + c * b)
              , T = n + E * oe(m + w / 2 + c * b);
            return m -= c * b,
            v -= c * b,
            Be(t, k, T, a, a, 0, m / l, v / l, x, h, u, p)
        },
        arc: (t, e, i, s, n, o, r, a, h, l) => Be(t, e, i, s, s, 0, n, o, r, a, h, l),
        ellipse(t, e, i, s, n, o, r, a, h, u, p, _) {
            const g = o * l
              , f = oe(g)
              , y = re(g);
            let m = r * l
              , v = a * l;
            m > de && (m -= d),
            v < 0 && (v += d);
            let w = v - m;
            w < 0 ? w += d : w > d && (w -= d),
            h && (w -= d);
            const x = he(le(w / c))
              , b = w / x
              , E = oe(b / 4)
              , k = 8 / 3 * E * E / oe(b / 2);
            v = m + b;
            let T, B, L, P, C, R, S, O, D = re(m), M = oe(m), I = L = y * s * D - f * n * M, A = P = f * s * D + y * n * M, W = e + L, z = i + P;
            t && t.push(t.length ? me : ye, W, z),
            u && pe(u, W, z),
            _ && ge(_, W, z);
            for (let o = 0; o < x; o++)
                T = re(v),
                B = oe(v),
                L = y * s * T - f * n * B,
                P = f * s * T + y * n * B,
                C = e + I - k * (y * s * M + f * n * D),
                R = i + A - k * (f * s * M - y * n * D),
                S = e + L + k * (y * s * B + f * n * T),
                O = i + P + k * (f * s * B - y * n * T),
                t && t.push(ve, C, R, S, O, e + L, i + P),
                u && Te(e + I, i + A, C, R, S, O, e + L, i + P, u, !0),
                I = L,
                A = P,
                D = T,
                M = B,
                m = v,
                v += b;
            p && ge(p, e + L, i + P)
        },
        quadraticCurveTo(t, e, i, s, n, o, r) {
            t.push(ve, (e + 2 * s) / 3, (i + 2 * n) / 3, (o + 2 * s) / 3, (r + 2 * n) / 3, o, r)
        },
        toTwoPointBoundsByQuadraticCurve(t, e, i, s, n, o, r, a) {
            Te(t, e, (t + 2 * i) / 3, (e + 2 * s) / 3, (n + 2 * i) / 3, (o + 2 * s) / 3, n, o, r, a)
        },
        toTwoPointBounds(t, e, i, s, n, o, r, a, h, l) {
            const d = [];
            let c, u, p, _, g, f, y, m, v = t, w = i, x = n, b = r;
            for (let t = 0; t < 2; ++t)
                if (1 == t && (v = e,
                w = s,
                x = o,
                b = a),
                c = -3 * v + 9 * w - 9 * x + 3 * b,
                u = 6 * v - 12 * w + 6 * x,
                p = 3 * w - 3 * v,
                Math.abs(c) < 1e-12) {
                    if (Math.abs(u) < 1e-12)
                        continue;
                    _ = -p / u,
                    0 < _ && _ < 1 && d.push(_)
                } else
                    y = u * u - 4 * p * c,
                    m = Math.sqrt(y),
                    y < 0 || (g = (-u + m) / (2 * c),
                    0 < g && g < 1 && d.push(g),
                    f = (-u - m) / (2 * c),
                    0 < f && f < 1 && d.push(f));
            l ? _e(h, t, e) : pe(h, t, e),
            _e(h, r, a);
            for (let l = 0, c = d.length; l < c; l++)
                ke(d[l], t, e, i, s, n, o, r, a, be),
                _e(h, be.x, be.y)
        },
        getPointAndSet(t, e, i, s, n, o, r, a, h, l) {
            const d = 1 - t
              , c = d * d * d
              , u = 3 * d * d * t
              , p = 3 * d * t * t
              , _ = t * t * t;
            l.x = c * e + u * s + p * o + _ * a,
            l.y = c * i + u * n + p * r + _ * h
        },
        getPoint(t, e, i, s, n, o, r, a, h) {
            const l = {};
            return ke(t, e, i, s, n, o, r, a, h, l),
            l
        }
    }
      , {getPointAndSet: ke, toTwoPointBounds: Te, ellipse: Be} = Ee
      , {sin: Le, cos: Pe, sqrt: Ce, atan2: Re} = Math
      , {ellipse: Se} = Ee
      , Oe = {
        ellipticalArc(t, i, s, n, o, r, a, h, c, u, p) {
            const _ = (c - i) / 2
              , g = (u - s) / 2
              , f = r * l
              , y = Le(f)
              , m = Pe(f)
              , v = -m * _ - y * g
              , w = -m * g + y * _
              , x = n * n
              , b = o * o
              , E = w * w
              , k = v * v
              , T = x * b - x * E - b * k;
            let B = 0;
            if (T < 0) {
                const t = Ce(1 - T / (x * b));
                n *= t,
                o *= t
            } else
                B = (a === h ? -1 : 1) * Ce(T / (x * E + b * k));
            const L = B * n * w / o
              , P = -B * o * v / n
              , C = Re((w - P) / o, (v - L) / n)
              , R = Re((-w - P) / o, (-v - L) / n);
            let S = R - C;
            0 === h && S > 0 ? S -= d : 1 === h && S < 0 && (S += d);
            const O = i + _ + m * L - y * P
              , D = s + g + y * L + m * P
              , M = S < 0 ? 1 : 0;
            p || e.ellipseToCurve ? Se(t, O, D, n, o, r, C / l, R / l, M) : n !== o || r ? t.push(Jt.G, O, D, n, o, r, C / l, R / l, M) : t.push(Jt.O, O, D, n, C / l, R / l, M)
        }
    }
      , {M: De, m: Me, L: Ie, l: Ae, H: We, h: ze, V: Fe, v: Ue, C: He, c: Ne, S: Ye, s: Xe, Q: Ve, q: je, T: Ge, t: Ze, A: Ke, a: qe, Z: Je, z: $e, N: Qe, D: ti, X: ei, G: ii, F: si, O: ni, P: oi, U: ri} = Jt
      , {rect: ai, roundRect: hi, arcTo: li, arc: di, ellipse: ci, quadraticCurveTo: ui} = Ee
      , {ellipticalArc: pi} = Oe
      , _i = wt.get("PathConvert")
      , gi = {}
      , fi = {
        current: {
            dot: 0
        },
        stringify(t, e) {
            let i, s, n, o = 0, r = t.length, a = "";
            for (; o < r; ) {
                s = t[o],
                i = se[s],
                a += s === n ? " " : ie[s];
                for (let s = 1; s < i; s++)
                    a += h.float(t[o + s], e),
                    s === i - 1 || (a += " ");
                n = s,
                o += i
            }
            return a
        },
        parse(t, e) {
            let i, s, n, o = "";
            const r = []
              , a = e ? te : Qt;
            for (let e = 0, h = t.length; e < h; e++)
                s = t[e],
                vt[s] ? ("." === s && (yi.dot && (mi(r, o),
                o = ""),
                yi.dot++),
                "0" === o && "." !== s && (mi(r, o),
                o = ""),
                o += s) : Jt[s] ? (o && (mi(r, o),
                o = ""),
                yi.name = Jt[s],
                yi.length = $t[s],
                yi.index = 0,
                mi(r, yi.name),
                !i && a[s] && (i = !0)) : "-" === s || "+" === s ? "e" === n || "E" === n ? o += s : (o && mi(r, o),
                o = s) : o && (mi(r, o),
                o = ""),
                n = s;
            return o && mi(r, o),
            i ? fi.toCanvasData(r, e) : r
        },
        toCanvasData(t, e) {
            let i, s, n, o, r, a = 0, h = 0, l = 0, d = 0, c = 0, u = t.length;
            const p = [];
            for (; c < u; ) {
                switch (n = t[c],
                n) {
                case Me:
                    t[c + 1] += a,
                    t[c + 2] += h;
                case De:
                    a = t[c + 1],
                    h = t[c + 2],
                    p.push(De, a, h),
                    c += 3;
                    break;
                case ze:
                    t[c + 1] += a;
                case We:
                    a = t[c + 1],
                    p.push(Ie, a, h),
                    c += 2;
                    break;
                case Ue:
                    t[c + 1] += h;
                case Fe:
                    h = t[c + 1],
                    p.push(Ie, a, h),
                    c += 2;
                    break;
                case Ae:
                    t[c + 1] += a,
                    t[c + 2] += h;
                case Ie:
                    a = t[c + 1],
                    h = t[c + 2],
                    p.push(Ie, a, h),
                    c += 3;
                    break;
                case Xe:
                    t[c + 1] += a,
                    t[c + 2] += h,
                    t[c + 3] += a,
                    t[c + 4] += h,
                    n = Ye;
                case Ye:
                    r = o === He || o === Ye,
                    l = r ? 2 * a - i : t[c + 1],
                    d = r ? 2 * h - s : t[c + 2],
                    i = t[c + 1],
                    s = t[c + 2],
                    a = t[c + 3],
                    h = t[c + 4],
                    p.push(He, l, d, i, s, a, h),
                    c += 5;
                    break;
                case Ne:
                    t[c + 1] += a,
                    t[c + 2] += h,
                    t[c + 3] += a,
                    t[c + 4] += h,
                    t[c + 5] += a,
                    t[c + 6] += h,
                    n = He;
                case He:
                    i = t[c + 3],
                    s = t[c + 4],
                    a = t[c + 5],
                    h = t[c + 6],
                    p.push(He, t[c + 1], t[c + 2], i, s, a, h),
                    c += 7;
                    break;
                case Ze:
                    t[c + 1] += a,
                    t[c + 2] += h,
                    n = Ge;
                case Ge:
                    r = o === Ve || o === Ge,
                    i = r ? 2 * a - i : t[c + 1],
                    s = r ? 2 * h - s : t[c + 2],
                    e ? ui(p, a, h, i, s, t[c + 1], t[c + 2]) : p.push(Ve, i, s, t[c + 1], t[c + 2]),
                    a = t[c + 1],
                    h = t[c + 2],
                    c += 3;
                    break;
                case je:
                    t[c + 1] += a,
                    t[c + 2] += h,
                    t[c + 3] += a,
                    t[c + 4] += h,
                    n = Ve;
                case Ve:
                    i = t[c + 1],
                    s = t[c + 2],
                    e ? ui(p, a, h, i, s, t[c + 3], t[c + 4]) : p.push(Ve, i, s, t[c + 3], t[c + 4]),
                    a = t[c + 3],
                    h = t[c + 4],
                    c += 5;
                    break;
                case qe:
                    t[c + 6] += a,
                    t[c + 7] += h;
                case Ke:
                    pi(p, a, h, t[c + 1], t[c + 2], t[c + 3], t[c + 4], t[c + 5], t[c + 6], t[c + 7], e),
                    a = t[c + 6],
                    h = t[c + 7],
                    c += 8;
                    break;
                case $e:
                case Je:
                    p.push(Je),
                    c++;
                    break;
                case Qe:
                    a = t[c + 1],
                    h = t[c + 2],
                    e ? ai(p, a, h, t[c + 3], t[c + 4]) : vi(p, t, c, 5),
                    c += 5;
                    break;
                case ti:
                    a = t[c + 1],
                    h = t[c + 2],
                    e ? hi(p, a, h, t[c + 3], t[c + 4], [t[c + 5], t[c + 6], t[c + 7], t[c + 8]]) : vi(p, t, c, 9),
                    c += 9;
                    break;
                case ei:
                    a = t[c + 1],
                    h = t[c + 2],
                    e ? hi(p, a, h, t[c + 3], t[c + 4], t[c + 5]) : vi(p, t, c, 6),
                    c += 6;
                    break;
                case ii:
                    ci(e ? p : vi(p, t, c, 9), t[c + 1], t[c + 2], t[c + 3], t[c + 4], t[c + 5], t[c + 6], t[c + 7], t[c + 8], null, gi),
                    a = gi.x,
                    h = gi.y,
                    c += 9;
                    break;
                case si:
                    e ? ci(p, t[c + 1], t[c + 2], t[c + 3], t[c + 4], 0, 0, 360, !1) : vi(p, t, c, 5),
                    a = t[c + 1] + t[c + 3],
                    h = t[c + 2],
                    c += 5;
                    break;
                case ni:
                    di(e ? p : vi(p, t, c, 7), t[c + 1], t[c + 2], t[c + 3], t[c + 4], t[c + 5], t[c + 6], null, gi),
                    a = gi.x,
                    h = gi.y,
                    c += 7;
                    break;
                case oi:
                    e ? di(p, t[c + 1], t[c + 2], t[c + 3], 0, 360, !1) : vi(p, t, c, 4),
                    a = t[c + 1] + t[c + 3],
                    h = t[c + 2],
                    c += 4;
                    break;
                case ri:
                    li(e ? p : vi(p, t, c, 6), a, h, t[c + 1], t[c + 2], t[c + 3], t[c + 4], t[c + 5], null, gi),
                    a = gi.x,
                    h = gi.y,
                    c += 6;
                    break;
                default:
                    return _i.error(`command: ${n} [index:${c}]`, t),
                    p
                }
                o = n
            }
            return p
        },
        objectToCanvasData(t) {
            const e = [];
            return t.forEach((t => {
                switch (t.name) {
                case "M":
                    e.push(De, t.x, t.y);
                    break;
                case "L":
                    e.push(Ie, t.x, t.y);
                    break;
                case "C":
                    e.push(He, t.x1, t.y1, t.x2, t.y2, t.x, t.y);
                    break;
                case "Q":
                    e.push(Ve, t.x1, t.y1, t.x, t.y);
                    break;
                case "Z":
                    e.push(Je)
                }
            }
            )),
            e
        },
        copyData(t, e, i, s) {
            for (let n = i, o = i + s; n < o; n++)
                t.push(e[n])
        },
        pushData(t, e) {
            yi.index === yi.length && (yi.index = 1,
            t.push(yi.name)),
            t.push(Number(e)),
            yi.index++,
            yi.dot = 0
        }
    }
      , {current: yi, pushData: mi, copyData: vi} = fi
      , {M: wi, L: xi, C: bi, Q: Ei, Z: ki, N: Ti, D: Bi, X: Li, G: Pi, F: Ci, O: Ri, P: Si, U: Oi} = Jt
      , {getMinDistanceFrom: Di, getRadianFrom: Mi} = D
      , {tan: Ii, min: Ai, abs: Wi} = Math
      , zi = {}
      , Fi = {
        beginPath(t) {
            t.length = 0
        },
        moveTo(t, e, i) {
            t.push(wi, e, i)
        },
        lineTo(t, e, i) {
            t.push(xi, e, i)
        },
        bezierCurveTo(t, e, i, s, n, o, r) {
            t.push(bi, e, i, s, n, o, r)
        },
        quadraticCurveTo(t, e, i, s, n) {
            t.push(Ei, e, i, s, n)
        },
        closePath(t) {
            t.push(ki)
        },
        rect(t, e, i, s, n) {
            t.push(Ti, e, i, s, n)
        },
        roundRect(t, e, i, s, n, o) {
            if ("number" == typeof o)
                t.push(Li, e, i, s, n, o);
            else {
                const r = h.fourNumber(o);
                r ? t.push(Bi, e, i, s, n, ...r) : t.push(Ti, e, i, s, n)
            }
        },
        ellipse(t, e, i, s, n, o, r, a, h) {
            void 0 === o ? t.push(Ci, e, i, s, n) : (void 0 === r && (r = 0),
            void 0 === a && (a = 360),
            t.push(Pi, e, i, s, n, o, r, a, h ? 1 : 0))
        },
        arc(t, e, i, s, n, o, r) {
            void 0 === n ? t.push(Si, e, i, s) : (void 0 === o && (o = 360),
            t.push(Ri, e, i, s, n, o, r ? 1 : 0))
        },
        arcTo(t, e, i, s, n, o, r, a) {
            if (void 0 !== r) {
                const h = Ii(Mi(r, a, e, i, s, n) / 2) * (Di(r, a, e, i, s, n) / 2);
                t.push(Oi, e, i, s, n, Ai(o, Wi(h)))
            } else
                t.push(Oi, e, i, s, n, o)
        },
        drawEllipse(t, e, i, s, n, o, r, a, h) {
            Ee.ellipse(null, e, i, s, n, void 0 === o ? 0 : o, void 0 === r ? 0 : r, void 0 === a ? 360 : a, h, null, null, zi),
            t.push(wi, zi.x, zi.y),
            Ui(t, e, i, s, n, o, r, a, h)
        },
        drawArc(t, e, i, s, n, o, r) {
            Ee.arc(null, e, i, s, void 0 === n ? 0 : n, void 0 === o ? 360 : o, r, null, null, zi),
            t.push(wi, zi.x, zi.y),
            Hi(t, e, i, s, n, o, r)
        },
        drawPoints(t, e, i, s) {
            Ee.points(t, e, i, s)
        }
    }
      , {ellipse: Ui, arc: Hi} = Fi
      , {moveTo: Ni, lineTo: Yi, quadraticCurveTo: Xi, bezierCurveTo: Vi, closePath: ji, beginPath: Gi, rect: Zi, roundRect: Ki, ellipse: qi, arc: Ji, arcTo: $i, drawEllipse: Qi, drawArc: ts, drawPoints: es} = Fi;
    class is {
        set path(t) {
            this.__path = t
        }
        get path() {
            return this.__path
        }
        constructor(t) {
            this.set(t)
        }
        set(t) {
            return this.__path = t ? "string" == typeof t ? Kt.parse(t) : t : [],
            this
        }
        beginPath() {
            return Gi(this.__path),
            this.paint(),
            this
        }
        moveTo(t, e) {
            return Ni(this.__path, t, e),
            this.paint(),
            this
        }
        lineTo(t, e) {
            return Yi(this.__path, t, e),
            this.paint(),
            this
        }
        bezierCurveTo(t, e, i, s, n, o) {
            return Vi(this.__path, t, e, i, s, n, o),
            this.paint(),
            this
        }
        quadraticCurveTo(t, e, i, s) {
            return Xi(this.__path, t, e, i, s),
            this.paint(),
            this
        }
        closePath() {
            return ji(this.__path),
            this.paint(),
            this
        }
        rect(t, e, i, s) {
            return Zi(this.__path, t, e, i, s),
            this.paint(),
            this
        }
        roundRect(t, e, i, s, n) {
            return Ki(this.__path, t, e, i, s, n),
            this.paint(),
            this
        }
        ellipse(t, e, i, s, n, o, r, a) {
            return qi(this.__path, t, e, i, s, n, o, r, a),
            this.paint(),
            this
        }
        arc(t, e, i, s, n, o) {
            return Ji(this.__path, t, e, i, s, n, o),
            this.paint(),
            this
        }
        arcTo(t, e, i, s, n) {
            return $i(this.__path, t, e, i, s, n),
            this.paint(),
            this
        }
        drawEllipse(t, e, i, s, n, o, r, a) {
            return Qi(this.__path, t, e, i, s, n, o, r, a),
            this.paint(),
            this
        }
        drawArc(t, e, i, s, n, o) {
            return ts(this.__path, t, e, i, s, n, o),
            this.paint(),
            this
        }
        drawPoints(t, e, i) {
            return es(this.__path, t, e, i),
            this.paint(),
            this
        }
        clearPath() {
            return this.beginPath()
        }
        paint() {}
    }
    const {M: ss, L: ns, C: os, Q: rs, Z: as, N: hs, D: ls, X: ds, G: cs, F: us, O: ps, P: _s, U: gs} = Jt
      , fs = wt.get("PathDrawer")
      , ys = {
        drawPathByData(t, e) {
            if (!e)
                return;
            let i, s = 0, n = e.length;
            for (; s < n; )
                switch (i = e[s],
                i) {
                case ss:
                    t.moveTo(e[s + 1], e[s + 2]),
                    s += 3;
                    break;
                case ns:
                    t.lineTo(e[s + 1], e[s + 2]),
                    s += 3;
                    break;
                case os:
                    t.bezierCurveTo(e[s + 1], e[s + 2], e[s + 3], e[s + 4], e[s + 5], e[s + 6]),
                    s += 7;
                    break;
                case rs:
                    t.quadraticCurveTo(e[s + 1], e[s + 2], e[s + 3], e[s + 4]),
                    s += 5;
                    break;
                case as:
                    t.closePath(),
                    s += 1;
                    break;
                case hs:
                    t.rect(e[s + 1], e[s + 2], e[s + 3], e[s + 4]),
                    s += 5;
                    break;
                case ls:
                    t.roundRect(e[s + 1], e[s + 2], e[s + 3], e[s + 4], [e[s + 5], e[s + 6], e[s + 7], e[s + 8]]),
                    s += 9;
                    break;
                case ds:
                    t.roundRect(e[s + 1], e[s + 2], e[s + 3], e[s + 4], e[s + 5]),
                    s += 6;
                    break;
                case cs:
                    t.ellipse(e[s + 1], e[s + 2], e[s + 3], e[s + 4], e[s + 5] * l, e[s + 6] * l, e[s + 7] * l, e[s + 8]),
                    s += 9;
                    break;
                case us:
                    t.ellipse(e[s + 1], e[s + 2], e[s + 3], e[s + 4], 0, 0, d, !1),
                    s += 5;
                    break;
                case ps:
                    t.arc(e[s + 1], e[s + 2], e[s + 3], e[s + 4] * l, e[s + 5] * l, e[s + 6]),
                    s += 7;
                    break;
                case _s:
                    t.arc(e[s + 1], e[s + 2], e[s + 3], 0, d, !1),
                    s += 4;
                    break;
                case gs:
                    t.arcTo(e[s + 1], e[s + 2], e[s + 3], e[s + 4], e[s + 5]),
                    s += 6;
                    break;
                default:
                    return void fs.error(`command: ${i} [index:${s}]`, e)
                }
        }
    }
      , {M: ms, L: vs, C: ws, Q: xs, Z: bs, N: Es, D: ks, X: Ts, G: Bs, F: Ls, O: Ps, P: Cs, U: Rs} = Jt
      , {toTwoPointBounds: Ss, toTwoPointBoundsByQuadraticCurve: Os, arcTo: Ds, arc: Ms, ellipse: Is} = Ee
      , {addPointBounds: As, copy: Ws, addPoint: zs, setPoint: Fs, addBounds: Us, toBounds: Hs} = N
      , Ns = wt.get("PathBounds");
    let Ys, Xs, Vs;
    const js = {}
      , Gs = {}
      , Zs = {}
      , Ks = {
        toBounds(t, e) {
            Ks.toTwoPointBounds(t, Gs),
            Hs(Gs, e)
        },
        toTwoPointBounds(t, e) {
            if (!t || !t.length)
                return Fs(e, 0, 0);
            let i, s, n, o, r, a = 0, h = 0, l = 0;
            const d = t.length;
            for (; a < d; )
                switch (r = t[a],
                0 === a && (r === bs || r === ws || r === xs ? Fs(e, h, l) : Fs(e, t[a + 1], t[a + 2])),
                r) {
                case ms:
                case vs:
                    h = t[a + 1],
                    l = t[a + 2],
                    zs(e, h, l),
                    a += 3;
                    break;
                case ws:
                    n = t[a + 5],
                    o = t[a + 6],
                    Ss(h, l, t[a + 1], t[a + 2], t[a + 3], t[a + 4], n, o, js),
                    As(e, js),
                    h = n,
                    l = o,
                    a += 7;
                    break;
                case xs:
                    i = t[a + 1],
                    s = t[a + 2],
                    n = t[a + 3],
                    o = t[a + 4],
                    Os(h, l, i, s, n, o, js),
                    As(e, js),
                    h = n,
                    l = o,
                    a += 5;
                    break;
                case bs:
                    a += 1;
                    break;
                case Es:
                    h = t[a + 1],
                    l = t[a + 2],
                    Us(e, h, l, t[a + 3], t[a + 4]),
                    a += 5;
                    break;
                case ks:
                case Ts:
                    h = t[a + 1],
                    l = t[a + 2],
                    Us(e, h, l, t[a + 3], t[a + 4]),
                    a += r === ks ? 9 : 6;
                    break;
                case Bs:
                    Is(null, t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5], t[a + 6], t[a + 7], t[a + 8], js, Zs),
                    0 === a ? Ws(e, js) : As(e, js),
                    h = Zs.x,
                    l = Zs.y,
                    a += 9;
                    break;
                case Ls:
                    h = t[a + 1],
                    l = t[a + 2],
                    Xs = t[a + 3],
                    Vs = t[a + 4],
                    Us(e, h - Xs, l - Vs, 2 * Xs, 2 * Vs),
                    h += Xs,
                    a += 5;
                    break;
                case Ps:
                    Ms(null, t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5], t[a + 6], js, Zs),
                    0 === a ? Ws(e, js) : As(e, js),
                    h = Zs.x,
                    l = Zs.y,
                    a += 7;
                    break;
                case Cs:
                    h = t[a + 1],
                    l = t[a + 2],
                    Ys = t[a + 3],
                    Us(e, h - Ys, l - Ys, 2 * Ys, 2 * Ys),
                    h += Ys,
                    a += 4;
                    break;
                case Rs:
                    Ds(null, h, l, t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5], js, Zs),
                    0 === a ? Ws(e, js) : As(e, js),
                    h = Zs.x,
                    l = Zs.y,
                    a += 6;
                    break;
                default:
                    return void Ns.error(`command: ${r} [index:${a}]`, t)
                }
        }
    }
      , {M: qs, L: Js, C: $s, Z: Qs} = Jt
      , {getCenterX: tn, getCenterY: en} = D
      , {arcTo: sn} = Fi
      , nn = {
        smooth(t, e, i) {
            let s, n = 0, o = 0, r = 0, a = 0, h = 0, l = 0, d = 0, c = 0, u = 0;
            const p = t.length
              , _ = [];
            for (; n < p; )
                switch (s = t[n],
                s) {
                case qs:
                    a = c = t[n + 1],
                    h = u = t[n + 2],
                    n += 3,
                    t[n] === Js ? (l = t[n + 1],
                    d = t[n + 2],
                    _.push(qs, tn(a, l), en(h, d))) : _.push(qs, a, h);
                    break;
                case Js:
                    switch (o = t[n + 1],
                    r = t[n + 2],
                    n += 3,
                    t[n]) {
                    case Js:
                        sn(_, o, r, t[n + 1], t[n + 2], e, c, u);
                        break;
                    case Qs:
                        sn(_, o, r, a, h, e, c, u);
                        break;
                    default:
                        _.push(Js, o, r)
                    }
                    c = o,
                    u = r;
                    break;
                case $s:
                    _.push($s, t[n + 1], t[n + 2], t[n + 3], t[n + 4], t[n + 5], t[n + 6]),
                    n += 7;
                    break;
                case Qs:
                    sn(_, a, h, l, d, e, c, u),
                    _.push(Qs),
                    n += 1
                }
            return s !== Qs && (_[1] = a,
            _[2] = h),
            _
        }
    };
    Kt.creator = new is,
    Kt.parse = fi.parse,
    Kt.convertToCanvasData = fi.toCanvasData;
    const on = new is
      , {drawRoundRect: rn} = ne;
    function an(t) {
        !function(t) {
            t && !t.roundRect && (t.roundRect = function(t, e, i, s, n) {
                rn(this, t, e, i, s, n)
            }
            )
        }(t)
    }
    const hn = {
        opacityTypes: ["png", "webp", "svg"],
        upperCaseTypeMap: {},
        mineType: t => !t || t.startsWith("image") ? t : ("jpg" === t && (t = "jpeg"),
        "image/" + t),
        fileType(t) {
            const e = t.split(".");
            return e[e.length - 1]
        },
        isOpaqueImage(t) {
            const e = ln.fileType(t);
            return ["jpg", "jpeg"].some((t => t === e))
        },
        getExportOptions(t) {
            switch (typeof t) {
            case "object":
                return t;
            case "number":
                return {
                    quality: t
                };
            case "boolean":
                return {
                    blob: t
                };
            default:
                return {}
            }
        }
    }
      , ln = hn;
    ln.opacityTypes.forEach((t => ln.upperCaseTypeMap[t] = t.toUpperCase()));
    const dn = wt.get("TaskProcessor");
    class cn {
        constructor(t) {
            this.parallel = !0,
            this.time = 1,
            this.id = s.create(s.TASK),
            this.task = t
        }
        run() {
            return Ft(this, void 0, void 0, (function*() {
                try {
                    this.task && !this.isComplete && this.parent.running && (yield this.task())
                } catch (t) {
                    dn.error(t)
                }
            }
            ))
        }
        complete() {
            this.isComplete = !0,
            this.parent = null,
            this.task = null
        }
        cancel() {
            this.isCancel = !0,
            this.complete()
        }
    }
    class un {
        get total() {
            return this.list.length + this.delayNumber
        }
        get finishedIndex() {
            return this.isComplete ? 0 : this.index + this.parallelSuccessNumber
        }
        get remain() {
            return this.isComplete ? this.total : this.total - this.finishedIndex
        }
        get percent() {
            const {total: t} = this;
            let e = 0
              , i = 0;
            for (let s = 0; s < t; s++)
                s <= this.finishedIndex ? (i += this.list[s].time,
                s === this.finishedIndex && (e = i)) : e += this.list[s].time;
            return this.isComplete ? 1 : i / e
        }
        constructor(t) {
            this.config = {
                parallel: 6
            },
            this.list = [],
            this.running = !1,
            this.isComplete = !0,
            this.index = 0,
            this.delayNumber = 0,
            t && Mt.assign(this.config, t),
            this.empty()
        }
        add(t, e) {
            let i, s, n, o;
            const r = new cn(t);
            return r.parent = this,
            "number" == typeof e ? o = e : e && (s = e.parallel,
            i = e.start,
            n = e.time,
            o = e.delay),
            n && (r.time = n),
            !1 === s && (r.parallel = !1),
            void 0 === o ? this.push(r, i) : (this.delayNumber++,
            setTimeout(( () => {
                this.delayNumber && (this.delayNumber--,
                this.push(r, i))
            }
            ), o)),
            this.isComplete = !1,
            r
        }
        push(t, e) {
            this.list.push(t),
            !1 === e || this.timer || (this.timer = setTimeout(( () => this.start())))
        }
        empty() {
            this.index = 0,
            this.parallelSuccessNumber = 0,
            this.list = [],
            this.parallelList = [],
            this.delayNumber = 0
        }
        start() {
            this.running || (this.running = !0,
            this.isComplete = !1,
            this.run())
        }
        pause() {
            clearTimeout(this.timer),
            this.timer = null,
            this.running = !1
        }
        resume() {
            this.start()
        }
        skip() {
            this.index++,
            this.resume()
        }
        stop() {
            this.isComplete = !0,
            this.list.forEach((t => {
                t.isComplete || t.cancel()
            }
            )),
            this.pause(),
            this.empty()
        }
        run() {
            this.running && (this.setParallelList(),
            this.parallelList.length > 1 ? this.runParallelTasks() : this.remain ? this.runTask() : this.onComplete())
        }
        runTask() {
            const t = this.list[this.index];
            t ? t.run().then(( () => {
                this.onTask(t),
                this.index++,
                this.nextTask()
            }
            )).catch((t => {
                this.onError(t)
            }
            )) : this.nextTask()
        }
        runParallelTasks() {
            this.parallelList.forEach((t => this.runParallelTask(t)))
        }
        runParallelTask(t) {
            t.run().then(( () => {
                this.onTask(t),
                this.fillParallelTask()
            }
            )).catch((t => {
                this.onParallelError(t)
            }
            ))
        }
        nextTask() {
            this.total === this.finishedIndex ? this.onComplete() : this.timer = setTimeout(( () => this.run()))
        }
        setParallelList() {
            let t;
            this.parallelList = [],
            this.parallelSuccessNumber = 0;
            let e = this.index + this.config.parallel;
            e > this.list.length && (e = this.list.length);
            for (let i = this.index; i < e && (t = this.list[i],
            t.parallel); i++)
                this.parallelList.push(t)
        }
        fillParallelTask() {
            let t;
            const e = this.parallelList;
            this.parallelSuccessNumber++,
            e.pop();
            const i = e.length
              , s = this.finishedIndex + i;
            if (e.length) {
                if (!this.running)
                    return;
                s < this.total && (t = this.list[s],
                t && t.parallel && (e.push(t),
                this.runParallelTask(t)))
            } else
                this.index += this.parallelSuccessNumber,
                this.parallelSuccessNumber = 0,
                this.nextTask()
        }
        onComplete() {
            this.stop(),
            this.config.onComplete && this.config.onComplete()
        }
        onTask(t) {
            t.complete(),
            this.config.onTask && this.config.onTask()
        }
        onParallelError(t) {
            this.parallelList.forEach((t => {
                t.parallel = !1
            }
            )),
            this.parallelList.length = 0,
            this.parallelSuccessNumber = 0,
            this.onError(t)
        }
        onError(t) {
            this.pause(),
            this.config.onError && this.config.onError(t)
        }
        destroy() {
            this.stop()
        }
    }
    const pn = {
        map: {},
        recycledList: [],
        tasker: new un,
        patternTasker: new un,
        get isComplete() {
            return _n.tasker.isComplete
        },
        get(t) {
            let e = _n.map[t.url];
            return e || (e = i.image(t),
            _n.map[t.url] = e),
            e.use++,
            e
        },
        recycle(t) {
            t.use--,
            setTimeout(( () => {
                t.use || _n.recycledList.push(t)
            }
            ))
        },
        clearRecycled() {
            const t = _n.recycledList;
            t.length > 100 && (t.forEach((t => {
                !t.use && t.url && (delete _n.map[t.url],
                t.destroy())
            }
            )),
            t.length = 0)
        },
        hasOpacityPixel: t => hn.opacityTypes.some((e => _n.isFormat(e, t))),
        isFormat(t, e) {
            if (e.format === t)
                return !0;
            const {url: i} = e;
            if (i.startsWith("data:")) {
                if (i.startsWith("data:" + hn.mineType(t)))
                    return !0
            } else {
                if (i.includes("." + t) || i.includes("." + hn.upperCaseTypeMap[t]))
                    return !0;
                if ("png" === t && !i.includes("."))
                    return !0
            }
            return !1
        },
        destroy() {
            _n.map = {},
            _n.recycledList = []
        }
    }
      , _n = pn
      , {IMAGE: gn, create: fn} = s;
    class yn {
        get url() {
            return this.config.url
        }
        get completed() {
            return this.ready || !!this.error
        }
        constructor(t) {
            this.use = 0,
            this.waitComplete = [],
            this.innerId = fn(gn),
            this.config = t || {
                url: ""
            },
            this.isSVG = pn.isFormat("svg", t),
            this.hasOpacityPixel = pn.hasOpacityPixel(t)
        }
        load(t, i) {
            return this.loading || (this.loading = !0,
            pn.tasker.add(( () => Ft(this, void 0, void 0, (function*() {
                return yield e.origin.loadImage(this.url).then((t => {
                    this.ready = !0,
                    this.width = t.naturalWidth || t.width,
                    this.height = t.naturalHeight || t.height,
                    this.view = t,
                    this.onComplete(!0)
                }
                )).catch((t => {
                    this.error = t,
                    this.onComplete(!1)
                }
                ))
            }
            ))))),
            this.waitComplete.push(t, i),
            this.waitComplete.length - 2
        }
        unload(t, e) {
            const i = this.waitComplete;
            if (e) {
                const e = i[t + 1];
                e && e({
                    type: "stop"
                })
            }
            i[t] = i[t + 1] = void 0
        }
        onComplete(t) {
            let e;
            this.waitComplete.forEach(( (i, s) => {
                e = s % 2,
                i && (t ? e || i(this) : e && i(this.error))
            }
            )),
            this.waitComplete.length = 0,
            this.loading = !1
        }
        getCanvas(t, i, s, n) {
            if (t || (t = this.width),
            i || (i = this.height),
            this.cache) {
                let {params: t, data: e} = this.cache;
                for (let i in t)
                    if (t[i] !== arguments[i]) {
                        e = null;
                        break
                    }
                if (e)
                    return e
            }
            const o = e.origin.createCanvas(t, i)
              , r = o.getContext("2d");
            return s && (r.globalAlpha = s),
            r.drawImage(this.view, 0, 0, t, i),
            this.cache = this.use > 1 ? {
                data: o,
                params: arguments
            } : null,
            o
        }
        getPattern(t, i, s, n) {
            const o = e.canvas.createPattern(t, i);
            try {
                s && o.setTransform && (o.setTransform(s),
                s = null)
            } catch (t) {}
            return n && (n.transform = s),
            o
        }
        destroy() {
            this.config = {
                url: ""
            },
            this.cache = null,
            this.waitComplete.length = 0
        }
    }
    function mn(t, e, i, s) {
        s || (i.configurable = i.enumerable = !0),
        Object.defineProperty(t, e, i)
    }
    function vn(t, e) {
        return Object.getOwnPropertyDescriptor(t, e)
    }
    function wn(t, e) {
        return (i, s) => bn(i, s, t, e && e(s))
    }
    function xn(t) {
        return t
    }
    function bn(t, e, i, s) {
        const n = {
            get() {
                return this.__getAttr(e)
            },
            set(t) {
                this.__setAttr(e, t)
            }
        };
        mn(t, e, Object.assign(n, s || {})),
        Zn(t, e, i)
    }
    function En(t) {
        return wn(t)
    }
    function kn(t, e) {
        return wn(t, (t => ({
            set(i) {
                this.__setAttr(t, i, e) && (this.__layout.matrixChanged || this.__layout.matrixChange())
            }
        })))
    }
    function Tn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.matrixChanged || this.__layout.matrixChange(),
                this.__hasAutoLayout = !!(this.origin || this.around || this.flow),
                this.__local || this.__layout.createLocal())
            }
        })))
    }
    function Bn(t, e) {
        return wn(t, (t => ({
            set(i) {
                this.__setAttr(t, i, e) && (this.__layout.scaleChanged || this.__layout.scaleChange())
            }
        })))
    }
    function Ln(t, e) {
        return wn(t, (t => ({
            set(i) {
                this.__setAttr(t, i, e) && (this.__layout.rotationChanged || this.__layout.rotationChange())
            }
        })))
    }
    function Pn(t, e) {
        return wn(t, (t => ({
            set(i) {
                this.__setAttr(t, i, e) && Rn(this)
            }
        })))
    }
    function Cn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (Rn(this),
                this.__.__removeNaturalSize())
            }
        })))
    }
    function Rn(t) {
        t.__layout.boxChanged || t.__layout.boxChange(),
        t.__hasAutoLayout && (t.__layout.matrixChanged || t.__layout.matrixChange())
    }
    function Sn(t) {
        return wn(t, (t => ({
            set(e) {
                const i = this.__;
                2 !== i.__pathInputed && (i.__pathInputed = e ? 1 : 0),
                e || (i.__pathForRender = void 0),
                this.__setAttr(t, e),
                Rn(this)
            }
        })))
    }
    const On = Pn;
    function Dn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && Mn(this)
            }
        })))
    }
    function Mn(t) {
        t.__layout.strokeChanged || t.__layout.strokeChange(),
        t.__.__useArrow && Rn(t)
    }
    const In = Dn;
    function An(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e),
                this.__layout.renderChanged || this.__layout.renderChange()
            }
        })))
    }
    function Wn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.surfaceChanged || this.__layout.surfaceChange())
            }
        })))
    }
    function zn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.opacityChanged || this.__layout.opacityChange()),
                this.mask && Un(this)
            }
        })))
    }
    function Fn(t) {
        return wn(t, (t => ({
            set(e) {
                const i = this.visible;
                if (!0 === i && 0 === e) {
                    if (this.animationOut)
                        return this.__runAnimation("out", ( () => Hn(this, t, e, i)))
                } else
                    0 === i && !0 === e && this.animation && this.__runAnimation("in");
                Hn(this, t, e, i),
                this.mask && Un(this)
            }
        })))
    }
    function Un(t) {
        const {parent: e} = t;
        if (e) {
            const {__hasMask: t} = e;
            e.__updateMask(),
            t !== e.__hasMask && e.forceUpdate()
        }
    }
    function Hn(t, e, i, s) {
        t.__setAttr(e, i) && (t.__layout.opacityChanged || t.__layout.opacityChange(),
        0 !== s && 0 !== i || Rn(t))
    }
    function Nn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.surfaceChanged || this.__layout.surfaceChange(),
                this.waitParent(( () => {
                    this.parent.__layout.childrenSortChange()
                }
                )))
            }
        })))
    }
    function Yn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.boxChanged || this.__layout.boxChange(),
                this.waitParent(( () => {
                    this.parent.__updateMask(e)
                }
                )))
            }
        })))
    }
    function Xn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && this.waitParent(( () => {
                    this.parent.__updateEraser(e)
                }
                ))
            }
        })))
    }
    function Vn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e) && (this.__layout.hitCanvasChanged = !0,
                wt.showHitView && (this.__layout.surfaceChanged || this.__layout.surfaceChange()),
                this.leafer && this.leafer.updateCursor())
            }
        })))
    }
    function jn(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e),
                this.leafer && this.leafer.updateCursor()
            }
        })))
    }
    function Gn(t) {
        return (e, i) => {
            mn(e, "__DataProcessor", {
                get: () => t
            })
        }
    }
    function Zn(t, e, i) {
        const s = t.__DataProcessor.prototype
          , n = "_" + e
          , o = function(t) {
            return "set" + t.charAt(0).toUpperCase() + t.slice(1)
        }(e)
          , r = {
            get() {
                const t = this[n];
                return void 0 === t ? i : t
            },
            set(t) {
                this[n] = t
            }
        };
        if (void 0 === i)
            r.get = function() {
                return this[n]
            }
            ;
        else if ("object" == typeof i) {
            const {clone: t} = Mt;
            r.get = function() {
                let e = this[n];
                return void 0 === e && (this[n] = e = t(i)),
                e
            }
        }
        "width" === e ? r.get = function() {
            const t = this[n];
            if (void 0 === t) {
                const t = this;
                return t._height && t.__naturalWidth && t.__useNaturalRatio ? t._height * t.__naturalWidth / t.__naturalHeight : t.__naturalWidth || i
            }
            return t
        }
        : "height" === e && (r.get = function() {
            const t = this[n];
            if (void 0 === t) {
                const t = this;
                return t._width && t.__naturalHeight && t.__useNaturalRatio ? t._width * t.__naturalHeight / t.__naturalWidth : t.__naturalHeight || i
            }
            return t
        }
        );
        let a, h = s;
        for (; !a && h; )
            a = vn(h, e),
            h = h.__proto__;
        a && a.set && (r.set = a.set),
        s[o] && (r.set = s[o],
        delete s[o]),
        mn(s, e, r)
    }
    const Kn = new wt("rewrite")
      , qn = []
      , Jn = ["destroy", "constructor"];
    function $n(t) {
        return (e, i) => {
            qn.push({
                name: e.constructor.name + "." + i,
                run: () => {
                    e[i] = t
                }
            })
        }
    }
    function Qn() {
        return t => {
            to()
        }
    }
    function to(t) {
        qn.length && (qn.forEach((e => {
            t && Kn.error(e.name, "需在Class上装饰@rewriteAble()"),
            e.run()
        }
        )),
        qn.length = 0)
    }
    function eo(t, e) {
        return i => {
            var s;
            (t.prototype ? (s = t.prototype,
            Object.getOwnPropertyNames(s)) : Object.keys(t)).forEach((s => {
                if (!(Jn.includes(s) || e && e.includes(s)))
                    if (t.prototype) {
                        vn(t.prototype, s).writable && (i.prototype[s] = t.prototype[s])
                    } else
                        i.prototype[s] = t[s]
            }
            ))
        }
    }
    function io() {
        return t => {
            Pt.register(t)
        }
    }
    function so() {
        return t => {
            St.register(t)
        }
    }
    setTimeout(( () => to(!0)));
    const {copy: no, toInnerPoint: oo, toOuterPoint: ro, scaleOfOuter: ao, rotateOfOuter: ho, skewOfOuter: lo, multiplyParent: co, divideParent: uo, getLayout: po} = b
      , _o = {}
      , go = {
        updateAllMatrix(t, e, i) {
            if (e && t.__hasAutoLayout && t.__layout.matrixChanged && (i = !0),
            mo(t, e, i),
            t.isBranch) {
                const {children: s} = t;
                for (let t = 0, n = s.length; t < n; t++)
                    yo(s[t], e, i)
            }
        },
        updateMatrix(t, e, i) {
            const s = t.__layout;
            e ? i && (s.waitAutoLayout = !0,
            t.__hasAutoLayout && (s.matrixChanged = !1)) : s.waitAutoLayout && (s.waitAutoLayout = !1),
            s.matrixChanged && t.__updateLocalMatrix(),
            s.waitAutoLayout || t.__updateWorldMatrix()
        },
        updateBounds(t) {
            const e = t.__layout;
            e.boundsChanged && t.__updateLocalBounds(),
            e.waitAutoLayout || t.__updateWorldBounds()
        },
        updateAllWorldOpacity(t) {
            if (t.__updateWorldOpacity(),
            t.isBranch) {
                const {children: e} = t;
                for (let t = 0, i = e.length; t < i; t++)
                    vo(e[t])
            }
        },
        updateAllChange(t) {
            if (vo(t),
            t.__updateChange(),
            t.isBranch) {
                const {children: e} = t;
                for (let t = 0, i = e.length; t < i; t++)
                    wo(e[t])
            }
        },
        worldHittable(t) {
            for (; t; ) {
                if (!t.__.hittable)
                    return !1;
                t = t.parent
            }
            return !0
        },
        moveWorld(t, e, i=0, s, n) {
            const o = "object" == typeof e ? Object.assign({}, e) : {
                x: e,
                y: i
            };
            s ? ro(t.localTransform, o, o, !0) : t.parent && oo(t.parent.worldTransform, o, o, !0),
            fo.moveLocal(t, o.x, o.y, n)
        },
        moveLocal(t, e, i=0, s) {
            "object" == typeof e && (i = e.y,
            e = e.x),
            e += t.x,
            i += t.y,
            s ? t.animate({
                x: e,
                y: i
            }, s) : (t.x = e,
            t.y = i)
        },
        zoomOfWorld(t, e, i, s, n) {
            fo.zoomOfLocal(t, bo(t, e), i, s, n)
        },
        zoomOfLocal(t, e, i, s=i, n) {
            no(_o, t.__localMatrix),
            ao(_o, e, i, s),
            t.origin || t.around ? fo.setTransform(t, _o, n) : (xo(t, _o),
            t.scaleResize(i, s, !0 !== n))
        },
        rotateOfWorld(t, e, i) {
            fo.rotateOfLocal(t, bo(t, e), i)
        },
        rotateOfLocal(t, e, i) {
            no(_o, t.__localMatrix),
            ho(_o, e, i),
            t.origin || t.around ? fo.setTransform(t, _o) : (xo(t, _o),
            t.rotation = h.formatRotation(t.rotation + i))
        },
        skewOfWorld(t, e, i, s, n) {
            fo.skewOfLocal(t, bo(t, e), i, s, n)
        },
        skewOfLocal(t, e, i, s=0, n) {
            no(_o, t.__localMatrix),
            lo(_o, e, i, s),
            fo.setTransform(t, _o, n)
        },
        transformWorld(t, e, i) {
            no(_o, t.worldTransform),
            co(_o, e),
            t.parent && uo(_o, t.parent.worldTransform),
            fo.setTransform(t, _o, i)
        },
        transform(t, e, i) {
            no(_o, t.localTransform),
            co(_o, e),
            fo.setTransform(t, _o, i)
        },
        setTransform(t, e, i) {
            const s = po(e, t.origin && fo.getInnerOrigin(t, t.origin), t.around && fo.getInnerOrigin(t, t.around));
            if (i) {
                const e = s.scaleX / t.scaleX
                  , n = s.scaleY / t.scaleY;
                delete s.scaleX,
                delete s.scaleY,
                t.set(s),
                t.scaleResize(e, n, !0 !== i)
            } else
                t.set(s)
        },
        getFlipTransform(t, e) {
            const i = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0
            }
              , s = "x" === e ? 1 : -1;
            return ao(i, fo.getLocalOrigin(t, "center"), -1 * s, 1 * s),
            i
        },
        getLocalOrigin: (t, e) => D.tempToOuterOf(fo.getInnerOrigin(t, e), t.localTransform),
        getInnerOrigin(t, e) {
            const i = {};
            return gt.toPoint(e, t.boxBounds, i),
            i
        },
        getRelativeWorld: (t, e, i) => (no(_o, t.worldTransform),
        uo(_o, e.worldTransform),
        i ? _o : Object.assign({}, _o)),
        drop(t, e, i, s) {
            t.setTransform(fo.getRelativeWorld(t, e, !0), s),
            e.add(t, i)
        },
        hasParent(t, e) {
            if (!e)
                return !1;
            for (; t; ) {
                if (e === t)
                    return !0;
                t = t.parent
            }
        }
    }
      , fo = go
      , {updateAllMatrix: yo, updateMatrix: mo, updateAllWorldOpacity: vo, updateAllChange: wo} = fo;
    function xo(t, e) {
        const {e: i, f: s} = t.__localMatrix;
        t.x += e.e - i,
        t.y += e.f - s
    }
    function bo(t, e) {
        return t.__layout.update(),
        t.parent ? D.tempToInnerOf(e, t.parent.__world) : e
    }
    const Eo = {
        worldBounds: t => t.__world,
        localBoxBounds: t => t.__.eraser || 0 === t.__.visible ? null : t.__local || t.__layout,
        localStrokeBounds: t => t.__.eraser || 0 === t.__.visible ? null : t.__layout.localStrokeBounds,
        localRenderBounds: t => t.__.eraser || 0 === t.__.visible ? null : t.__layout.localRenderBounds,
        maskLocalBoxBounds: t => t.__.mask ? t.__localBoxBounds : null,
        maskLocalStrokeBounds: t => t.__.mask ? t.__layout.localStrokeBounds : null,
        maskLocalRenderBounds: t => t.__.mask ? t.__layout.localRenderBounds : null,
        excludeRenderBounds: (t, e) => !(!e.bounds || e.bounds.hit(t.__world, e.matrix)) || !(!e.hideBounds || !e.hideBounds.includes(t.__world, e.matrix))
    }
      , {updateBounds: ko} = go
      , To = {
        sort: (t, e) => t.__.zIndex === e.__.zIndex ? t.__tempNumber - e.__tempNumber : t.__.zIndex - e.__.zIndex,
        pushAllChildBranch(t, e) {
            if (t.__tempNumber = 1,
            t.__.__childBranchNumber) {
                const {children: i} = t;
                for (let s = 0, n = i.length; s < n; s++)
                    (t = i[s]).isBranch && (t.__tempNumber = 1,
                    e.add(t),
                    Bo(t, e))
            }
        },
        pushAllParent(t, e) {
            const {keys: i} = e;
            if (i)
                for (; t.parent && void 0 === i[t.parent.innerId]; )
                    e.add(t.parent),
                    t = t.parent;
            else
                for (; t.parent; )
                    e.add(t.parent),
                    t = t.parent
        },
        pushAllBranchStack(t, e) {
            let i = e.length;
            const {children: s} = t;
            for (let t = 0, i = s.length; t < i; t++)
                s[t].isBranch && e.push(s[t]);
            for (let t = i, s = e.length; t < s; t++)
                Lo(e[t], e)
        },
        updateBounds(t, e) {
            const i = [t];
            Lo(t, i),
            Po(i, e)
        },
        updateBoundsByBranchStack(t, e) {
            let i, s;
            for (let n = t.length - 1; n > -1; n--) {
                i = t[n],
                s = i.children;
                for (let t = 0, e = s.length; t < e; t++)
                    ko(s[t]);
                e && e === i || ko(i)
            }
        }
    }
      , {pushAllChildBranch: Bo, pushAllBranchStack: Lo, updateBoundsByBranchStack: Po} = To
      , Co = {
        run(t) {
            if (t && t.length) {
                const e = t.length;
                for (let i = 0; i < e; i++)
                    t[i]();
                t.length === e ? t.length = 0 : t.splice(0, e)
            }
        }
    }
      , {getRelativeWorld: Ro} = go
      , {toOuterOf: So, getPoints: Oo, copy: Do} = ot
      , Mo = "_localContentBounds"
      , Io = "_worldContentBounds"
      , Ao = "_worldBoxBounds"
      , Wo = "_worldStrokeBounds";
    class zo {
        get contentBounds() {
            return this._contentBounds || this.boxBounds
        }
        set contentBounds(t) {
            this._contentBounds = t
        }
        get strokeBounds() {
            return this._strokeBounds || this.boxBounds
        }
        get renderBounds() {
            return this._renderBounds || this.boxBounds
        }
        get localContentBounds() {
            return So(this.contentBounds, this.leaf.__localMatrix, this[Mo] || (this[Mo] = {})),
            this[Mo]
        }
        get localStrokeBounds() {
            return this._localStrokeBounds || this
        }
        get localRenderBounds() {
            return this._localRenderBounds || this
        }
        get worldContentBounds() {
            return So(this.contentBounds, this.leaf.__world, this[Io] || (this[Io] = {})),
            this[Io]
        }
        get worldBoxBounds() {
            return So(this.boxBounds, this.leaf.__world, this[Ao] || (this[Ao] = {})),
            this[Ao]
        }
        get worldStrokeBounds() {
            return So(this.strokeBounds, this.leaf.__world, this[Wo] || (this[Wo] = {})),
            this[Wo]
        }
        get a() {
            return 1
        }
        get b() {
            return 0
        }
        get c() {
            return 0
        }
        get d() {
            return 1
        }
        get e() {
            return this.leaf.__.x
        }
        get f() {
            return this.leaf.__.y
        }
        get x() {
            return this.e + this.boxBounds.x
        }
        get y() {
            return this.f + this.boxBounds.y
        }
        get width() {
            return this.boxBounds.width
        }
        get height() {
            return this.boxBounds.height
        }
        constructor(t) {
            this.leaf = t,
            this.boxBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            this.leaf.__local && (this._localRenderBounds = this._localStrokeBounds = this.leaf.__local),
            this.boxChange(),
            this.matrixChange()
        }
        createLocal() {
            const t = this.leaf.__local = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this._localStrokeBounds || (this._localStrokeBounds = t),
            this._localRenderBounds || (this._localRenderBounds = t)
        }
        update() {
            const {leafer: t} = this.leaf;
            if (t)
                t.ready ? t.watcher.changed && t.layouter.layout() : t.start();
            else {
                let t = this.leaf;
                for (; t.parent && !t.parent.leafer; )
                    t = t.parent;
                e.layout(t)
            }
        }
        getTransform(t="world") {
            this.update();
            const {leaf: e} = this;
            switch (t) {
            case "world":
                return e.__world;
            case "local":
                return e.__localMatrix;
            case "inner":
                return b.defaultMatrix;
            case "page":
                t = e.zoomLayer;
            default:
                return Ro(e, t)
            }
        }
        getBounds(t, e="world") {
            switch (this.update(),
            e) {
            case "world":
                return this.getWorldBounds(t);
            case "local":
                return this.getLocalBounds(t);
            case "inner":
                return this.getInnerBounds(t);
            case "page":
                e = this.leaf.zoomLayer;
            default:
                return new lt(this.getInnerBounds(t)).toOuterOf(this.getTransform(e))
            }
        }
        getInnerBounds(t="box") {
            switch (t) {
            case "render":
                return this.renderBounds;
            case "content":
                if (this.contentBounds)
                    return this.contentBounds;
            case "box":
                return this.boxBounds;
            case "stroke":
                return this.strokeBounds
            }
        }
        getLocalBounds(t="box") {
            switch (t) {
            case "render":
                return this.localRenderBounds;
            case "stroke":
                return this.localStrokeBounds;
            case "content":
                if (this.contentBounds)
                    return this.localContentBounds;
            case "box":
                return this.leaf.__localBoxBounds
            }
        }
        getWorldBounds(t="box") {
            switch (t) {
            case "render":
                return this.leaf.__world;
            case "stroke":
                return this.worldStrokeBounds;
            case "content":
                if (this.contentBounds)
                    return this.worldContentBounds;
            case "box":
                return this.worldBoxBounds
            }
        }
        getLayoutBounds(t, e="world", i) {
            const {leaf: s} = this;
            let n, o, r, a = this.getInnerBounds(t);
            switch (e) {
            case "world":
                n = s.getWorldPoint(a),
                o = s.__world;
                break;
            case "local":
                const {scaleX: t, scaleY: i, rotation: h, skewX: l, skewY: d} = s.__;
                r = {
                    scaleX: t,
                    scaleY: i,
                    rotation: h,
                    skewX: l,
                    skewY: d
                },
                n = s.getLocalPointByInner(a);
                break;
            case "inner":
                n = a,
                o = b.defaultMatrix;
                break;
            case "page":
                e = s.zoomLayer;
            default:
                n = s.getWorldPoint(a, e),
                o = Ro(s, e, !0)
            }
            if (r || (r = b.getLayout(o)),
            Do(r, a),
            D.copy(r, n),
            i) {
                const {scaleX: t, scaleY: e} = r
                  , i = Math.abs(t)
                  , s = Math.abs(e);
                1 === i && 1 === s || (r.scaleX /= i,
                r.scaleY /= s,
                r.width *= i,
                r.height *= s)
            }
            return r
        }
        getLayoutPoints(t, e="world") {
            const {leaf: i} = this
              , s = Oo(this.getInnerBounds(t));
            let n;
            switch (e) {
            case "world":
                n = null;
                break;
            case "local":
                n = i.parent;
                break;
            case "inner":
                break;
            case "page":
                e = i.zoomLayer;
            default:
                n = e
            }
            return void 0 !== n && s.forEach((t => i.innerToWorld(t, null, !1, n))),
            s
        }
        shrinkContent() {
            const {x: t, y: e, width: i, height: s} = this.boxBounds;
            this._contentBounds = {
                x: t,
                y: e,
                width: i,
                height: s
            }
        }
        spreadStroke() {
            const {x: t, y: e, width: i, height: s} = this.strokeBounds;
            this._strokeBounds = {
                x: t,
                y: e,
                width: i,
                height: s
            },
            this._localStrokeBounds = {
                x: t,
                y: e,
                width: i,
                height: s
            },
            this.renderSpread || this.spreadRenderCancel()
        }
        spreadRender() {
            const {x: t, y: e, width: i, height: s} = this.renderBounds;
            this._renderBounds = {
                x: t,
                y: e,
                width: i,
                height: s
            },
            this._localRenderBounds = {
                x: t,
                y: e,
                width: i,
                height: s
            }
        }
        shrinkContentCancel() {
            this._contentBounds = void 0
        }
        spreadStrokeCancel() {
            const t = this.renderBounds === this.strokeBounds;
            this._strokeBounds = this.boxBounds,
            this._localStrokeBounds = this.leaf.__localBoxBounds,
            t && this.spreadRenderCancel()
        }
        spreadRenderCancel() {
            this._renderBounds = this._strokeBounds,
            this._localRenderBounds = this._localStrokeBounds
        }
        boxChange() {
            this.boxChanged = !0,
            this.localBoxChanged || this.localBoxChange(),
            this.hitCanvasChanged = !0
        }
        localBoxChange() {
            this.localBoxChanged = !0,
            this.boundsChanged = !0
        }
        strokeChange() {
            this.strokeChanged = !0,
            this.strokeSpread || (this.strokeSpread = 1),
            this.boundsChanged = !0,
            this.hitCanvasChanged = !0
        }
        renderChange() {
            this.renderChanged = !0,
            this.renderSpread || (this.renderSpread = 1),
            this.boundsChanged = !0
        }
        scaleChange() {
            this.scaleChanged = !0,
            this._scaleOrRotationChange()
        }
        rotationChange() {
            this.rotationChanged = !0,
            this.affectRotation = !0,
            this._scaleOrRotationChange()
        }
        _scaleOrRotationChange() {
            this.affectScaleOrRotation = !0,
            this.matrixChange(),
            this.leaf.__local || this.createLocal()
        }
        matrixChange() {
            this.matrixChanged = !0,
            this.localBoxChanged || this.localBoxChange()
        }
        surfaceChange() {
            this.surfaceChanged = !0
        }
        opacityChange() {
            this.opacityChanged = !0,
            this.surfaceChanged || this.surfaceChange()
        }
        childrenSortChange() {
            this.childrenSortChanged || (this.childrenSortChanged = !0,
            this.leaf.forceUpdate("surface"))
        }
        destroy() {}
    }
    class Fo {
        constructor(t, e) {
            this.bubbles = !1,
            this.type = t,
            e && (this.target = e)
        }
        stopDefault() {
            this.isStopDefault = !0,
            this.origin && e.event.stopDefault(this.origin)
        }
        stopNow() {
            this.isStopNow = !0,
            this.isStop = !0,
            this.origin && e.event.stopNow(this.origin)
        }
        stop() {
            this.isStop = !0,
            this.origin && e.event.stop(this.origin)
        }
    }
    class Uo extends Fo {
        constructor(t, e, i) {
            super(t, e),
            this.parent = i,
            this.child = e
        }
    }
    Uo.ADD = "child.add",
    Uo.REMOVE = "child.remove",
    Uo.CREATED = "created",
    Uo.MOUNTED = "mounted",
    Uo.UNMOUNTED = "unmounted",
    Uo.DESTROY = "destroy";
    class Ho extends Fo {
        constructor(t, e, i, s, n) {
            super(t, e),
            this.attrName = i,
            this.oldValue = s,
            this.newValue = n
        }
    }
    Ho.CHANGE = "property.change",
    Ho.LEAFER_CHANGE = "property.leafer_change";
    class No extends Fo {
        constructor(t, e) {
            super(t),
            Object.assign(this, e)
        }
    }
    No.LOAD = "image.load",
    No.LOADED = "image.loaded",
    No.ERROR = "image.error";
    class Yo extends Fo {
        get bigger() {
            if (!this.old)
                return !0;
            const {width: t, height: e} = this.old;
            return this.width >= t && this.height >= e
        }
        get smaller() {
            return !this.bigger
        }
        get samePixelRatio() {
            return !this.old || this.pixelRatio === this.old.pixelRatio
        }
        constructor(t, e) {
            "object" == typeof t ? (super(Yo.RESIZE),
            Object.assign(this, t)) : super(t),
            this.old = e
        }
    }
    Yo.RESIZE = "resize";
    class Xo extends Fo {
        constructor(t, e) {
            super(t),
            this.data = e
        }
    }
    Xo.REQUEST = "watch.request",
    Xo.DATA = "watch.data";
    class Vo extends Fo {
        constructor(t, e, i) {
            super(t),
            e && (this.data = e,
            this.times = i)
        }
    }
    Vo.CHECK_UPDATE = "layout.check_update",
    Vo.REQUEST = "layout.request",
    Vo.START = "layout.start",
    Vo.BEFORE = "layout.before",
    Vo.LAYOUT = "layout",
    Vo.AFTER = "layout.after",
    Vo.AGAIN = "layout.again",
    Vo.END = "layout.end";
    class jo extends Fo {
        constructor(t, e, i, s) {
            super(t),
            e && (this.times = e),
            i && (this.renderBounds = i,
            this.renderOptions = s)
        }
    }
    jo.REQUEST = "render.request",
    jo.CHILD_START = "render.child_start",
    jo.START = "render.start",
    jo.BEFORE = "render.before",
    jo.RENDER = "render",
    jo.AFTER = "render.after",
    jo.AGAIN = "render.again",
    jo.END = "render.end",
    jo.NEXT = "render.next";
    class Go extends Fo {
    }
    Go.START = "leafer.start",
    Go.BEFORE_READY = "leafer.before_ready",
    Go.READY = "leafer.ready",
    Go.AFTER_READY = "leafer.after_ready",
    Go.VIEW_READY = "leafer.view_ready",
    Go.VIEW_COMPLETED = "leafer.view_completed",
    Go.STOP = "leafer.stop",
    Go.RESTART = "leafer.restart",
    Go.END = "leafer.end";
    const Zo = {};
    class Ko {
        set event(t) {
            this.on(t)
        }
        on(t, e, i) {
            if (!e) {
                let e, i = t;
                for (let t in i)
                    e = i[t],
                    e instanceof Array ? this.on(t, e[0], e[1]) : this.on(t, e);
                return
            }
            let s, n, o;
            i && ("once" === i ? n = !0 : "boolean" == typeof i ? s = i : (s = i.capture,
            n = i.once));
            const r = qo(this, s, !0)
              , a = "string" == typeof t ? t.split(" ") : t
              , h = n ? {
                listener: e,
                once: n
            } : {
                listener: e
            };
            a.forEach((t => {
                t && (o = r[t],
                o ? -1 === o.findIndex((t => t.listener === e)) && o.push(h) : r[t] = [h])
            }
            ))
        }
        off(t, e, i) {
            if (t) {
                const s = "string" == typeof t ? t.split(" ") : t;
                if (e) {
                    let t, n, o;
                    i && (t = "boolean" == typeof i ? i : "once" !== i && i.capture);
                    const r = qo(this, t);
                    s.forEach((t => {
                        t && (n = r[t],
                        n && (o = n.findIndex((t => t.listener === e)),
                        o > -1 && n.splice(o, 1),
                        n.length || delete r[t]))
                    }
                    ))
                } else {
                    const {__bubbleMap: t, __captureMap: e} = this;
                    s.forEach((i => {
                        t && delete t[i],
                        e && delete e[i]
                    }
                    ))
                }
            } else
                this.__bubbleMap = this.__captureMap = void 0
        }
        on_(t, e, i, s) {
            return i && (e = e.bind(i)),
            this.on(t, e, s),
            {
                type: t,
                current: this,
                listener: e,
                options: s
            }
        }
        off_(t) {
            if (!t)
                return;
            const e = t instanceof Array ? t : [t];
            e.forEach((t => t.current.off(t.type, t.listener, t.options))),
            e.length = 0
        }
        once(t, e, i) {
            this.on(t, e, {
                once: !0,
                capture: i
            })
        }
        emit(t, e, i) {
            !e && St.has(t) && (e = St.get(t, {
                type: t,
                target: this,
                current: this
            }));
            const s = qo(this, i)[t];
            if (s) {
                let n;
                for (let o = 0, r = s.length; o < r && (n = s[o],
                n.listener(e),
                n.once && (this.off(t, n.listener, i),
                o--,
                r--),
                !e || !e.isStopNow); o++)
                    ;
            }
            this.syncEventer && this.syncEventer.emitEvent(e, i)
        }
        emitEvent(t, e) {
            t.current = this,
            this.emit(t.type, t, e)
        }
        hasEvent(t, e) {
            if (this.syncEventer && this.syncEventer.hasEvent(t, e))
                return !0;
            const {__bubbleMap: i, __captureMap: s} = this
              , n = i && i[t]
              , o = s && s[t];
            return !!(void 0 === e ? n || o : e ? o : n)
        }
        destroy() {
            this.__captureMap = this.__bubbleMap = this.syncEventer = null
        }
    }
    function qo(t, e, i) {
        if (e) {
            const {__captureMap: e} = t;
            return e || (i ? t.__captureMap = {} : Zo)
        }
        {
            const {__bubbleMap: e} = t;
            return e || (i ? t.__bubbleMap = {} : Zo)
        }
    }
    const {on: Jo, on_: $o, off: Qo, off_: tr, once: er, emit: ir, emitEvent: sr, hasEvent: nr, destroy: or} = Ko.prototype
      , rr = {
        on: Jo,
        on_: $o,
        off: Qo,
        off_: tr,
        once: er,
        emit: ir,
        emitEvent: sr,
        hasEvent: nr,
        destroyEventer: or
    }
      , {isFinite: ar} = Number
      , hr = wt.get("setAttr")
      , lr = {
        __setAttr(t, e, i) {
            if (this.leaferIsCreated) {
                const s = this.__.__getInput(t);
                if (i && !ar(e) && void 0 !== e && (hr.warn(this.innerName, t, e),
                e = void 0),
                "object" == typeof e || s !== e) {
                    this.__realSetAttr(t, e);
                    const {CHANGE: i} = Ho
                      , n = new Ho(i,this,t,s,e);
                    return this.isLeafer ? this.emitEvent(new Ho(Ho.LEAFER_CHANGE,this,t,s,e)) : this.hasEvent(i) && this.emitEvent(n),
                    this.leafer.emitEvent(n),
                    !0
                }
                return !1
            }
            return this.__realSetAttr(t, e),
            !0
        },
        __realSetAttr(t, e) {
            const i = this.__;
            i[t] = e,
            this.__proxyData && this.setProxyAttr(t, e),
            i.normalStyle && (this.lockNormalStyle || void 0 === i.normalStyle[t] || (i.normalStyle[t] = e))
        },
        __getAttr(t) {
            return this.__proxyData ? this.getProxyAttr(t) : this.__.__get(t)
        }
    }
      , {setLayout: dr, multiplyParent: cr, translateInner: ur, defaultWorld: pr} = b
      , {toPoint: _r, tempPoint: gr} = gt
      , fr = {
        __updateWorldMatrix() {
            cr(this.__local || this.__layout, this.parent ? this.parent.__world : pr, this.__world, !!this.__layout.affectScaleOrRotation, this.__, this.parent && this.parent.__)
        },
        __updateLocalMatrix() {
            if (this.__local) {
                const t = this.__layout
                  , e = this.__local
                  , i = this.__;
                t.affectScaleOrRotation && (t.scaleChanged || t.rotationChanged) && (dr(e, i, null, null, t.affectRotation),
                t.scaleChanged = t.rotationChanged = !1),
                e.e = i.x + i.offsetX,
                e.f = i.y + i.offsetY,
                (i.around || i.origin) && (_r(i.around || i.origin, t.boxBounds, gr),
                ur(e, -gr.x, -gr.y, !i.around))
            }
            this.__layout.matrixChanged = !1
        }
    }
      , {updateMatrix: yr, updateAllMatrix: mr} = go
      , {updateBounds: vr} = To
      , {toOuterOf: wr, copyAndSpread: xr, copy: br} = ot
      , {toBounds: Er} = Ks
      , kr = {
        __updateWorldBounds() {
            wr(this.__layout.renderBounds, this.__world, this.__world),
            this.__layout.resized && (this.__onUpdateSize(),
            this.__layout.resized = !1)
        },
        __updateLocalBounds() {
            const t = this.__layout;
            t.boxChanged && (this.__.__pathInputed || this.__updatePath(),
            this.__updateRenderPath(),
            this.__updateBoxBounds(),
            t.resized = !0),
            t.localBoxChanged && (this.__local && this.__updateLocalBoxBounds(),
            t.localBoxChanged = !1,
            t.strokeSpread && (t.strokeChanged = !0),
            t.renderSpread && (t.renderChanged = !0),
            this.parent && this.parent.__layout.boxChange()),
            t.boxChanged = !1,
            t.strokeChanged && (t.strokeSpread = this.__updateStrokeSpread(),
            t.strokeSpread ? (t.strokeBounds === t.boxBounds && t.spreadStroke(),
            this.__updateStrokeBounds(),
            this.__updateLocalStrokeBounds()) : t.spreadStrokeCancel(),
            t.strokeChanged = !1,
            (t.renderSpread || t.strokeSpread !== t.strokeBoxSpread) && (t.renderChanged = !0),
            this.parent && this.parent.__layout.strokeChange(),
            t.resized = !0),
            t.renderChanged && (t.renderSpread = this.__updateRenderSpread(),
            t.renderSpread ? (t.renderBounds !== t.boxBounds && t.renderBounds !== t.strokeBounds || t.spreadRender(),
            this.__updateRenderBounds(),
            this.__updateLocalRenderBounds()) : t.spreadRenderCancel(),
            t.renderChanged = !1,
            this.parent && this.parent.__layout.renderChange()),
            t.boundsChanged = !1
        },
        __updateLocalBoxBounds() {
            this.__hasMotionPath && this.__updateMotionPath(),
            this.__hasAutoLayout && this.__updateAutoLayout(),
            wr(this.__layout.boxBounds, this.__local, this.__local)
        },
        __updateLocalStrokeBounds() {
            wr(this.__layout.strokeBounds, this.__localMatrix, this.__layout.localStrokeBounds)
        },
        __updateLocalRenderBounds() {
            wr(this.__layout.renderBounds, this.__localMatrix, this.__layout.localRenderBounds)
        },
        __updateBoxBounds() {
            const t = this.__layout.boxBounds
              , e = this.__;
            e.__pathInputed ? Er(e.path, t) : (t.x = 0,
            t.y = 0,
            t.width = e.width,
            t.height = e.height)
        },
        __updateAutoLayout() {
            this.__layout.matrixChanged = !0,
            this.isBranch ? (this.leaferIsReady && this.leafer.layouter.addExtra(this),
            this.__.flow ? (this.__layout.boxChanged && this.__updateFlowLayout(),
            mr(this),
            vr(this, this),
            this.__.__autoSide && this.__updateBoxBounds(!0)) : (mr(this),
            vr(this, this))) : yr(this)
        },
        __updateNaturalSize() {
            const {__: t, __layout: e} = this;
            t.__naturalWidth = e.boxBounds.width,
            t.__naturalHeight = e.boxBounds.height
        },
        __updateStrokeBounds() {
            const t = this.__layout;
            xr(t.strokeBounds, t.boxBounds, t.strokeBoxSpread)
        },
        __updateRenderBounds() {
            const t = this.__layout;
            t.renderSpread > 0 ? xr(t.renderBounds, t.boxBounds, t.renderSpread) : br(t.renderBounds, t.strokeBounds)
        }
    }
      , Tr = {
        __render(t, e) {
            if (this.__worldOpacity)
                if (t.setWorld(this.__nowWorld = this.__getNowWorld(e)),
                t.opacity = this.__.opacity,
                this.__.__single) {
                    if ("path" === this.__.eraser)
                        return this.__renderEraser(t, e);
                    const i = t.getSameCanvas(!0, !0);
                    this.__draw(i, e),
                    this.__worldFlipped ? t.copyWorldByReset(i, this.__nowWorld, null, this.__.__blendMode, !0) : t.copyWorldToInner(i, this.__nowWorld, this.__layout.renderBounds, this.__.__blendMode),
                    i.recycle(this.__nowWorld)
                } else
                    this.__draw(t, e)
        },
        __clip(t, e) {
            this.__worldOpacity && (t.setWorld(this.__nowWorld = this.__getNowWorld(e)),
            this.__drawRenderPath(t),
            this.windingRule ? t.clip(this.windingRule) : t.clip())
        },
        __updateWorldOpacity() {
            this.__worldOpacity = this.__.visible ? this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity : 0,
            this.__layout.opacityChanged && (this.__layout.opacityChanged = !1)
        }
    }
      , {excludeRenderBounds: Br} = Eo
      , Lr = {
        __updateChange() {
            const {__layout: t} = this;
            t.childrenSortChanged && (this.__updateSortChildren(),
            t.childrenSortChanged = !1),
            this.__.__checkSingle()
        },
        __render(t, e) {
            if (this.__nowWorld = this.__getNowWorld(e),
            this.__worldOpacity)
                if (this.__.__single) {
                    if ("path" === this.__.eraser)
                        return this.__renderEraser(t, e);
                    const i = t.getSameCanvas(!1, !0);
                    this.__renderBranch(i, e);
                    const s = this.__nowWorld;
                    t.opacity = this.__.opacity,
                    t.copyWorldByReset(i, s, s, this.__.__blendMode, !0),
                    i.recycle(s)
                } else
                    this.__renderBranch(t, e)
        },
        __renderBranch(t, e) {
            if (this.__hasMask)
                this.__renderMask(t, e);
            else {
                const {children: i} = this;
                for (let s = 0, n = i.length; s < n; s++)
                    Br(i[s], e) || i[s].__render(t, e)
            }
        },
        __clip(t, e) {
            if (this.__worldOpacity) {
                const {children: i} = this;
                for (let s = 0, n = i.length; s < n; s++)
                    Br(i[s], e) || i[s].__clip(t, e)
            }
        }
    }
      , {LEAF: Pr, create: Cr} = s
      , {toInnerPoint: Rr, toOuterPoint: Sr, multiplyParent: Or} = b
      , {toOuterOf: Dr} = ot
      , {copy: Mr, move: Ir} = D
      , {moveLocal: Ar, zoomOfLocal: Wr, rotateOfLocal: zr, skewOfLocal: Fr, moveWorld: Ur, zoomOfWorld: Hr, rotateOfWorld: Nr, skewOfWorld: Yr, transform: Xr, transformWorld: Vr, setTransform: jr, getFlipTransform: Gr, getLocalOrigin: Zr, getRelativeWorld: Kr, drop: qr} = go;
    t.Leaf = class {
        get tag() {
            return this.__tag
        }
        set tag(t) {}
        get __tag() {
            return "Leaf"
        }
        get innerName() {
            return this.__.name || this.tag + this.innerId
        }
        get __DataProcessor() {
            return At
        }
        get __LayoutProcessor() {
            return zo
        }
        get leaferIsCreated() {
            return this.leafer && this.leafer.created
        }
        get leaferIsReady() {
            return this.leafer && this.leafer.ready
        }
        get isLeafer() {
            return !1
        }
        get isBranch() {
            return !1
        }
        get isBranchLeaf() {
            return !1
        }
        get __localMatrix() {
            return this.__local || this.__layout
        }
        get __localBoxBounds() {
            return this.__local || this.__layout
        }
        get worldTransform() {
            return this.__layout.getTransform("world")
        }
        get localTransform() {
            return this.__layout.getTransform("local")
        }
        get boxBounds() {
            return this.getBounds("box", "inner")
        }
        get renderBounds() {
            return this.getBounds("render", "inner")
        }
        get worldBoxBounds() {
            return this.getBounds("box")
        }
        get worldStrokeBounds() {
            return this.getBounds("stroke")
        }
        get worldRenderBounds() {
            return this.getBounds("render")
        }
        get worldOpacity() {
            return this.__layout.update(),
            this.__worldOpacity
        }
        get __worldFlipped() {
            return this.__world.scaleX < 0 || this.__world.scaleY < 0
        }
        get __onlyHitMask() {
            return this.__hasMask && !this.__.hitChildren
        }
        get __ignoreHitWorld() {
            return (this.__hasMask || this.__hasEraser) && this.__.hitChildren
        }
        get __inLazyBounds() {
            const {leafer: t} = this;
            return t && t.created && t.lazyBounds.hit(this.__world)
        }
        get pathInputed() {
            return this.__.__pathInputed
        }
        set event(t) {
            this.on(t)
        }
        constructor(t) {
            this.innerId = Cr(Pr),
            this.reset(t),
            this.__bubbleMap && this.__emitLifeEvent(Uo.CREATED)
        }
        reset(t) {
            this.leafer && this.leafer.forceRender(this.__world),
            this.__world = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                scaleX: 1,
                scaleY: 1
            },
            null !== t && (this.__local = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }),
            this.__worldOpacity = 1,
            this.__ = new this.__DataProcessor(this),
            this.__layout = new this.__LayoutProcessor(this),
            this.__level && this.resetCustom(),
            t && (t.__ && (t = t.toJSON()),
            t.children ? this.set(t) : Object.assign(this, t))
        }
        resetCustom() {
            this.__hasMask = this.__hasEraser = null,
            this.forceUpdate()
        }
        waitParent(t, e) {
            e && (t = t.bind(e)),
            this.parent ? t() : this.on(Uo.ADD, t, "once")
        }
        waitLeafer(t, e) {
            e && (t = t.bind(e)),
            this.leafer ? t() : this.on(Uo.MOUNTED, t, "once")
        }
        nextRender(t, e, i) {
            this.leafer ? this.leafer.nextRender(t, e, i) : this.waitLeafer(( () => this.leafer.nextRender(t, e, i)))
        }
        removeNextRender(t) {
            this.nextRender(t, null, "off")
        }
        __bindLeafer(t) {
            if (this.isLeafer && null !== t && (t = this),
            this.leafer && !t && this.leafer.leafs--,
            this.leafer = t,
            t ? (t.leafs++,
            this.__level = this.parent ? this.parent.__level + 1 : 1,
            this.animation && this.__runAnimation("in"),
            this.__bubbleMap && this.__emitLifeEvent(Uo.MOUNTED)) : this.__emitLifeEvent(Uo.UNMOUNTED),
            this.isBranch) {
                const {children: e} = this;
                for (let i = 0, s = e.length; i < s; i++)
                    e[i].__bindLeafer(t)
            }
        }
        set(t, e) {}
        get(t) {}
        setAttr(t, e) {
            this[t] = e
        }
        getAttr(t) {
            return this[t]
        }
        getComputedAttr(t) {
            return this.__[t]
        }
        toJSON(t) {
            return t && this.__layout.update(),
            this.__.__getInputData(null, t)
        }
        toString(t) {
            return JSON.stringify(this.toJSON(t))
        }
        toSVG() {}
        __SVG(t) {}
        toHTML() {}
        __setAttr(t, e) {
            return !0
        }
        __getAttr(t) {}
        setProxyAttr(t, e) {}
        getProxyAttr(t) {}
        find(t, e) {}
        findTag(t) {}
        findOne(t, e) {}
        findId(t) {}
        focus(t) {}
        updateState() {}
        updateLayout() {
            this.__layout.update()
        }
        forceUpdate(t) {
            void 0 === t ? t = "width" : "surface" === t && (t = "blendMode");
            const e = this.__.__getInput(t);
            this.__[t] = void 0 === e ? null : void 0,
            this[t] = e
        }
        forceRender(t, e) {
            this.forceUpdate("surface")
        }
        __updateWorldMatrix() {}
        __updateLocalMatrix() {}
        __updateWorldBounds() {}
        __updateLocalBounds() {}
        __updateLocalBoxBounds() {}
        __updateLocalStrokeBounds() {}
        __updateLocalRenderBounds() {}
        __updateBoxBounds() {}
        __updateContentBounds() {}
        __updateStrokeBounds() {}
        __updateRenderBounds() {}
        __updateAutoLayout() {}
        __updateFlowLayout() {}
        __updateNaturalSize() {}
        __updateStrokeSpread() {
            return 0
        }
        __updateRenderSpread() {
            return 0
        }
        __onUpdateSize() {}
        __updateEraser(t) {
            this.__hasEraser = !!t || this.children.some((t => t.__.eraser))
        }
        __renderEraser(t, e) {
            t.save(),
            this.__clip(t, e);
            const {renderBounds: i} = this.__layout;
            t.clearRect(i.x, i.y, i.width, i.height),
            t.restore()
        }
        __updateMask(t) {
            this.__hasMask = this.children.some((t => t.__.mask && t.__.visible && t.__.opacity))
        }
        __renderMask(t, e) {}
        __getNowWorld(t) {
            if (t.matrix) {
                this.__cameraWorld || (this.__cameraWorld = {});
                const e = this.__cameraWorld;
                return Or(this.__world, t.matrix, e, void 0, this.__world),
                Dr(this.__layout.renderBounds, e, e),
                e
            }
            return this.__world
        }
        getTransform(t) {
            return this.__layout.getTransform(t || "local")
        }
        getBounds(t, e) {
            return this.__layout.getBounds(t, e)
        }
        getLayoutBounds(t, e, i) {
            return this.__layout.getLayoutBounds(t, e, i)
        }
        getLayoutPoints(t, e) {
            return this.__layout.getLayoutPoints(t, e)
        }
        getWorldBounds(t, e, i) {
            const s = e ? Kr(this, e) : this.worldTransform
              , n = i ? t : {};
            return Dr(t, s, n),
            n
        }
        worldToLocal(t, e, i, s) {
            this.parent ? this.parent.worldToInner(t, e, i, s) : e && Mr(e, t)
        }
        localToWorld(t, e, i, s) {
            this.parent ? this.parent.innerToWorld(t, e, i, s) : e && Mr(e, t)
        }
        worldToInner(t, e, i, s) {
            s && (s.innerToWorld(t, e, i),
            t = e || t),
            Rr(this.worldTransform, t, e, i)
        }
        innerToWorld(t, e, i, s) {
            Sr(this.worldTransform, t, e, i),
            s && s.worldToInner(e || t, null, i)
        }
        getBoxPoint(t, e, i, s) {
            return this.getBoxPointByInner(this.getInnerPoint(t, e, i, s), null, null, !0)
        }
        getBoxPointByInner(t, e, i, s) {
            const n = s ? t : Object.assign({}, t)
              , {x: o, y: r} = this.boxBounds;
            return Ir(n, -o, -r),
            n
        }
        getInnerPoint(t, e, i, s) {
            const n = s ? t : {};
            return this.worldToInner(t, n, i, e),
            n
        }
        getInnerPointByBox(t, e, i, s) {
            const n = s ? t : Object.assign({}, t)
              , {x: o, y: r} = this.boxBounds;
            return Ir(n, o, r),
            n
        }
        getInnerPointByLocal(t, e, i, s) {
            return this.getInnerPoint(t, this.parent, i, s)
        }
        getLocalPoint(t, e, i, s) {
            const n = s ? t : {};
            return this.worldToLocal(t, n, i, e),
            n
        }
        getLocalPointByInner(t, e, i, s) {
            return this.getWorldPoint(t, this.parent, i, s)
        }
        getPagePoint(t, e, i, s) {
            return (this.leafer ? this.leafer.zoomLayer : this).getInnerPoint(t, e, i, s)
        }
        getWorldPoint(t, e, i, s) {
            const n = s ? t : {};
            return this.innerToWorld(t, n, i, e),
            n
        }
        getWorldPointByBox(t, e, i, s) {
            return this.getWorldPoint(this.getInnerPointByBox(t, null, null, s), e, i, !0)
        }
        getWorldPointByLocal(t, e, i, s) {
            const n = s ? t : {};
            return this.localToWorld(t, n, i, e),
            n
        }
        getWorldPointByPage(t, e, i, s) {
            return (this.leafer ? this.leafer.zoomLayer : this).getWorldPoint(t, e, i, s)
        }
        setTransform(t, e) {
            jr(this, t, e)
        }
        transform(t, e) {
            Xr(this, t, e)
        }
        move(t, e, i) {
            Ar(this, t, e, i)
        }
        moveInner(t, e, i) {
            Ur(this, t, e, !0, i)
        }
        scaleOf(t, e, i, s) {
            Wr(this, Zr(this, t), e, i, s)
        }
        rotateOf(t, e) {
            zr(this, Zr(this, t), e)
        }
        skewOf(t, e, i, s) {
            Fr(this, Zr(this, t), e, i, s)
        }
        transformWorld(t, e) {
            Vr(this, t, e)
        }
        moveWorld(t, e, i) {
            Ur(this, t, e, !1, i)
        }
        scaleOfWorld(t, e, i, s) {
            Hr(this, t, e, i, s)
        }
        rotateOfWorld(t, e) {
            Nr(this, t, e)
        }
        skewOfWorld(t, e, i, s) {
            Yr(this, t, e, i, s)
        }
        flip(t) {
            Xr(this, Gr(this, t))
        }
        scaleResize(t, e=t, i) {
            this.scaleX *= t,
            this.scaleY *= e
        }
        __scaleResize(t, e) {}
        resizeWidth(t) {}
        resizeHeight(t) {}
        __hitWorld(t) {
            return !0
        }
        __hit(t) {
            return !0
        }
        __hitFill(t) {
            return !0
        }
        __hitStroke(t, e) {
            return !0
        }
        __hitPixel(t) {
            return !0
        }
        __drawHitPath(t) {}
        __updateHitCanvas() {}
        __render(t, e) {}
        __drawFast(t, e) {}
        __draw(t, e) {}
        __clip(t, e) {}
        __renderShape(t, e, i, s) {}
        __updateWorldOpacity() {}
        __updateChange() {}
        __drawPath(t) {}
        __drawRenderPath(t) {}
        __updatePath() {}
        __updateRenderPath() {}
        getMotionPathData() {
            return Bt.need("path")
        }
        getMotionPoint(t) {
            return Bt.need("path")
        }
        getMotionTotal() {
            return 0
        }
        __updateMotionPath() {}
        __runAnimation(t, e) {}
        __updateSortChildren() {}
        add(t, e) {}
        remove(t, e) {
            this.parent && this.parent.remove(this, e)
        }
        dropTo(t, e, i) {
            qr(this, t, e, i)
        }
        on(t, e, i) {}
        off(t, e, i) {}
        on_(t, e, i, s) {}
        off_(t) {}
        once(t, e, i) {}
        emit(t, e, i) {}
        emitEvent(t, e) {}
        hasEvent(t, e) {
            return !1
        }
        static changeAttr(t, e, i) {
            i ? this.addAttr(t, e, i) : Zn(this.prototype, t, e)
        }
        static addAttr(t, e, i) {
            i || (i = Pn),
            i(e)(this.prototype, t)
        }
        __emitLifeEvent(t) {
            this.hasEvent(t) && this.emitEvent(new Uo(t,this,this.parent))
        }
        destroy() {
            this.destroyed || (this.parent && this.remove(),
            this.children && this.clear(),
            this.__emitLifeEvent(Uo.DESTROY),
            this.__.destroy(),
            this.__layout.destroy(),
            this.destroyEventer(),
            this.destroyed = !0)
        }
    }
    ,
    t.Leaf = zt([eo(lr), eo(fr), eo(kr), eo(rr), eo(Tr)], t.Leaf);
    const {setListWithFn: Jr} = ot
      , {sort: $r} = To
      , {localBoxBounds: Qr, localStrokeBounds: ta, localRenderBounds: ea, maskLocalBoxBounds: ia, maskLocalStrokeBounds: sa, maskLocalRenderBounds: na} = Eo
      , oa = new wt("Branch");
    t.Branch = class extends t.Leaf {
        __updateStrokeSpread() {
            const {children: t} = this;
            for (let e = 0, i = t.length; e < i; e++)
                if (t[e].__layout.strokeSpread)
                    return 1;
            return 0
        }
        __updateRenderSpread() {
            const {children: t} = this;
            for (let e = 0, i = t.length; e < i; e++)
                if (t[e].__layout.renderSpread)
                    return 1;
            return 0
        }
        __updateBoxBounds() {
            Jr(this.__layout.boxBounds, this.children, this.__hasMask ? ia : Qr)
        }
        __updateStrokeBounds() {
            Jr(this.__layout.strokeBounds, this.children, this.__hasMask ? sa : ta)
        }
        __updateRenderBounds() {
            Jr(this.__layout.renderBounds, this.children, this.__hasMask ? na : ea)
        }
        __updateSortChildren() {
            let t;
            const {children: e} = this;
            if (e.length > 1) {
                for (let i = 0, s = e.length; i < s; i++)
                    e[i].__tempNumber = i,
                    e[i].__.zIndex && (t = !0);
                e.sort($r),
                this.__layout.affectChildrenSort = t
            }
        }
        add(t, e) {
            if (t === this || t.destroyed)
                return oa.warn("add self or destroyed");
            const i = void 0 === e;
            if (!t.__) {
                if (t instanceof Array)
                    return t.forEach((t => {
                        this.add(t, e),
                        i || e++
                    }
                    ));
                t = Pt.get(t.tag, t)
            }
            t.parent && t.parent.remove(t),
            t.parent = this,
            i ? this.children.push(t) : this.children.splice(e, 0, t),
            t.isBranch && (this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1);
            const s = t.__layout;
            s.boxChanged || s.boxChange(),
            s.matrixChanged || s.matrixChange(),
            t.__bubbleMap && t.__emitLifeEvent(Uo.ADD),
            this.leafer && (t.__bindLeafer(this.leafer),
            this.leafer.created && this.__emitChildEvent(Uo.ADD, t)),
            this.__layout.affectChildrenSort && this.__layout.childrenSortChange()
        }
        addMany(...t) {
            this.add(t)
        }
        remove(t, e) {
            t ? t.__ ? t.animationOut ? t.__runAnimation("out", ( () => this.__remove(t, e))) : this.__remove(t, e) : this.find(t).forEach((t => this.remove(t, e))) : void 0 === t && super.remove(null, e)
        }
        removeAll(t) {
            const {children: e} = this;
            e.length && (this.children = [],
            this.__preRemove(),
            this.__.__childBranchNumber = 0,
            e.forEach((e => {
                this.__realRemoveChild(e),
                t && e.destroy()
            }
            )))
        }
        clear() {
            this.removeAll(!0)
        }
        __remove(t, e) {
            const i = this.children.indexOf(t);
            i > -1 && (this.children.splice(i, 1),
            t.isBranch && (this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1),
            this.__preRemove(),
            this.__realRemoveChild(t),
            e && t.destroy())
        }
        __preRemove() {
            this.__hasMask && this.__updateMask(),
            this.__hasEraser && this.__updateEraser(),
            this.__layout.boxChange(),
            this.__layout.affectChildrenSort && this.__layout.childrenSortChange()
        }
        __realRemoveChild(t) {
            t.__emitLifeEvent(Uo.REMOVE),
            t.parent = null,
            this.leafer && (t.__bindLeafer(null),
            this.leafer.created && (this.__emitChildEvent(Uo.REMOVE, t),
            this.leafer.hitCanvasManager && this.leafer.hitCanvasManager.clear()))
        }
        __emitChildEvent(t, e) {
            const i = new Uo(t,e,this);
            this.hasEvent(t) && !this.isLeafer && this.emitEvent(i),
            this.leafer.emitEvent(i)
        }
    }
    ,
    t.Branch = zt([eo(Lr)], t.Branch);
    class ra {
        get length() {
            return this.list.length
        }
        constructor(t) {
            this.reset(),
            t && (t instanceof Array ? this.addList(t) : this.add(t))
        }
        has(t) {
            return t && void 0 !== this.keys[t.innerId]
        }
        indexAt(t) {
            return this.list[t]
        }
        indexOf(t) {
            const e = this.keys[t.innerId];
            return void 0 === e ? -1 : e
        }
        add(t) {
            const {list: e, keys: i} = this;
            void 0 === i[t.innerId] && (e.push(t),
            i[t.innerId] = e.length - 1)
        }
        addAt(t, e=0) {
            const {keys: i} = this;
            if (void 0 === i[t.innerId]) {
                const {list: s} = this;
                for (let t = e, n = s.length; t < n; t++)
                    i[s[t].innerId]++;
                0 === e ? s.unshift(t) : (e > s.length && (e = s.length),
                s.splice(e, 0, t)),
                i[t.innerId] = e
            }
        }
        addList(t) {
            for (let e = 0; e < t.length; e++)
                this.add(t[e])
        }
        remove(t) {
            const {list: e} = this;
            let i;
            for (let s = 0, n = e.length; s < n; s++)
                void 0 !== i ? this.keys[e[s].innerId] = s - 1 : e[s].innerId === t.innerId && (i = s,
                delete this.keys[t.innerId]);
            void 0 !== i && e.splice(i, 1)
        }
        sort(t) {
            const {list: e} = this;
            t ? e.sort(( (t, e) => e.__level - t.__level)) : e.sort(( (t, e) => t.__level - e.__level))
        }
        forEach(t) {
            this.list.forEach(t)
        }
        clone() {
            const t = new ra;
            return t.list = [...this.list],
            t.keys = Object.assign({}, this.keys),
            t
        }
        update() {
            this.keys = {};
            const {list: t, keys: e} = this;
            for (let i = 0, s = t.length; i < s; i++)
                e[t[i].innerId] = i
        }
        reset() {
            this.list = [],
            this.keys = {}
        }
        destroy() {
            this.reset()
        }
    }
    class aa {
        get length() {
            return this._length
        }
        constructor(t) {
            this._length = 0,
            this.reset(),
            t && (t instanceof Array ? this.addList(t) : this.add(t))
        }
        has(t) {
            return void 0 !== this.keys[t.innerId]
        }
        without(t) {
            return void 0 === this.keys[t.innerId]
        }
        sort(t) {
            const {levels: e} = this;
            t ? e.sort(( (t, e) => e - t)) : e.sort(( (t, e) => t - e))
        }
        addList(t) {
            t.forEach((t => {
                this.add(t)
            }
            ))
        }
        add(t) {
            const {keys: e, levelMap: i} = this;
            e[t.innerId] || (e[t.innerId] = 1,
            i[t.__level] ? i[t.__level].push(t) : (i[t.__level] = [t],
            this.levels.push(t.__level)),
            this._length++)
        }
        forEach(t) {
            let e;
            this.levels.forEach((i => {
                e = this.levelMap[i];
                for (let i = 0, s = e.length; i < s; i++)
                    t(e[i])
            }
            ))
        }
        reset() {
            this.levelMap = {},
            this.keys = {},
            this.levels = [],
            this._length = 0
        }
        destroy() {
            this.levelMap = null
        }
    }
    const ha = wt.get("LeaferCanvas");
    class la extends Zt {
        set zIndex(t) {
            const {style: e} = this.view;
            e.zIndex = t,
            this.setAbsolute(this.view)
        }
        set childIndex(t) {
            const {view: e, parentView: i} = this;
            if (e && i) {
                const s = i.children[t];
                s ? (this.setAbsolute(s),
                i.insertBefore(e, s)) : i.appendChild(s)
            }
        }
        init() {
            const {config: t} = this
              , i = t.view || t.canvas;
            i ? this.__createViewFrom(i) : this.__createView();
            const {style: s} = this.view;
            if (s.display || (s.display = "block"),
            this.parentView = this.view.parentElement,
            this.parentView) {
                const t = this.parentView.style;
                t.webkitUserSelect = t.userSelect = "none"
            }
            e.syncDomFont && !this.parentView && (s.display = "none",
            document.body.appendChild(this.view)),
            this.__createContext(),
            this.autoLayout || this.resize(t)
        }
        set backgroundColor(t) {
            this.view.style.backgroundColor = t
        }
        get backgroundColor() {
            return this.view.style.backgroundColor
        }
        set hittable(t) {
            this.view.style.pointerEvents = t ? "auto" : "none"
        }
        get hittable() {
            return "none" !== this.view.style.pointerEvents
        }
        __createView() {
            this.view = document.createElement("canvas")
        }
        __createViewFrom(t) {
            let e = "string" == typeof t ? document.getElementById(t) : t;
            if (e)
                if (e instanceof HTMLCanvasElement)
                    this.view = e;
                else {
                    let t = e;
                    if (e === window || e === document) {
                        const e = document.createElement("div")
                          , {style: i} = e;
                        i.position = "absolute",
                        i.top = i.bottom = i.left = i.right = "0px",
                        document.body.appendChild(e),
                        t = e
                    }
                    this.__createView();
                    const i = this.view;
                    t.hasChildNodes() && (this.setAbsolute(i),
                    t.style.position || (t.style.position = "relative")),
                    t.appendChild(i)
                }
            else
                ha.error(`no id: ${t}`),
                this.__createView()
        }
        setAbsolute(t) {
            const {style: e} = t;
            e.position = "absolute",
            e.top = e.left = "0px"
        }
        updateViewSize() {
            const {width: t, height: e, pixelRatio: i} = this
              , {style: s} = this.view;
            s.width = t + "px",
            s.height = e + "px",
            this.view.width = Math.ceil(t * i),
            this.view.height = Math.ceil(e * i)
        }
        updateClientBounds() {
            this.clientBounds = this.view.getBoundingClientRect()
        }
        startAutoLayout(t, i) {
            if (this.resizeListener = i,
            t) {
                this.autoBounds = t;
                try {
                    this.resizeObserver = new ResizeObserver((t => {
                        this.updateClientBounds();
                        for (const e of t)
                            this.checkAutoBounds(e.contentRect)
                    }
                    ));
                    const t = this.parentView;
                    t ? (this.resizeObserver.observe(t),
                    this.checkAutoBounds(t.getBoundingClientRect())) : (this.checkAutoBounds(this.view),
                    ha.warn("no parent"))
                } catch (t) {
                    this.imitateResizeObserver()
                }
            } else
                window.addEventListener("resize", ( () => {
                    const t = e.devicePixelRatio;
                    if (this.pixelRatio !== t) {
                        const {width: e, height: i} = this;
                        this.emitResize({
                            width: e,
                            height: i,
                            pixelRatio: t
                        })
                    }
                }
                ))
        }
        imitateResizeObserver() {
            this.autoLayout && (this.parentView && this.checkAutoBounds(this.parentView.getBoundingClientRect()),
            e.requestRender(this.imitateResizeObserver.bind(this)))
        }
        checkAutoBounds(t) {
            const i = this.view
              , {x: s, y: n, width: o, height: r} = this.autoBounds.getBoundsFrom(t)
              , a = {
                width: o,
                height: r,
                pixelRatio: e.devicePixelRatio
            };
            if (!this.isSameSize(a)) {
                const {style: t} = i;
                t.marginLeft = s + "px",
                t.marginTop = n + "px",
                this.emitResize(a)
            }
        }
        stopAutoLayout() {
            this.autoLayout = !1,
            this.resizeListener = null,
            this.resizeObserver && (this.resizeObserver.disconnect(),
            this.resizeObserver = null)
        }
        emitResize(t) {
            const e = {};
            Mt.copyAttrs(e, this, Gt),
            this.resize(t),
            this.resizeListener && void 0 !== this.width && this.resizeListener(new Yo(t,e))
        }
        unrealCanvas() {
            if (!this.unreal && this.parentView) {
                const t = this.view;
                t && t.remove(),
                this.view = this.parentView,
                this.unreal = !0
            }
        }
        destroy() {
            if (this.view) {
                if (this.stopAutoLayout(),
                !this.unreal) {
                    const t = this.view;
                    t.parentElement && t.remove()
                }
                super.destroy()
            }
        }
    }
    an(CanvasRenderingContext2D.prototype),
    an(Path2D.prototype);
    const {mineType: da, fileType: ca} = hn;
    function ua(t, s) {
        e.origin = {
            createCanvas(t, e) {
                const i = document.createElement("canvas");
                return i.width = t,
                i.height = e,
                i
            },
            canvasToDataURL: (t, e, i) => t.toDataURL(da(e), i),
            canvasToBolb: (t, e, i) => new Promise((s => t.toBlob(s, da(e), i))),
            canvasSaveAs: (t, i, s) => {
                const n = t.toDataURL(da(ca(i)), s);
                return e.origin.download(n, i)
            }
            ,
            download: (t, e) => new Promise((i => {
                let s = document.createElement("a");
                s.href = t,
                s.download = e,
                document.body.appendChild(s),
                s.click(),
                document.body.removeChild(s),
                i()
            }
            )),
            loadImage: t => new Promise(( (i, s) => {
                const n = new Image
                  , {crossOrigin: o} = e.image;
                o && (n.setAttribute("crossOrigin", o),
                n.crossOrigin = o),
                n.onload = () => {
                    i(n)
                }
                ,
                n.onerror = t => {
                    s(t)
                }
                ,
                n.src = e.image.getRealURL(t)
            }
            ))
        },
        e.event = {
            stopDefault(t) {
                t.preventDefault()
            },
            stopNow(t) {
                t.stopImmediatePropagation()
            },
            stop(t) {
                t.stopPropagation()
            }
        },
        e.canvas = i.canvas(),
        e.conicGradientSupport = !!e.canvas.context.createConicGradient
    }
    Object.assign(i, {
        canvas: (t, e) => new la(t,e),
        image: t => new yn(t)
    }),
    e.name = "web",
    e.isMobile = "ontouchstart"in window,
    e.requestRender = function(t) {
        window.requestAnimationFrame(t)
    }
    ,
    mn(e, "devicePixelRatio", {
        get: () => Math.max(1, devicePixelRatio)
    });
    const {userAgent: pa} = navigator;
    pa.indexOf("Firefox") > -1 ? (e.conicGradientRotate90 = !0,
    e.intWheelDeltaY = !0,
    e.syncDomFont = !0) : pa.indexOf("Safari") > -1 && -1 === pa.indexOf("Chrome") && (e.fullImageShadow = !0),
    pa.indexOf("Windows") > -1 ? (e.os = "Windows",
    e.intWheelDeltaY = !0) : pa.indexOf("Mac") > -1 ? e.os = "Mac" : pa.indexOf("Linux") > -1 && (e.os = "Linux");
    class _a {
        get childrenChanged() {
            return this.hasAdd || this.hasRemove || this.hasVisible
        }
        get updatedList() {
            if (this.hasRemove) {
                const t = new ra;
                return this.__updatedList.list.forEach((e => {
                    e.leafer && t.add(e)
                }
                )),
                t
            }
            return this.__updatedList
        }
        constructor(t, e) {
            this.totalTimes = 0,
            this.config = {},
            this.__updatedList = new ra,
            this.target = t,
            e && (this.config = Mt.default(e, this.config)),
            this.__listenEvents()
        }
        start() {
            this.disabled || (this.running = !0)
        }
        stop() {
            this.running = !1
        }
        disable() {
            this.stop(),
            this.__removeListenEvents(),
            this.disabled = !0
        }
        update() {
            this.changed = !0,
            this.running && this.target.emit(jo.REQUEST)
        }
        __onAttrChange(t) {
            this.__updatedList.add(t.target),
            this.update()
        }
        __onChildEvent(t) {
            t.type === Uo.ADD ? (this.hasAdd = !0,
            this.__pushChild(t.child)) : (this.hasRemove = !0,
            this.__updatedList.add(t.parent)),
            this.update()
        }
        __pushChild(t) {
            this.__updatedList.add(t),
            t.isBranch && this.__loopChildren(t)
        }
        __loopChildren(t) {
            const {children: e} = t;
            for (let t = 0, i = e.length; t < i; t++)
                this.__pushChild(e[t])
        }
        __onRquestData() {
            this.target.emitEvent(new Xo(Xo.DATA,{
                updatedList: this.updatedList
            })),
            this.__updatedList = new ra,
            this.totalTimes++,
            this.changed = !1,
            this.hasVisible = !1,
            this.hasRemove = !1,
            this.hasAdd = !1
        }
        __listenEvents() {
            const {target: t} = this;
            this.__eventIds = [t.on_(Ho.CHANGE, this.__onAttrChange, this), t.on_([Uo.ADD, Uo.REMOVE], this.__onChildEvent, this), t.on_(Xo.REQUEST, this.__onRquestData, this)]
        }
        __removeListenEvents() {
            this.target.off_(this.__eventIds)
        }
        destroy() {
            this.target && (this.stop(),
            this.__removeListenEvents(),
            this.target = null,
            this.__updatedList = null)
        }
    }
    const {updateAllMatrix: ga, updateBounds: fa, updateAllWorldOpacity: ya} = go
      , {pushAllChildBranch: ma, pushAllParent: va} = To;
    const {worldBounds: wa} = Eo
      , xa = {
        x: 0,
        y: 0,
        width: 1e5,
        height: 1e5
    };
    class ba {
        constructor(t) {
            this.updatedBounds = new lt,
            this.beforeBounds = new lt,
            this.afterBounds = new lt,
            t instanceof Array && (t = new ra(t)),
            this.updatedList = t
        }
        setBefore() {
            this.beforeBounds.setListWithFn(this.updatedList.list, wa)
        }
        setAfter() {
            const {list: t} = this.updatedList;
            t.some((t => t.noBounds)) ? this.afterBounds.set(xa) : this.afterBounds.setListWithFn(t, wa),
            this.updatedBounds.setList([this.beforeBounds, this.afterBounds])
        }
        merge(t) {
            this.updatedList.addList(t.updatedList.list),
            this.beforeBounds.add(t.beforeBounds),
            this.afterBounds.add(t.afterBounds),
            this.updatedBounds.add(t.updatedBounds)
        }
        destroy() {
            this.updatedList = null
        }
    }
    const {updateAllMatrix: Ea, updateAllChange: ka} = go
      , Ta = wt.get("Layouter");
    class Ba {
        constructor(t, e) {
            this.totalTimes = 0,
            this.config = {},
            this.__levelList = new aa,
            this.target = t,
            e && (this.config = Mt.default(e, this.config)),
            this.__listenEvents()
        }
        start() {
            this.disabled || (this.running = !0)
        }
        stop() {
            this.running = !1
        }
        disable() {
            this.stop(),
            this.__removeListenEvents(),
            this.disabled = !0
        }
        layout() {
            if (!this.running)
                return;
            const {target: t} = this;
            this.times = 0;
            try {
                t.emit(Vo.START),
                this.layoutOnce(),
                t.emitEvent(new Vo(Vo.END,this.layoutedBlocks,this.times))
            } catch (t) {
                Ta.error(t)
            }
            this.layoutedBlocks = null
        }
        layoutAgain() {
            this.layouting ? this.waitAgain = !0 : this.layoutOnce()
        }
        layoutOnce() {
            return this.layouting ? Ta.warn("layouting") : this.times > 3 ? Ta.warn("layout max times") : (this.times++,
            this.totalTimes++,
            this.layouting = !0,
            this.target.emit(Xo.REQUEST),
            this.totalTimes > 1 ? this.partLayout() : this.fullLayout(),
            this.layouting = !1,
            void (this.waitAgain && (this.waitAgain = !1,
            this.layoutOnce())))
        }
        partLayout() {
            var t;
            if (!(null === (t = this.__updatedList) || void 0 === t ? void 0 : t.length))
                return;
            const e = kt.start("PartLayout")
              , {target: i, __updatedList: s} = this
              , {BEFORE: n, LAYOUT: o, AFTER: r} = Vo
              , a = this.getBlocks(s);
            a.forEach((t => t.setBefore())),
            i.emitEvent(new Vo(n,a,this.times)),
            this.extraBlock = null,
            s.sort(),
            function(t, e) {
                let i;
                t.list.forEach((t => {
                    i = t.__layout,
                    e.without(t) && !i.proxyZoom && (i.matrixChanged ? (ga(t, !0),
                    e.add(t),
                    t.isBranch && ma(t, e),
                    va(t, e)) : i.boundsChanged && (e.add(t),
                    t.isBranch && (t.__tempNumber = 0),
                    va(t, e)))
                }
                ))
            }(s, this.__levelList),
            function(t) {
                let e, i, s;
                t.sort(!0),
                t.levels.forEach((n => {
                    e = t.levelMap[n];
                    for (let t = 0, n = e.length; t < n; t++) {
                        if (i = e[t],
                        i.isBranch && i.__tempNumber) {
                            s = i.children;
                            for (let t = 0, e = s.length; t < e; t++)
                                s[t].isBranch || fa(s[t])
                        }
                        fa(i)
                    }
                }
                ))
            }(this.__levelList),
            function(t) {
                let e;
                t.list.forEach((t => {
                    e = t.__layout,
                    e.opacityChanged && ya(t),
                    e.stateStyleChanged && setTimeout(( () => e.stateStyleChanged && t.updateState())),
                    t.__updateChange()
                }
                ))
            }(s),
            this.extraBlock && a.push(this.extraBlock),
            a.forEach((t => t.setAfter())),
            i.emitEvent(new Vo(o,a,this.times)),
            i.emitEvent(new Vo(r,a,this.times)),
            this.addBlocks(a),
            this.__levelList.reset(),
            this.__updatedList = null,
            kt.end(e)
        }
        fullLayout() {
            const t = kt.start("FullLayout")
              , {target: e} = this
              , {BEFORE: i, LAYOUT: s, AFTER: n} = Vo
              , o = this.getBlocks(new ra(e));
            e.emitEvent(new Vo(i,o,this.times)),
            Ba.fullLayout(e),
            o.forEach((t => {
                t.setAfter()
            }
            )),
            e.emitEvent(new Vo(s,o,this.times)),
            e.emitEvent(new Vo(n,o,this.times)),
            this.addBlocks(o),
            kt.end(t)
        }
        static fullLayout(t) {
            Ea(t, !0),
            t.isBranch ? To.updateBounds(t) : go.updateBounds(t),
            ka(t)
        }
        addExtra(t) {
            if (!this.__updatedList.has(t)) {
                const {updatedList: e, beforeBounds: i} = this.extraBlock || (this.extraBlock = new ba([]));
                e.length ? i.add(t.__world) : i.set(t.__world),
                e.add(t)
            }
        }
        createBlock(t) {
            return new ba(t)
        }
        getBlocks(t) {
            return [this.createBlock(t)]
        }
        addBlocks(t) {
            this.layoutedBlocks ? this.layoutedBlocks.push(...t) : this.layoutedBlocks = t
        }
        __onReceiveWatchData(t) {
            this.__updatedList = t.data.updatedList
        }
        __listenEvents() {
            const {target: t} = this;
            this.__eventIds = [t.on_(Vo.REQUEST, this.layout, this), t.on_(Vo.AGAIN, this.layoutAgain, this), t.on_(Xo.DATA, this.__onReceiveWatchData, this)]
        }
        __removeListenEvents() {
            this.target.off_(this.__eventIds)
        }
        destroy() {
            this.target && (this.stop(),
            this.__removeListenEvents(),
            this.target = this.config = null)
        }
    }
    const La = wt.get("Renderer");
    class Pa {
        get needFill() {
            return !(this.canvas.allowBackgroundColor || !this.config.fill)
        }
        constructor(t, e, i) {
            this.FPS = 60,
            this.totalTimes = 0,
            this.times = 0,
            this.config = {
                usePartRender: !0,
                maxFPS: 60
            },
            this.target = t,
            this.canvas = e,
            i && (this.config = Mt.default(i, this.config)),
            this.__listenEvents()
        }
        start() {
            this.running = !0,
            this.update(!1)
        }
        stop() {
            this.running = !1
        }
        update(t=!0) {
            this.changed || (this.changed = t),
            this.__requestRender()
        }
        requestLayout() {
            this.target.emit(Vo.REQUEST)
        }
        render(t) {
            if (!this.running || !this.canvas.view)
                return this.update();
            const {target: e} = this;
            this.times = 0,
            this.totalBounds = new lt,
            La.log(e.innerName, "---\x3e");
            try {
                e.isApp || e.app.emit(jo.CHILD_START, e),
                this.emitRender(jo.START),
                this.renderOnce(t),
                this.emitRender(jo.END, this.totalBounds),
                pn.clearRecycled()
            } catch (t) {
                this.rendering = !1,
                La.error(t)
            }
            La.log("-------------|")
        }
        renderAgain() {
            this.rendering ? this.waitAgain = !0 : this.renderOnce()
        }
        renderOnce(t) {
            if (this.rendering)
                return La.warn("rendering");
            if (this.times > 3)
                return La.warn("render max times");
            if (this.times++,
            this.totalTimes++,
            this.rendering = !0,
            this.changed = !1,
            this.renderBounds = new lt,
            this.renderOptions = {},
            t)
                this.emitRender(jo.BEFORE),
                t();
            else {
                if (this.requestLayout(),
                this.ignore)
                    return void (this.ignore = this.rendering = !1);
                this.emitRender(jo.BEFORE),
                this.config.usePartRender && this.totalTimes > 1 ? this.partRender() : this.fullRender()
            }
            this.emitRender(jo.RENDER, this.renderBounds, this.renderOptions),
            this.emitRender(jo.AFTER, this.renderBounds, this.renderOptions),
            this.updateBlocks = null,
            this.rendering = !1,
            this.waitAgain && (this.waitAgain = !1,
            this.renderOnce())
        }
        partRender() {
            const {canvas: t, updateBlocks: e} = this;
            if (!e)
                return La.warn("PartRender: need update attr");
            this.mergeBlocks(),
            e.forEach((e => {
                t.bounds.hit(e) && !e.isEmpty() && this.clipRender(e)
            }
            ))
        }
        clipRender(t) {
            const e = kt.start("PartRender")
              , {canvas: i} = this
              , s = t.getIntersect(i.bounds)
              , n = t.includes(this.target.__world)
              , o = new lt(s);
            i.save(),
            n && !wt.showRepaint ? i.clear() : (s.spread(10 + 1 / this.canvas.pixelRatio).ceil(),
            i.clearWorld(s, !0),
            i.clipWorld(s, !0)),
            this.__render(s, n, o),
            i.restore(),
            kt.end(e)
        }
        fullRender() {
            const t = kt.start("FullRender")
              , {canvas: e} = this;
            e.save(),
            e.clear(),
            this.__render(e.bounds, !0),
            e.restore(),
            kt.end(t)
        }
        __render(t, e, i) {
            const s = t.includes(this.target.__world) ? {
                includes: e
            } : {
                bounds: t,
                includes: e
            };
            this.needFill && this.canvas.fillWorld(t, this.config.fill),
            wt.showRepaint && this.canvas.strokeWorld(t, "red"),
            this.target.__render(this.canvas, s),
            this.renderBounds = i = i || t,
            this.renderOptions = s,
            this.totalBounds.isEmpty() ? this.totalBounds = i : this.totalBounds.add(i),
            wt.showHitView && this.renderHitView(s),
            wt.showBoundsView && this.renderBoundsView(s),
            this.canvas.updateRender(i)
        }
        renderHitView(t) {}
        renderBoundsView(t) {}
        addBlock(t) {
            this.updateBlocks || (this.updateBlocks = []),
            this.updateBlocks.push(t)
        }
        mergeBlocks() {
            const {updateBlocks: t} = this;
            if (t) {
                const e = new lt;
                e.setList(t),
                t.length = 0,
                t.push(e)
            }
        }
        __requestRender() {
            if (this.requestTime)
                return;
            const t = this.requestTime = Date.now();
            e.requestRender(( () => {
                this.FPS = Math.min(60, Math.ceil(1e3 / (Date.now() - t))),
                this.requestTime = 0,
                this.running && (this.changed && this.canvas.view && this.render(),
                this.target.emit(jo.NEXT))
            }
            ))
        }
        __onResize(t) {
            if (!this.canvas.unreal) {
                if (t.bigger || !t.samePixelRatio) {
                    const {width: e, height: i} = t.old;
                    if (!new lt(0,0,e,i).includes(this.target.__world) || this.needFill || !t.samePixelRatio)
                        return this.addBlock(this.canvas.bounds),
                        void this.target.forceUpdate("surface")
                }
                this.addBlock(new lt(0,0,1,1)),
                this.update()
            }
        }
        __onLayoutEnd(t) {
            t.data && t.data.map((t => {
                let e;
                t.updatedList && t.updatedList.list.some((t => (e = !t.__world.width || !t.__world.height,
                e && (t.isLeafer || La.tip(t.innerName, ": empty"),
                e = !t.isBranch || t.isBranchLeaf),
                e))),
                this.addBlock(e ? this.canvas.bounds : t.updatedBounds)
            }
            ))
        }
        emitRender(t, e, i) {
            this.target.emitEvent(new jo(t,this.times,e,i))
        }
        __listenEvents() {
            const {target: t} = this;
            this.__eventIds = [t.on_(jo.REQUEST, this.update, this), t.on_(Vo.END, this.__onLayoutEnd, this), t.on_(jo.AGAIN, this.renderAgain, this), t.on_(Yo.RESIZE, this.__onResize, this)]
        }
        __removeListenEvents() {
            this.target.off_(this.__eventIds)
        }
        destroy() {
            this.target && (this.stop(),
            this.__removeListenEvents(),
            this.target = this.canvas = this.config = null)
        }
    }
    const {hitRadiusPoint: Ca} = ot;
    class Ra {
        constructor(t, e) {
            this.target = t,
            this.selector = e
        }
        getByPoint(t, e, i) {
            e || (e = 0),
            i || (i = {});
            const s = i.through || !1
              , n = i.ignoreHittable || !1
              , o = i.target || this.target;
            this.exclude = i.exclude || null,
            this.point = {
                x: t.x,
                y: t.y,
                radiusX: e,
                radiusY: e
            },
            this.findList = new ra(i.findList),
            i.findList || this.hitBranch(o);
            const {list: r} = this.findList
              , a = this.getBestMatchLeaf(r, i.bottomList, n)
              , h = n ? this.getPath(a) : this.getHitablePath(a);
            return this.clear(),
            s ? {
                path: h,
                target: a,
                throughPath: r.length ? this.getThroughPath(r) : h
            } : {
                path: h,
                target: a
            }
        }
        getBestMatchLeaf(t, e, i) {
            if (t.length) {
                let e;
                this.findList = new ra;
                const {x: s, y: n} = this.point
                  , o = {
                    x: s,
                    y: n,
                    radiusX: 0,
                    radiusY: 0
                };
                for (let s = 0, n = t.length; s < n; s++)
                    if (e = t[s],
                    (i || go.worldHittable(e)) && (this.hitChild(e, o),
                    this.findList.length))
                        return this.findList.list[0]
            }
            if (e)
                for (let t = 0, i = e.length; t < i; t++)
                    if (this.hitChild(e[t].target, this.point, e[t].proxy),
                    this.findList.length)
                        return this.findList.list[0];
            return t[0]
        }
        getPath(t) {
            const e = new ra;
            for (; t; )
                e.add(t),
                t = t.parent;
            return this.target && e.add(this.target),
            e
        }
        getHitablePath(t) {
            const e = this.getPath(t && t.hittable ? t : null);
            let i, s = new ra;
            for (let t = e.list.length - 1; t > -1 && (i = e.list[t],
            i.__.hittable) && (s.addAt(i, 0),
            i.__.hitChildren); t--)
                ;
            return s
        }
        getThroughPath(t) {
            const e = new ra
              , i = [];
            for (let e = t.length - 1; e > -1; e--)
                i.push(this.getPath(t[e]));
            let s, n, o;
            for (let t = 0, r = i.length; t < r; t++) {
                s = i[t],
                n = i[t + 1];
                for (let t = 0, i = s.length; t < i && (o = s.list[t],
                !n || !n.has(o)); t++)
                    e.add(o)
            }
            return e
        }
        hitBranch(t) {
            this.eachFind(t.children, t.__onlyHitMask)
        }
        eachFind(t, e) {
            let i, s;
            const {point: n} = this;
            for (let o = t.length - 1; o > -1; o--)
                i = t[o],
                !i.__.visible || e && !i.__.mask || (s = !!i.__.hitRadius || Ca(i.__world, n),
                i.isBranch ? (s || i.__ignoreHitWorld) && (this.eachFind(i.children, i.__onlyHitMask),
                i.isBranchLeaf && this.hitChild(i, n)) : s && this.hitChild(i, n))
        }
        hitChild(t, e, i) {
            if ((!this.exclude || !this.exclude.has(t)) && t.__hitWorld(e)) {
                const {parent: s} = t;
                if (s && s.__hasMask && !t.__.mask && !s.children.some((t => t.__.mask && t.__hitWorld(e))))
                    return;
                this.findList.add(i || t)
            }
        }
        clear() {
            this.point = null,
            this.findList = null,
            this.exclude = null
        }
        destroy() {
            this.clear()
        }
    }
    const {Yes: Sa, NoAndSkip: Oa, YesAndSkip: Da} = t.Answer
      , Ma = {}
      , Ia = {}
      , Aa = {};
    class Wa {
        constructor(t, e) {
            this.config = {},
            this.innerIdMap = {},
            this.idMap = {},
            this.methods = {
                id: (t, e) => t.id === e ? (this.target && (this.idMap[e] = t),
                1) : 0,
                innerId: (t, e) => t.innerId === e ? (this.target && (this.innerIdMap[e] = t),
                1) : 0,
                className: (t, e) => t.className === e ? 1 : 0,
                tag: (t, e) => t.__tag === e ? 1 : 0,
                tags: (t, e) => e[t.__tag] ? 1 : 0
            },
            this.target = t,
            e && (this.config = Mt.default(e, this.config)),
            this.picker = new Ra(t,this),
            t && this.__listenEvents()
        }
        getBy(t, e, i, s) {
            switch (typeof t) {
            case "number":
                const n = this.getByInnerId(t, e);
                return i ? n : n ? [n] : [];
            case "string":
                switch (t[0]) {
                case "#":
                    Ma.id = t.substring(1),
                    t = Ma;
                    break;
                case ".":
                    Ia.className = t.substring(1),
                    t = Ia;
                    break;
                default:
                    Aa.tag = t,
                    t = Aa
                }
            case "object":
                if (void 0 !== t.id) {
                    const s = this.getById(t.id, e);
                    return i ? s : s ? [s] : []
                }
                if (t.tag) {
                    const {tag: s} = t
                      , n = s instanceof Array;
                    return this.getByMethod(n ? this.methods.tags : this.methods.tag, e, i, n ? Mt.toMap(s) : s)
                }
                return this.getByMethod(this.methods.className, e, i, t.className);
            case "function":
                return this.getByMethod(t, e, i, s)
            }
        }
        getByPoint(t, i, s) {
            return "node" === e.name && this.target && this.target.emit(Vo.CHECK_UPDATE),
            this.picker.getByPoint(t, i, s)
        }
        getByInnerId(t, e) {
            const i = this.innerIdMap[t];
            return i || (this.eachFind(this.toChildren(e), this.methods.innerId, null, t),
            this.findLeaf)
        }
        getById(t, e) {
            const i = this.idMap[t];
            return i && go.hasParent(i, e || this.target) ? i : (this.eachFind(this.toChildren(e), this.methods.id, null, t),
            this.findLeaf)
        }
        getByClassName(t, e) {
            return this.getByMethod(this.methods.className, e, !1, t)
        }
        getByTag(t, e) {
            return this.getByMethod(this.methods.tag, e, !1, t)
        }
        getByMethod(t, e, i, s) {
            const n = i ? null : [];
            return this.eachFind(this.toChildren(e), t, n, s),
            n || this.findLeaf
        }
        eachFind(t, e, i, s) {
            let n, o;
            for (let r = 0, a = t.length; r < a; r++) {
                if (n = t[r],
                o = e(n, s),
                o === Sa || o === Da) {
                    if (!i)
                        return void (this.findLeaf = n);
                    i.push(n)
                }
                n.isBranch && o < Oa && this.eachFind(n.children, e, i, s)
            }
        }
        toChildren(t) {
            return this.findLeaf = null,
            [t || this.target]
        }
        __onRemoveChild(t) {
            const {id: e, innerId: i} = t.child;
            this.idMap[e] && delete this.idMap[e],
            this.innerIdMap[i] && delete this.innerIdMap[i]
        }
        __checkIdChange(t) {
            if ("id" === t.attrName) {
                const e = t.oldValue;
                this.idMap[e] && delete this.idMap[e]
            }
        }
        __listenEvents() {
            this.__eventIds = [this.target.on_(Uo.REMOVE, this.__onRemoveChild, this), this.target.on_(Ho.CHANGE, this.__checkIdChange, this)]
        }
        __removeListenEvents() {
            this.target.off_(this.__eventIds),
            this.__eventIds.length = 0
        }
        destroy() {
            this.__eventIds.length && (this.__removeListenEvents(),
            this.picker.destroy(),
            this.findLeaf = null,
            this.innerIdMap = {},
            this.idMap = {})
        }
    }
    function za(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e),
                e && (this.__.__useEffect = !0),
                this.__layout.renderChanged || this.__layout.renderChange()
            }
        })))
    }
    function Fa(t) {
        return wn(t, (t => ({
            set(e) {
                this.__setAttr(t, e),
                this.__layout.boxChanged || this.__layout.boxChange(),
                this.__updateSize()
            }
        })))
    }
    function Ua() {
        return (t, e) => {
            const i = "_" + e;
            mn(t, e, {
                set(t) {
                    this.isLeafer && (this[i] = t)
                },
                get() {
                    return this.isApp ? this.tree.zoomLayer : this.isLeafer ? this[i] || this : this.leafer && this.leafer.zoomLayer
                }
            })
        }
    }
    Object.assign(i, {
        watcher: (t, e) => new _a(t,e),
        layouter: (t, e) => new Ba(t,e),
        renderer: (t, e, i) => new Pa(t,e,i),
        selector: (t, e) => new Wa(t,e)
    }),
    e.layout = Ba.fullLayout;
    const Ha = {}
      , Na = {}
      , Ya = {
        number: (t, e) => "object" == typeof t ? "percent" === t.type ? t.value * e : t.value : t
    }
      , Xa = {}
      , Va = {}
      , ja = {}
      , Ga = {}
      , Za = {}
      , Ka = {}
      , qa = {
        setStyleName: (t, e, i) => Bt.need("state"),
        set: (t, e) => Bt.need("state")
    }
      , Ja = {
        list: {},
        register(t, e) {
            Ja.list[t] = e
        },
        get: t => Ja.list[t]
    }
      , {parse: $a, objectToCanvasData: Qa} = fi
      , th = {}
      , eh = wt.get("UIData");
    class ih extends At {
        get scale() {
            const {scaleX: t, scaleY: e} = this;
            return t !== e ? {
                x: t,
                y: e
            } : t
        }
        get __strokeWidth() {
            const {strokeWidth: t, strokeWidthFixed: e} = this;
            if (e) {
                const e = this.__leaf;
                let {scaleX: i} = e.__nowWorld || e.__world;
                return i < 0 && (i = -i),
                i > 1 ? t / i : t
            }
            return t
        }
        get __hasStroke() {
            return this.stroke && this.strokeWidth
        }
        get __hasMultiPaint() {
            const t = this;
            return !!(t.__isFills && t.fill.length > 1 || t.__isStrokes && t.stroke.length > 1 || t.__useEffect) || t.fill && this.__hasStroke
        }
        get __clipAfterFill() {
            const t = this;
            return t.cornerRadius || t.innerShadow || t.__pathInputed
        }
        get __autoWidth() {
            return !this._width
        }
        get __autoHeight() {
            return !this._height
        }
        get __autoSide() {
            return !this._width || !this._height
        }
        get __autoSize() {
            return !this._width && !this._height
        }
        setVisible(t) {
            this._visible = t;
            const {leafer: e} = this.__leaf;
            e && (e.watcher.hasVisible = !0)
        }
        setWidth(t) {
            t < 0 ? (this._width = -t,
            this.__leaf.scaleX *= -1,
            eh.warn("width < 0, instead -scaleX ", this)) : this._width = t
        }
        setHeight(t) {
            t < 0 ? (this._height = -t,
            this.__leaf.scaleY *= -1,
            eh.warn("height < 0, instead -scaleY", this)) : this._height = t
        }
        setFill(t) {
            this.__naturalWidth && this.__removeNaturalSize(),
            "string" != typeof t && t ? "object" == typeof t && (this.__setInput("fill", t),
            this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange(),
            this.__isFills = !0,
            this._fill || (this._fill = th)) : (this.__isFills && (this.__removeInput("fill"),
            ja.recycleImage("fill", this),
            this.__isFills = !1,
            this.__pixelFill && (this.__pixelFill = !1)),
            this._fill = t)
        }
        setStroke(t) {
            "string" != typeof t && t ? "object" == typeof t && (this.__setInput("stroke", t),
            this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange(),
            this.__isStrokes = !0,
            this._stroke || (this._stroke = th)) : (this.__isStrokes && (this.__removeInput("stroke"),
            ja.recycleImage("stroke", this),
            this.__isStrokes = !1,
            this.__pixelStroke && (this.__pixelStroke = !1)),
            this._stroke = t)
        }
        setPath(t) {
            const e = "string" == typeof t;
            e || t && "object" == typeof t[0] ? (this.__setInput("path", t),
            this._path = e ? $a(t) : Qa(t)) : (this.__input && this.__removeInput("path"),
            this._path = t)
        }
        setShadow(t) {
            this.__setInput("shadow", t),
            t instanceof Array ? (t.some((t => !1 === t.visible)) && (t = t.filter((t => !1 !== t.visible))),
            this._shadow = t.length ? t : null) : this._shadow = t && !1 !== t.visible ? [t] : null
        }
        setInnerShadow(t) {
            this.__setInput("innerShadow", t),
            t instanceof Array ? (t.some((t => !1 === t.visible)) && (t = t.filter((t => !1 !== t.visible))),
            this._innerShadow = t.length ? t : null) : this._innerShadow = t && !1 !== t.visible ? [t] : null
        }
        __computePaint() {
            const {fill: t, stroke: e} = this.__input;
            t && Va.compute("fill", this.__leaf),
            e && Va.compute("stroke", this.__leaf),
            this.__needComputePaint = !1
        }
    }
    class sh extends ih {
    }
    class nh extends sh {
        get __boxStroke() {
            return !this.__pathInputed
        }
        get __drawAfterFill() {
            const t = this;
            return "hide" === t.overflow && (t.__clipAfterFill || t.innerShadow) && t.__leaf.children.length
        }
        get __clipAfterFill() {
            return this.__leaf.isOverflow || super.__clipAfterFill
        }
    }
    class oh extends sh {
        __getInputData(t, e) {
            const i = super.__getInputData(t, e);
            return Gt.forEach((t => delete i[t])),
            i
        }
    }
    class rh extends nh {
    }
    class ah extends ih {
    }
    class hh extends ih {
        get __boxStroke() {
            return !this.__pathInputed
        }
    }
    class lh extends ih {
        get __boxStroke() {
            return !this.__pathInputed
        }
    }
    class dh extends ih {
    }
    class ch extends ih {
    }
    class uh extends ih {
        get __pathInputed() {
            return 2
        }
    }
    class ph extends sh {
    }
    const _h = {
        thin: 100,
        "extra-light": 200,
        light: 300,
        normal: 400,
        medium: 500,
        "semi-bold": 600,
        bold: 700,
        "extra-bold": 800,
        black: 900
    };
    class gh extends ih {
        get __useNaturalRatio() {
            return !1
        }
        setFontWeight(t) {
            "string" == typeof t ? (this.__setInput("fontWeight", t),
            this._fontWeight = _h[t] || 400) : (this.__input && this.__removeInput("fontWeight"),
            this._fontWeight = t)
        }
    }
    class fh extends hh {
        setUrl(t) {
            this.__setImageFill(t),
            this._url = t
        }
        __setImageFill(t) {
            this.__leaf.image && (this.__leaf.image = null),
            this.fill = t ? {
                type: "image",
                mode: "stretch",
                url: t
            } : void 0
        }
        __getData() {
            const t = super.__getData();
            return delete t.fill,
            t
        }
        __getInputData(t, e) {
            const i = super.__getInputData(t, e);
            return delete i.fill,
            i
        }
    }
    class yh extends hh {
        get __isCanvas() {
            return !0
        }
        get __drawAfterFill() {
            return !0
        }
        __getInputData(t, e) {
            const i = super.__getInputData(t, e);
            return i.url = this.__leaf.canvas.toDataURL("image/png"),
            i
        }
    }
    const mh = {
        __updateStrokeSpread() {
            let t = 0
              , e = 0;
            const i = this.__
              , {strokeAlign: s, strokeWidth: n} = i;
            if ((i.stroke || "all" === i.hitStroke) && n && "inside" !== s && (e = t = "center" === s ? n / 2 : n,
            !i.__boxStroke)) {
                const e = i.__isLinePath ? 0 : 10 * t
                  , s = "none" === i.strokeCap ? 0 : n;
                t += Math.max(e, s)
            }
            return i.__useArrow && (t += 5 * n),
            this.__layout.strokeBoxSpread = e,
            t
        },
        __updateRenderSpread() {
            let t = 0;
            const {shadow: e, innerShadow: i, blur: s, backgroundBlur: n} = this.__;
            e && e.forEach((e => t = Math.max(t, Math.max(Math.abs(e.y), Math.abs(e.x)) + (e.spread > 0 ? e.spread : 0) + 1.5 * e.blur))),
            s && (t = Math.max(t, s));
            let o = t = Math.ceil(t);
            return i && i.forEach((t => o = Math.max(o, Math.max(Math.abs(t.y), Math.abs(t.x)) + (t.spread < 0 ? -t.spread : 0) + 1.5 * t.blur))),
            n && (o = Math.max(o, n)),
            this.__layout.renderShapeSpread = o,
            t + (this.__layout.strokeSpread || 0)
        }
    }
      , vh = {
        __updateChange() {
            const t = this.__;
            if (t.__useEffect) {
                const {shadow: e, innerShadow: i, blur: s, backgroundBlur: n} = this.__;
                t.__useEffect = !!(e || i || s || n)
            }
            t.__checkSingle();
            t.__isFills || t.__isStrokes || t.cornerRadius || t.__useEffect ? t.__complex = !0 : t.__complex && (t.__complex = !1)
        },
        __drawFast(t, e) {
            wh(this, t, e)
        },
        __draw(t, e) {
            const i = this.__;
            if (i.__complex) {
                i.__needComputePaint && i.__computePaint();
                const {fill: s, stroke: n, __drawAfterFill: o} = i;
                if (this.__drawRenderPath(t),
                i.__useEffect) {
                    const r = Va.shape(this, t, e);
                    this.__nowWorld = this.__getNowWorld(e);
                    const {shadow: a, innerShadow: h} = i;
                    a && Za.shadow(this, t, r),
                    s && (i.__isFills ? Va.fills(s, this, t) : Va.fill(s, this, t)),
                    o && this.__drawAfterFill(t, e),
                    h && Za.innerShadow(this, t, r),
                    n && (i.__isStrokes ? Va.strokes(n, this, t) : Va.stroke(n, this, t)),
                    r.worldCanvas && r.worldCanvas.recycle(),
                    r.canvas.recycle()
                } else
                    s && (i.__isFills ? Va.fills(s, this, t) : Va.fill(s, this, t)),
                    o && this.__drawAfterFill(t, e),
                    n && (i.__isStrokes ? Va.strokes(n, this, t) : Va.stroke(n, this, t))
            } else
                i.__pathInputed ? wh(this, t, e) : this.__drawFast(t, e)
        },
        __renderShape(t, e, i, s) {
            if (this.__worldOpacity) {
                t.setWorld(this.__nowWorld = this.__getNowWorld(e));
                const {fill: n, stroke: o} = this.__;
                this.__drawRenderPath(t),
                n && !i && (this.__.__pixelFill ? Va.fills(n, this, t) : Va.fill("#000000", this, t)),
                this.__.__isCanvas && this.__drawAfterFill(t, e),
                o && !s && (this.__.__pixelStroke ? Va.strokes(o, this, t) : Va.stroke("#000000", this, t))
            }
        },
        __drawAfterFill(t, e) {
            this.__.__clipAfterFill ? (t.save(),
            this.windingRule ? t.clip(this.windingRule) : t.clip(),
            this.__drawContent(t, e),
            t.restore()) : this.__drawContent(t, e)
        }
    };
    function wh(t, e, i) {
        const {fill: s, stroke: n, __drawAfterFill: o} = t.__;
        t.__drawRenderPath(e),
        s && Va.fill(s, t, e),
        o && t.__drawAfterFill(e, i),
        n && Va.stroke(n, t, e)
    }
    const xh = {
        __drawFast(t, e) {
            let {width: i, height: s, fill: n, stroke: o, __drawAfterFill: r} = this.__;
            if (n && (t.fillStyle = n,
            t.fillRect(0, 0, i, s)),
            r && this.__drawAfterFill(t, e),
            o) {
                const {strokeAlign: n, __strokeWidth: r} = this.__;
                if (!r)
                    return;
                t.setStroke(o, r, this.__);
                const a = r / 2;
                switch (n) {
                case "center":
                    t.strokeRect(0, 0, i, s);
                    break;
                case "inside":
                    i -= r,
                    s -= r,
                    i < 0 || s < 0 ? (t.save(),
                    this.__clip(t, e),
                    t.strokeRect(a, a, i, s),
                    t.restore()) : t.strokeRect(a, a, i, s);
                    break;
                case "outside":
                    t.strokeRect(-a, -a, i + r, s + r)
                }
            }
        }
    };
    var bh, Eh;
    t.UI = bh = class extends t.Leaf {
        get app() {
            return this.leafer && this.leafer.app
        }
        get isFrame() {
            return !1
        }
        set scale(t) {
            h.assignScale(this, t)
        }
        get scale() {
            return this.__.scale
        }
        get pen() {
            const {path: t} = this.__;
            return on.set(this.path = t || []),
            t || this.__drawPathByBox(on),
            on
        }
        get editConfig() {}
        get editOuter() {
            return ""
        }
        get editInner() {
            return ""
        }
        constructor(t) {
            super(t)
        }
        reset(t) {}
        set(t, e) {
            e ? "temp" === e ? (this.lockNormalStyle = !0,
            Object.assign(this, t),
            this.lockNormalStyle = !1) : this.animate(t, e) : Object.assign(this, t)
        }
        get(t) {
            return "string" == typeof t ? this.__.__getInput(t) : this.__.__getInputData(t)
        }
        createProxyData() {}
        find(t, e) {}
        findTag(t) {
            return this.find({
                tag: t
            })
        }
        findOne(t, e) {}
        findId(t) {
            return this.findOne({
                id: t
            })
        }
        getPath(t, e) {
            this.__layout.update();
            let i = e ? this.__.__pathForRender : this.__.path;
            return i || (on.set(i = []),
            this.__drawPathByBox(on)),
            t ? fi.toCanvasData(i, !0) : i
        }
        getPathString(t, e, i) {
            return fi.stringify(this.getPath(t, e), i)
        }
        load() {
            this.__.__computePaint()
        }
        __onUpdateSize() {
            if (this.__.__input) {
                const t = this.__;
                !t.lazy || this.__inLazyBounds || Ka.running ? t.__computePaint() : t.__needComputePaint = !0
            }
        }
        __updateRenderPath() {
            if (this.__.path) {
                const t = this.__;
                t.__pathForRender = t.cornerRadius ? nn.smooth(t.path, t.cornerRadius, t.cornerSmoothing) : t.path,
                t.__useArrow && Xa.addArrows(this, !t.cornerRadius)
            }
        }
        __drawRenderPath(t) {
            t.beginPath(),
            this.__drawPathByData(t, this.__.__pathForRender)
        }
        __drawPath(t) {
            t.beginPath(),
            this.__drawPathByData(t, this.__.path)
        }
        __drawPathByData(t, e) {
            e ? ys.drawPathByData(t, e) : this.__drawPathByBox(t)
        }
        __drawPathByBox(t) {
            const {x: e, y: i, width: s, height: n} = this.__layout.boxBounds;
            if (this.__.cornerRadius) {
                const {cornerRadius: o} = this.__;
                t.roundRect(e, i, s, n, "number" == typeof o ? [o] : o)
            } else
                t.rect(e, i, s, n)
        }
        animate(t, e, i, s) {
            return Bt.need("animate")
        }
        killAnimate(t) {}
        export(t, e) {
            return Ka.export(this, t, e)
        }
        clone(t) {
            const e = this.toJSON();
            return t && Object.assign(e, t),
            bh.one(e)
        }
        static one(t, e, i, s, n) {
            return Pt.get(t.tag || this.prototype.__tag, t, e, i, s, n)
        }
        static registerUI() {
            io()(this)
        }
        static registerData(t) {
            Gn(t)(this.prototype)
        }
        static setEditConfig(t) {}
        static setEditOuter(t) {}
        static setEditInner(t) {}
        destroy() {
            this.fill = this.stroke = null,
            this.__animate && this.killAnimate(),
            super.destroy()
        }
    }
    ,
    zt([Gn(ih)], t.UI.prototype, "__", void 0),
    zt([Ua()], t.UI.prototype, "zoomLayer", void 0),
    zt([En("")], t.UI.prototype, "id", void 0),
    zt([En("")], t.UI.prototype, "name", void 0),
    zt([En("")], t.UI.prototype, "className", void 0),
    zt([Wn("pass-through")], t.UI.prototype, "blendMode", void 0),
    zt([zn(1)], t.UI.prototype, "opacity", void 0),
    zt([Fn(!0)], t.UI.prototype, "visible", void 0),
    zt([Wn(!1)], t.UI.prototype, "locked", void 0),
    zt([Nn(0)], t.UI.prototype, "zIndex", void 0),
    zt([Yn(!1)], t.UI.prototype, "mask", void 0),
    zt([Xn(!1)], t.UI.prototype, "eraser", void 0),
    zt([kn(0, !0)], t.UI.prototype, "x", void 0),
    zt([kn(0, !0)], t.UI.prototype, "y", void 0),
    zt([Pn(100, !0)], t.UI.prototype, "width", void 0),
    zt([Pn(100, !0)], t.UI.prototype, "height", void 0),
    zt([Bn(1, !0)], t.UI.prototype, "scaleX", void 0),
    zt([Bn(1, !0)], t.UI.prototype, "scaleY", void 0),
    zt([Ln(0, !0)], t.UI.prototype, "rotation", void 0),
    zt([Ln(0, !0)], t.UI.prototype, "skewX", void 0),
    zt([Ln(0, !0)], t.UI.prototype, "skewY", void 0),
    zt([kn(0, !0)], t.UI.prototype, "offsetX", void 0),
    zt([kn(0, !0)], t.UI.prototype, "offsetY", void 0),
    zt([kn(0, !0)], t.UI.prototype, "scrollX", void 0),
    zt([kn(0, !0)], t.UI.prototype, "scrollY", void 0),
    zt([Tn()], t.UI.prototype, "origin", void 0),
    zt([Tn()], t.UI.prototype, "around", void 0),
    zt([En(!1)], t.UI.prototype, "lazy", void 0),
    zt([Cn(1)], t.UI.prototype, "pixelRatio", void 0),
    zt([Sn()], t.UI.prototype, "path", void 0),
    zt([On()], t.UI.prototype, "windingRule", void 0),
    zt([On(!0)], t.UI.prototype, "closed", void 0),
    zt([Pn(0)], t.UI.prototype, "padding", void 0),
    zt([Pn(!1)], t.UI.prototype, "lockRatio", void 0),
    zt([Pn()], t.UI.prototype, "widthRange", void 0),
    zt([Pn()], t.UI.prototype, "heightRange", void 0),
    zt([En(!1)], t.UI.prototype, "draggable", void 0),
    zt([En()], t.UI.prototype, "dragBounds", void 0),
    zt([En(!1)], t.UI.prototype, "editable", void 0),
    zt([Vn(!0)], t.UI.prototype, "hittable", void 0),
    zt([Vn("path")], t.UI.prototype, "hitFill", void 0),
    zt([In("path")], t.UI.prototype, "hitStroke", void 0),
    zt([Vn(!1)], t.UI.prototype, "hitBox", void 0),
    zt([Vn(!0)], t.UI.prototype, "hitChildren", void 0),
    zt([Vn(!0)], t.UI.prototype, "hitSelf", void 0),
    zt([Vn()], t.UI.prototype, "hitRadius", void 0),
    zt([jn("")], t.UI.prototype, "cursor", void 0),
    zt([Wn()], t.UI.prototype, "fill", void 0),
    zt([In()], t.UI.prototype, "stroke", void 0),
    zt([In("inside")], t.UI.prototype, "strokeAlign", void 0),
    zt([In(1)], t.UI.prototype, "strokeWidth", void 0),
    zt([In(!1)], t.UI.prototype, "strokeWidthFixed", void 0),
    zt([In("none")], t.UI.prototype, "strokeCap", void 0),
    zt([In("miter")], t.UI.prototype, "strokeJoin", void 0),
    zt([In()], t.UI.prototype, "dashPattern", void 0),
    zt([In()], t.UI.prototype, "dashOffset", void 0),
    zt([In(10)], t.UI.prototype, "miterLimit", void 0),
    zt([On(0)], t.UI.prototype, "cornerRadius", void 0),
    zt([On()], t.UI.prototype, "cornerSmoothing", void 0),
    zt([za()], t.UI.prototype, "shadow", void 0),
    zt([za()], t.UI.prototype, "innerShadow", void 0),
    zt([za()], t.UI.prototype, "blur", void 0),
    zt([za()], t.UI.prototype, "backgroundBlur", void 0),
    zt([za()], t.UI.prototype, "grayscale", void 0),
    zt([En({})], t.UI.prototype, "data", void 0),
    zt([$n(t.Leaf.prototype.reset)], t.UI.prototype, "reset", null),
    t.UI = bh = zt([eo(mh), eo(vh), Qn()], t.UI),
    t.Group = class extends t.UI {
        get __tag() {
            return "Group"
        }
        get isBranch() {
            return !0
        }
        constructor(t) {
            super(t)
        }
        reset(t) {
            this.__setBranch(),
            super.reset(t)
        }
        __setBranch() {
            this.children || (this.children = [])
        }
        set(t, e) {
            if (t.children) {
                const {children: i} = t;
                delete t.children,
                this.children ? this.clear() : this.__setBranch(),
                super.set(t, e),
                i.forEach((t => this.add(t))),
                t.children = i
            } else
                super.set(t, e)
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.children = this.children.map((e => e.toJSON(t))),
            e
        }
        pick(t, e) {}
        addAt(t, e) {
            this.add(t, e)
        }
        addAfter(t, e) {
            this.add(t, this.children.indexOf(e) + 1)
        }
        addBefore(t, e) {
            this.add(t, this.children.indexOf(e))
        }
        add(t, e) {}
        addMany(...t) {}
        remove(t, e) {}
        removeAll(t) {}
        clear() {}
    }
    ,
    zt([Gn(sh)], t.Group.prototype, "__", void 0),
    t.Group = zt([eo(t.Branch), io()], t.Group);
    const kh = wt.get("Leafer");
    t.Leafer = Eh = class extends t.Group {
        get __tag() {
            return "Leafer"
        }
        get isApp() {
            return !1
        }
        get app() {
            return this.parent || this
        }
        get isLeafer() {
            return !0
        }
        get imageReady() {
            return this.viewReady && pn.isComplete
        }
        get layoutLocked() {
            return !this.layouter.running
        }
        get FPS() {
            return this.renderer ? this.renderer.FPS : 60
        }
        get cursorPoint() {
            return this.interaction && this.interaction.hoverData || {
                x: this.width / 2,
                y: this.height / 2
            }
        }
        get clientBounds() {
            return this.canvas && this.canvas.getClientBounds()
        }
        constructor(t, e) {
            super(e),
            this.config = {
                start: !0,
                hittable: !0,
                smooth: !0,
                lazySpeard: 100
            },
            this.leafs = 0,
            this.__eventIds = [],
            this.__controllers = [],
            this.__readyWait = [],
            this.__viewReadyWait = [],
            this.__viewCompletedWait = [],
            this.__nextRenderWait = [],
            this.userConfig = t,
            t && (t.view || t.width) && this.init(t),
            Eh.list.add(this)
        }
        init(t, e) {
            if (this.canvas)
                return;
            let s;
            const {config: n} = this;
            this.__setLeafer(this),
            e && (this.parentApp = e,
            this.__bindApp(e),
            s = e.running),
            t && (this.parent = e,
            this.initType(t.type),
            this.parent = void 0,
            Mt.assign(n, t));
            const o = this.canvas = i.canvas(n);
            this.__controllers.push(this.renderer = i.renderer(this, o, n), this.watcher = i.watcher(this, n), this.layouter = i.layouter(this, n)),
            this.isApp && this.__setApp(),
            this.__checkAutoLayout(n, e),
            this.view = o.view,
            e || (this.selector = i.selector(this),
            this.interaction = i.interaction(this, o, this.selector, n),
            this.interaction && (this.__controllers.unshift(this.interaction),
            this.hitCanvasManager = i.hitCanvasManager()),
            this.canvasManager = new Dt,
            s = n.start),
            this.hittable = n.hittable,
            this.fill = n.fill,
            this.canvasManager.add(o),
            this.__listenEvents(),
            s && (this.__startTimer = setTimeout(this.start.bind(this))),
            Co.run(this.__initWait),
            this.onInit()
        }
        onInit() {}
        initType(t) {}
        set(t, e) {
            this.waitInit(( () => {
                super.set(t, e)
            }
            ))
        }
        start() {
            clearTimeout(this.__startTimer),
            !this.running && this.canvas && (this.running = !0,
            this.ready ? this.emitLeafer(Go.RESTART) : this.emitLeafer(Go.START),
            this.__controllers.forEach((t => t.start())),
            this.isApp || this.renderer.render())
        }
        stop() {
            clearTimeout(this.__startTimer),
            this.running && this.canvas && (this.__controllers.forEach((t => t.stop())),
            this.running = !1,
            this.emitLeafer(Go.STOP))
        }
        unlockLayout() {
            this.layouter.start(),
            this.updateLayout()
        }
        lockLayout() {
            this.updateLayout(),
            this.layouter.stop()
        }
        resize(t) {
            const e = Mt.copyAttrs({}, t, Gt);
            Object.keys(e).forEach((t => this[t] = e[t]))
        }
        forceRender(t, e) {
            const {renderer: i} = this;
            i && (i.addBlock(t ? new lt(t) : this.canvas.bounds),
            this.viewReady && (e ? i.render() : i.update()))
        }
        requestRender(t=!1) {
            this.renderer && this.renderer.update(t)
        }
        updateCursor(t) {
            const e = this.interaction;
            e && (t ? e.setCursor(t) : e.updateCursor())
        }
        updateLazyBounds() {
            this.lazyBounds = this.canvas.bounds.clone().spread(this.config.lazySpeard)
        }
        __doResize(t) {
            const {canvas: e} = this;
            if (!e || e.isSameSize(t))
                return;
            const i = Mt.copyAttrs({}, this.canvas, Gt);
            e.resize(t),
            this.updateLazyBounds(),
            this.__onResize(new Yo(t,i))
        }
        __onResize(t) {
            this.emitEvent(t),
            Mt.copyAttrs(this.__, t, Gt),
            setTimeout(( () => {
                this.canvasManager && this.canvasManager.clearRecycled()
            }
            ), 0)
        }
        __setApp() {}
        __bindApp(t) {
            this.selector = t.selector,
            this.interaction = t.interaction,
            this.canvasManager = t.canvasManager,
            this.hitCanvasManager = t.hitCanvasManager
        }
        __setLeafer(t) {
            this.leafer = t,
            this.__level = 1
        }
        __checkAutoLayout(t, e) {
            e || (t.width && t.height || (this.autoLayout = new ct(t)),
            this.canvas.startAutoLayout(this.autoLayout, this.__onResize.bind(this)))
        }
        __setAttr(t, e) {
            return this.canvas && (Gt.includes(t) ? (e || kh.warn(t + " is 0"),
            this.__changeCanvasSize(t, e)) : "fill" === t ? this.__changeFill(e) : "hittable" === t ? this.parent || (this.canvas.hittable = e) : "zIndex" === t && (this.canvas.zIndex = e,
            setTimeout(( () => this.parent && this.parent.__updateSortChildren())))),
            super.__setAttr(t, e)
        }
        __getAttr(t) {
            return this.canvas && Gt.includes(t) ? this.canvas[t] : super.__getAttr(t)
        }
        __changeCanvasSize(t, e) {
            const i = Mt.copyAttrs({}, this.canvas, Gt);
            i[t] = this.config[t] = e,
            e && this.canvas.stopAutoLayout(),
            this.__doResize(i)
        }
        __changeFill(t) {
            this.config.fill = t,
            this.canvas.allowBackgroundColor ? this.canvas.backgroundColor = t : this.forceRender()
        }
        __onCreated() {
            this.created = !0
        }
        __onReady() {
            this.ready || (this.ready = !0,
            this.emitLeafer(Go.BEFORE_READY),
            this.emitLeafer(Go.READY),
            this.emitLeafer(Go.AFTER_READY),
            Co.run(this.__readyWait))
        }
        __onViewReady() {
            this.viewReady || (this.viewReady = !0,
            this.emitLeafer(Go.VIEW_READY),
            Co.run(this.__viewReadyWait))
        }
        __onNextRender() {
            if (this.viewReady) {
                Co.run(this.__nextRenderWait);
                const {imageReady: t} = this;
                t && !this.viewCompleted && this.__checkViewCompleted(),
                t || (this.viewCompleted = !1,
                this.requestRender())
            }
        }
        __checkViewCompleted(t=!0) {
            this.nextRender(( () => {
                this.imageReady && (t && this.emitLeafer(Go.VIEW_COMPLETED),
                Co.run(this.__viewCompletedWait),
                this.viewCompleted = !0)
            }
            ))
        }
        __onWatchData() {
            this.watcher.childrenChanged && this.interaction && this.nextRender(( () => this.interaction.updateCursor()))
        }
        waitInit(t, e) {
            e && (t = t.bind(e)),
            this.__initWait || (this.__initWait = []),
            this.canvas ? t() : this.__initWait.push(t)
        }
        waitReady(t, e) {
            e && (t = t.bind(e)),
            this.ready ? t() : this.__readyWait.push(t)
        }
        waitViewReady(t, e) {
            e && (t = t.bind(e)),
            this.viewReady ? t() : this.__viewReadyWait.push(t)
        }
        waitViewCompleted(t, e) {
            e && (t = t.bind(e)),
            this.__viewCompletedWait.push(t),
            this.viewCompleted ? this.__checkViewCompleted(!1) : this.running || this.start()
        }
        nextRender(t, e, i) {
            e && (t = t.bind(e));
            const s = this.__nextRenderWait;
            if (i) {
                for (let e = 0; e < s.length; e++)
                    if (s[e] === t) {
                        s.splice(e, 1);
                        break
                    }
            } else
                s.push(t);
            this.requestRender()
        }
        zoom(t, e, i) {
            return Bt.need("view")
        }
        getValidMove(t, e) {
            return {
                x: t,
                y: e
            }
        }
        getValidScale(t) {
            return t
        }
        getWorldPointByClient(t, e) {
            return this.interaction && this.interaction.getLocal(t, e)
        }
        getPagePointByClient(t, e) {
            return this.getPagePoint(this.getWorldPointByClient(t, e))
        }
        updateClientBounds() {
            this.canvas && this.canvas.updateClientBounds()
        }
        receiveEvent(t) {}
        __checkUpdateLayout() {
            this.__layout.update()
        }
        emitLeafer(t) {
            this.emitEvent(new Go(t,this))
        }
        __listenEvents() {
            const t = kt.start("FirstCreate " + this.innerName);
            this.once(Go.START, ( () => kt.end(t))),
            this.once(Vo.START, ( () => this.updateLazyBounds())),
            this.once(Vo.END, ( () => this.__onReady())),
            this.once(jo.START, ( () => this.__onCreated())),
            this.once(jo.END, ( () => this.__onViewReady())),
            this.__eventIds.push(this.on_(Xo.DATA, this.__onWatchData, this), this.on_(jo.NEXT, this.__onNextRender, this), this.on_(Vo.CHECK_UPDATE, this.__checkUpdateLayout, this))
        }
        __removeListenEvents() {
            this.off_(this.__eventIds),
            this.__eventIds.length = 0
        }
        destroy(t) {
            const e = () => {
                if (!this.destroyed) {
                    Eh.list.remove(this);
                    try {
                        this.stop(),
                        this.emitEvent(new Go(Go.END,this)),
                        this.__removeListenEvents(),
                        this.__controllers.forEach((t => !(this.parent && t === this.interaction) && t.destroy())),
                        this.__controllers.length = 0,
                        this.parent || (this.selector && this.selector.destroy(),
                        this.hitCanvasManager && this.hitCanvasManager.destroy(),
                        this.canvasManager.destroy()),
                        this.canvas.destroy(),
                        this.config.view = this.view = this.parentApp = null,
                        this.userConfig && (this.userConfig.view = null),
                        super.destroy(),
                        setTimeout(( () => {
                            pn.clearRecycled()
                        }
                        ), 100)
                    } catch (t) {
                        kh.error(t)
                    }
                }
            }
            ;
            t ? e() : setTimeout(e)
        }
    }
    ,
    t.Leafer.list = new ra,
    zt([Gn(oh)], t.Leafer.prototype, "__", void 0),
    zt([Pn()], t.Leafer.prototype, "pixelRatio", void 0),
    t.Leafer = Eh = zt([io()], t.Leafer),
    t.Rect = class extends t.UI {
        get __tag() {
            return "Rect"
        }
        constructor(t) {
            super(t)
        }
    }
    ,
    zt([Gn(hh)], t.Rect.prototype, "__", void 0),
    t.Rect = zt([eo(xh), Qn(), io()], t.Rect);
    const {copy: Th, add: Bh, includes: Lh} = ot
      , Ph = t.Rect.prototype
      , Ch = t.Group.prototype
      , Rh = {};
    t.Box = class extends t.Group {
        get __tag() {
            return "Box"
        }
        get isBranchLeaf() {
            return !0
        }
        constructor(t) {
            super(t),
            this.__layout.renderChanged || this.__layout.renderChange()
        }
        __updateStrokeSpread() {
            return 0
        }
        __updateRectRenderSpread() {
            return 0
        }
        __updateRenderSpread() {
            return this.__updateRectRenderSpread() || -1
        }
        __updateRectBoxBounds() {}
        __updateBoxBounds(t) {
            const e = this.__;
            if (this.children.length)
                if (e.__autoSide) {
                    super.__updateBoxBounds();
                    const {boxBounds: t} = this.__layout;
                    e.__autoSize || (e.__autoWidth ? (t.width += t.x,
                    t.x = 0,
                    t.height = e.height,
                    t.y = 0) : (t.height += t.y,
                    t.y = 0,
                    t.width = e.width,
                    t.x = 0)),
                    this.__updateNaturalSize()
                } else
                    this.__updateRectBoxBounds();
            else
                this.__updateRectBoxBounds()
        }
        __updateStrokeBounds() {}
        __updateRenderBounds() {
            let t;
            const {renderBounds: e} = this.__layout;
            this.children.length ? (super.__updateRenderBounds(),
            Th(Rh, e),
            this.__updateRectRenderBounds(),
            t = !Lh(e, Rh),
            t && "hide" !== this.__.overflow && Bh(e, Rh)) : this.__updateRectRenderBounds(),
            !this.isOverflow != !t && (this.isOverflow = t)
        }
        __updateRectRenderBounds() {}
        __updateRectChange() {}
        __updateChange() {
            super.__updateChange(),
            this.__updateRectChange()
        }
        __renderRect(t, e) {}
        __renderGroup(t, e) {}
        __render(t, e) {
            this.__.__drawAfterFill ? this.__renderRect(t, e) : (this.__renderRect(t, e),
            this.children.length && this.__renderGroup(t, e))
        }
        __drawContent(t, e) {
            this.__renderGroup(t, e),
            this.__.__hasStroke && (t.setWorld(this.__nowWorld),
            this.__drawRenderPath(t))
        }
    }
    ,
    zt([Gn(nh)], t.Box.prototype, "__", void 0),
    zt([En(!1)], t.Box.prototype, "resizeChildren", void 0),
    zt([An("show")], t.Box.prototype, "overflow", void 0),
    zt([$n(Ph.__updateStrokeSpread)], t.Box.prototype, "__updateStrokeSpread", null),
    zt([$n(Ph.__updateRenderSpread)], t.Box.prototype, "__updateRectRenderSpread", null),
    zt([$n(Ph.__updateBoxBounds)], t.Box.prototype, "__updateRectBoxBounds", null),
    zt([$n(Ph.__updateStrokeBounds)], t.Box.prototype, "__updateStrokeBounds", null),
    zt([$n(Ph.__updateRenderBounds)], t.Box.prototype, "__updateRectRenderBounds", null),
    zt([$n(Ph.__updateChange)], t.Box.prototype, "__updateRectChange", null),
    zt([$n(Ph.__render)], t.Box.prototype, "__renderRect", null),
    zt([$n(Ch.__render)], t.Box.prototype, "__renderGroup", null),
    t.Box = zt([Qn(), io()], t.Box),
    t.Frame = class extends t.Box {
        get __tag() {
            return "Frame"
        }
        get isFrame() {
            return !0
        }
        constructor(t) {
            super(t)
        }
    }
    ,
    zt([Gn(rh)], t.Frame.prototype, "__", void 0),
    zt([Wn("#FFFFFF")], t.Frame.prototype, "fill", void 0),
    zt([An("hide")], t.Frame.prototype, "overflow", void 0),
    t.Frame = zt([io()], t.Frame);
    const {moveTo: Sh, closePath: Oh, ellipse: Dh} = Fi;
    t.Ellipse = class extends t.UI {
        get __tag() {
            return "Ellipse"
        }
        constructor(t) {
            super(t)
        }
        __updatePath() {
            const {width: t, height: i, innerRadius: s, startAngle: n, endAngle: o} = this.__
              , r = t / 2
              , a = i / 2
              , h = this.__.path = [];
            s ? (n || o ? (s < 1 && Dh(h, r, a, r * s, a * s, 0, n, o, !1),
            Dh(h, r, a, r, a, 0, o, n, !0),
            s < 1 && Oh(h)) : (s < 1 && (Dh(h, r, a, r * s, a * s),
            Sh(h, t, a)),
            Dh(h, r, a, r, a, 0, 360, 0, !0)),
            e.ellipseToCurve && (this.__.path = this.getPath(!0))) : n || o ? (Sh(h, r, a),
            Dh(h, r, a, r, a, 0, n, o, !1),
            Oh(h)) : Dh(h, r, a, r, a)
        }
    }
    ,
    zt([Gn(lh)], t.Ellipse.prototype, "__", void 0),
    zt([On(0)], t.Ellipse.prototype, "innerRadius", void 0),
    zt([On(0)], t.Ellipse.prototype, "startAngle", void 0),
    zt([On(0)], t.Ellipse.prototype, "endAngle", void 0),
    t.Ellipse = zt([io()], t.Ellipse);
    const {moveTo: Mh, lineTo: Ih, drawPoints: Ah} = Fi
      , {rotate: Wh, getAngle: zh, getDistance: Fh, defaultPoint: Uh} = D
      , {toBounds: Hh} = Ks;
    t.Line = class extends t.UI {
        get __tag() {
            return "Line"
        }
        get toPoint() {
            const {width: t, rotation: e} = this.__
              , i = {
                x: 0,
                y: 0
            };
            return t && (i.x = t),
            e && Wh(i, e),
            i
        }
        set toPoint(t) {
            this.width = Fh(Uh, t),
            this.rotation = zh(Uh, t),
            this.height && (this.height = 0)
        }
        constructor(t) {
            super(t)
        }
        __updatePath() {
            const t = this.__
              , e = t.path = [];
            t.points ? Ah(e, t.points, !1, t.closed) : (Mh(e, 0, 0),
            Ih(e, this.width, 0))
        }
        __updateRenderPath() {
            const t = this.__;
            !this.pathInputed && t.points && t.curve ? (Ah(t.__pathForRender = [], t.points, t.curve, t.closed),
            t.__useArrow && Xa.addArrows(this, !1)) : super.__updateRenderPath()
        }
        __updateBoxBounds() {
            this.points ? Hh(this.__.__pathForRender, this.__layout.boxBounds) : super.__updateBoxBounds()
        }
    }
    ,
    zt([Gn(ah)], t.Line.prototype, "__", void 0),
    zt([Dn("center")], t.Line.prototype, "strokeAlign", void 0),
    zt([Pn(0)], t.Line.prototype, "height", void 0),
    zt([On()], t.Line.prototype, "points", void 0),
    zt([On(0)], t.Line.prototype, "curve", void 0),
    zt([On(!1)], t.Line.prototype, "closed", void 0),
    t.Line = zt([io()], t.Line);
    const {sin: Nh, cos: Yh, PI: Xh} = Math
      , {moveTo: Vh, lineTo: jh, closePath: Gh, drawPoints: Zh} = Fi
      , Kh = t.Line.prototype;
    t.Polygon = class extends t.UI {
        get __tag() {
            return "Polygon"
        }
        constructor(t) {
            super(t)
        }
        __updatePath() {
            const t = this.__.path = [];
            if (this.__.points)
                Zh(t, this.__.points, !1, !0);
            else {
                const {width: e, height: i, sides: s} = this.__
                  , n = e / 2
                  , o = i / 2;
                Vh(t, n, 0);
                for (let e = 1; e < s; e++)
                    jh(t, n + n * Nh(2 * e * Xh / s), o - o * Yh(2 * e * Xh / s))
            }
            Gh(t)
        }
        __updateRenderPath() {}
        __updateBoxBounds() {}
    }
    ,
    zt([Gn(dh)], t.Polygon.prototype, "__", void 0),
    zt([On(3)], t.Polygon.prototype, "sides", void 0),
    zt([On()], t.Polygon.prototype, "points", void 0),
    zt([On(0)], t.Polygon.prototype, "curve", void 0),
    zt([$n(Kh.__updateRenderPath)], t.Polygon.prototype, "__updateRenderPath", null),
    zt([$n(Kh.__updateBoxBounds)], t.Polygon.prototype, "__updateBoxBounds", null),
    t.Polygon = zt([Qn(), io()], t.Polygon);
    const {sin: qh, cos: Jh, PI: $h} = Math
      , {moveTo: Qh, lineTo: tl, closePath: el} = Fi;
    t.Star = class extends t.UI {
        get __tag() {
            return "Star"
        }
        constructor(t) {
            super(t)
        }
        __updatePath() {
            const {width: t, height: e, corners: i, innerRadius: s} = this.__
              , n = t / 2
              , o = e / 2
              , r = this.__.path = [];
            Qh(r, n, 0);
            for (let t = 1; t < 2 * i; t++)
                tl(r, n + (t % 2 == 0 ? n : n * s) * qh(t * $h / i), o - (t % 2 == 0 ? o : o * s) * Jh(t * $h / i));
            el(r)
        }
    }
    ,
    zt([Gn(ch)], t.Star.prototype, "__", void 0),
    zt([On(5)], t.Star.prototype, "corners", void 0),
    zt([On(.382)], t.Star.prototype, "innerRadius", void 0),
    t.Star = zt([io()], t.Star),
    t.Image = class extends t.Rect {
        get __tag() {
            return "Image"
        }
        get ready() {
            return !!this.image && this.image.ready
        }
        constructor(t) {
            super(t),
            this.on(No.LOADED, (t => {
                "fill" === t.attrName && t.attrValue.url === this.url && (this.image = t.image)
            }
            ))
        }
        destroy() {
            this.image = null,
            super.destroy()
        }
    }
    ,
    zt([Gn(fh)], t.Image.prototype, "__", void 0),
    zt([Pn("")], t.Image.prototype, "url", void 0),
    t.Image = zt([io()], t.Image);
    const il = t.Image;
    t.Canvas = class extends t.Rect {
        get __tag() {
            return "Canvas"
        }
        get ready() {
            return !this.url
        }
        constructor(t) {
            super(t),
            this.canvas = i.canvas(this.__),
            this.context = this.canvas.context,
            t && t.url && this.drawImage(t.url)
        }
        drawImage(t) {
            new yn({
                url: t
            }).load((t => {
                this.context.drawImage(t.view, 0, 0),
                this.url = void 0,
                this.paint(),
                this.emitEvent(new No(No.LOADED,{
                    image: t
                }))
            }
            ))
        }
        draw(t, e, i, s) {
            const n = new U(t.worldTransform).invert()
              , o = new U;
            e && o.translate(e.x, e.y),
            i && ("number" == typeof i ? o.scale(i) : o.scale(i.x, i.y)),
            s && o.rotate(s),
            n.multiplyParent(o),
            t.__render(this.canvas, {
                matrix: n.withScale()
            }),
            this.paint()
        }
        paint() {
            this.forceRender()
        }
        __drawContent(t, e) {
            const {width: i, height: s} = this.__
              , {view: n} = this.canvas;
            t.drawImage(n, 0, 0, n.width, n.height, 0, 0, i, s)
        }
        __updateSize() {
            const {canvas: t} = this;
            if (t) {
                const {smooth: e} = this.__;
                t.smooth !== e && (t.smooth = e),
                t.resize(this.__)
            }
        }
        destroy() {
            this.canvas && (this.canvas.destroy(),
            this.canvas = this.context = null),
            super.destroy()
        }
    }
    ,
    zt([Gn(yh)], t.Canvas.prototype, "__", void 0),
    zt([Fa(100)], t.Canvas.prototype, "width", void 0),
    zt([Fa(100)], t.Canvas.prototype, "height", void 0),
    zt([Fa(1)], t.Canvas.prototype, "pixelRatio", void 0),
    zt([Fa(!0)], t.Canvas.prototype, "smooth", void 0),
    zt([Fa()], t.Canvas.prototype, "contextSettings", void 0),
    t.Canvas = zt([io()], t.Canvas);
    const {copyAndSpread: sl, includes: nl, isSame: ol, spread: rl, setList: al} = ot;
    t.Text = class extends t.UI {
        get __tag() {
            return "Text"
        }
        get textDrawData() {
            return this.__layout.update(),
            this.__.__textDrawData
        }
        constructor(t) {
            super(t)
        }
        __drawHitPath(t) {
            const {__lineHeight: e, fontSize: i, __baseLine: s, __textDrawData: n} = this.__;
            t.beginPath(),
            this.__.__letterSpacing < 0 ? this.__drawPathByData(t) : n.rows.forEach((n => t.rect(n.x, n.y - s, n.width, e < i ? i : e)))
        }
        __drawPathByData(t, e) {
            const {x: i, y: s, width: n, height: o} = this.__layout.boxBounds;
            t.rect(i, s, n, o)
        }
        __drawRenderPath(t) {
            t.font = this.__.__font
        }
        __updateTextDrawData() {
            const t = this.__
              , {lineHeight: e, letterSpacing: i, fontFamily: s, fontSize: n, fontWeight: o, italic: r, textCase: a, textOverflow: l, padding: d} = t;
            t.__lineHeight = Ya.number(e, n),
            t.__letterSpacing = Ya.number(i, n),
            t.__padding = d ? h.fourNumber(d) : void 0,
            t.__baseLine = t.__lineHeight - (t.__lineHeight - .7 * n) / 2,
            t.__font = `${r ? "italic " : ""}${"small-caps" === a ? "small-caps " : ""}${"normal" !== o ? o + " " : ""}${n}px ${s}`,
            t.__clipText = "show" !== l && !t.__autoSize,
            t.__textDrawData = Ha.getDrawData(t.text, this.__)
        }
        __updateBoxBounds() {
            const t = this.__
              , e = this.__layout
              , {fontSize: i, italic: s, padding: n, __autoWidth: o, __autoHeight: r} = t;
            this.__updateTextDrawData();
            const {bounds: a} = t.__textDrawData
              , h = e.boxBounds;
            if (t.__lineHeight < i && rl(a, i / 2),
            o || r) {
                if (h.x = o ? a.x : 0,
                h.y = r ? a.y : 0,
                h.width = o ? a.width : t.width,
                h.height = r ? a.height : t.height,
                n) {
                    const [e,i,s,n] = t.__padding;
                    o && (h.x -= n,
                    h.width += i + n),
                    r && (h.y -= e,
                    h.height += s + e)
                }
                this.__updateNaturalSize()
            } else
                super.__updateBoxBounds();
            s && (h.width += .16 * i);
            const l = nl(h, a) ? h : a;
            ol(l, e.contentBounds) ? t.__textBoxBounds = l : (e.contentBounds = l,
            e.renderChanged = !0,
            al(t.__textBoxBounds = {}, [h, a]))
        }
        __updateRenderSpread() {
            let t = super.__updateRenderSpread();
            return t || (t = this.__layout.boxBounds === this.__layout.contentBounds ? 0 : 1),
            t
        }
        __updateRenderBounds() {
            sl(this.__layout.renderBounds, this.__.__textBoxBounds, this.__layout.renderSpread)
        }
    }
    ,
    zt([Gn(gh)], t.Text.prototype, "__", void 0),
    zt([Pn(0)], t.Text.prototype, "width", void 0),
    zt([Pn(0)], t.Text.prototype, "height", void 0),
    zt([En(!1)], t.Text.prototype, "resizeFontSize", void 0),
    zt([Wn("#000000")], t.Text.prototype, "fill", void 0),
    zt([Dn("outside")], t.Text.prototype, "strokeAlign", void 0),
    zt([Vn("all")], t.Text.prototype, "hitFill", void 0),
    zt([Pn("")], t.Text.prototype, "text", void 0),
    zt([Pn("L")], t.Text.prototype, "fontFamily", void 0),
    zt([Pn(12)], t.Text.prototype, "fontSize", void 0),
    zt([Pn("normal")], t.Text.prototype, "fontWeight", void 0),
    zt([Pn(!1)], t.Text.prototype, "italic", void 0),
    zt([Pn("none")], t.Text.prototype, "textCase", void 0),
    zt([Pn("none")], t.Text.prototype, "textDecoration", void 0),
    zt([Pn(0)], t.Text.prototype, "letterSpacing", void 0),
    zt([Pn({
        type: "percent",
        value: 1.5
    })], t.Text.prototype, "lineHeight", void 0),
    zt([Pn(0)], t.Text.prototype, "paraIndent", void 0),
    zt([Pn(0)], t.Text.prototype, "paraSpacing", void 0),
    zt([Pn("left")], t.Text.prototype, "textAlign", void 0),
    zt([Pn("top")], t.Text.prototype, "verticalAlign", void 0),
    zt([Pn(!0)], t.Text.prototype, "autoSizeAlign", void 0),
    zt([Pn("normal")], t.Text.prototype, "textWrap", void 0),
    zt([Pn("show")], t.Text.prototype, "textOverflow", void 0),
    t.Text = zt([io()], t.Text),
    t.Path = class extends t.UI {
        get __tag() {
            return "Path"
        }
        constructor(t) {
            super(t)
        }
    }
    ,
    zt([Gn(uh)], t.Path.prototype, "__", void 0),
    zt([Dn("center")], t.Path.prototype, "strokeAlign", void 0),
    t.Path = zt([io()], t.Path),
    t.Pen = class extends t.Group {
        get __tag() {
            return "Pen"
        }
        constructor(t) {
            super(t)
        }
        setStyle(e) {
            const i = this.pathElement = new t.Path(e);
            return this.pathStyle = e,
            this.__path = i.path || (i.path = []),
            this.add(i),
            this
        }
        beginPath() {
            return this
        }
        moveTo(t, e) {
            return this
        }
        lineTo(t, e) {
            return this
        }
        bezierCurveTo(t, e, i, s, n, o) {
            return this
        }
        quadraticCurveTo(t, e, i, s) {
            return this
        }
        closePath() {
            return this
        }
        rect(t, e, i, s) {
            return this
        }
        roundRect(t, e, i, s, n) {
            return this
        }
        ellipse(t, e, i, s, n, o, r, a) {
            return this
        }
        arc(t, e, i, s, n, o) {
            return this
        }
        arcTo(t, e, i, s, n) {
            return this
        }
        drawEllipse(t, e, i, s, n, o, r, a) {
            return this
        }
        drawArc(t, e, i, s, n, o) {
            return this
        }
        drawPoints(t, e, i) {
            return this
        }
        clearPath() {
            return this
        }
        paint() {
            this.pathElement.__layout.boxChanged || this.pathElement.forceUpdate("path")
        }
    }
    ,
    zt([Gn(ph)], t.Pen.prototype, "__", void 0),
    zt([ (t, e) => {
        mn(t, e, {
            get() {
                return this.__path
            }
        })
    }
    ], t.Pen.prototype, "path", void 0),
    t.Pen = zt([eo(is, ["set", "path", "paint"]), io()], t.Pen),
    t.App = class extends t.Leafer {
        get __tag() {
            return "App"
        }
        get isApp() {
            return !0
        }
        constructor(t, e) {
            super(t, e)
        }
        init(t, e) {
            if (super.init(t, e),
            t) {
                const {ground: e, tree: s, sky: n, editor: o} = t;
                e && (this.ground = this.addLeafer(e)),
                (s || o) && (this.tree = this.addLeafer(s || {
                    type: t.type || "design"
                })),
                (n || o) && (this.sky = this.addLeafer(n)),
                o && this.sky.add(this.editor = i.editor(o))
            }
        }
        __setApp() {
            const {canvas: t} = this
              , {realCanvas: e, view: i} = this.config;
            e || i === this.canvas.view || !t.parentView ? this.realCanvas = !0 : t.unrealCanvas(),
            this.leafer = this,
            this.watcher.disable(),
            this.layouter.disable(),
            this.__eventIds.push(this.on_(Ho.CHANGE, this.__onPropertyChange, this))
        }
        start() {
            super.start(),
            this.children.forEach((t => t.start()))
        }
        stop() {
            this.children.forEach((t => t.stop())),
            super.stop()
        }
        unlockLayout() {
            super.unlockLayout(),
            this.children.forEach((t => t.unlockLayout()))
        }
        lockLayout() {
            super.lockLayout(),
            this.children.forEach((t => t.lockLayout()))
        }
        forceRender(t, e) {
            this.children.forEach((i => i.forceRender(t, e)))
        }
        addLeafer(e) {
            const i = new t.Leafer(e);
            return this.add(i),
            i
        }
        add(t, e) {
            if (!t.view) {
                if (this.realCanvas && !this.canvas.bounds)
                    return void setTimeout(( () => this.add(t, e)), 10);
                t.init(this.__getChildConfig(t.userConfig), this)
            }
            super.add(t, e),
            void 0 !== e && (t.canvas.childIndex = e),
            this.__listenChildEvents(t)
        }
        __onPropertyChange() {
            wt.showHitView && this.children.forEach((t => t.forceUpdate("surface")))
        }
        __onCreated() {
            this.created = this.children.every((t => t.created))
        }
        __onReady() {
            this.children.every((t => t.ready)) && super.__onReady()
        }
        __onViewReady() {
            this.children.every((t => t.viewReady)) && super.__onViewReady()
        }
        __onChildRenderEnd(t) {
            this.renderer.addBlock(t.renderBounds),
            this.viewReady && this.renderer.update()
        }
        __render(t, e) {
            if (t.context) {
                const i = e.matrix;
                i && t.setTransform(i.a, i.b, i.c, i.d, i.e, i.f),
                this.children.forEach((e => t.copyWorld(e.canvas)))
            }
        }
        __onResize(t) {
            this.children.forEach((e => e.resize(t))),
            super.__onResize(t)
        }
        __checkUpdateLayout() {
            this.children.forEach((t => t.__layout.update()))
        }
        __getChildConfig(t) {
            let e = Object.assign({}, this.config);
            return e.hittable = e.realCanvas = void 0,
            t && Mt.assign(e, t),
            this.autoLayout && Mt.copyAttrs(e, this, Gt),
            e.view = this.realCanvas ? void 0 : this.view,
            e.fill = void 0,
            e
        }
        __listenChildEvents(t) {
            t.once(Vo.END, ( () => this.__onReady())),
            t.once(jo.START, ( () => this.__onCreated())),
            t.once(jo.END, ( () => this.__onViewReady())),
            this.realCanvas && this.__eventIds.push(t.on_(jo.END, this.__onChildRenderEnd, this))
        }
    }
    ,
    t.App = zt([io()], t.App);
    const hl = {}
      , ll = {
        isHoldSpaceKey: () => ll.isHold("Space"),
        isHold: t => hl[t],
        setDownCode(t) {
            hl[t] || (hl[t] = !0)
        },
        setUpCode(t) {
            hl[t] = !1
        }
    }
      , dl = {
        LEFT: 1,
        RIGHT: 2,
        MIDDLE: 4,
        defaultLeft(t) {
            t.buttons || (t.buttons = 1)
        },
        left: t => 1 === t.buttons,
        right: t => 2 === t.buttons,
        middle: t => 4 === t.buttons
    };
    class cl extends Fo {
        get spaceKey() {
            return ll.isHoldSpaceKey()
        }
        get left() {
            return dl.left(this)
        }
        get right() {
            return dl.right(this)
        }
        get middle() {
            return dl.middle(this)
        }
        constructor(t) {
            super(t.type),
            this.bubbles = !0,
            Object.assign(this, t)
        }
        getBoxPoint(t) {
            return (t || this.current).getBoxPoint(this)
        }
        getInnerPoint(t) {
            return (t || this.current).getInnerPoint(this)
        }
        getLocalPoint(t) {
            return (t || this.current).getLocalPoint(this)
        }
        getPagePoint() {
            return this.current.getPagePoint(this)
        }
        getInner(t) {
            return this.getInnerPoint(t)
        }
        getLocal(t) {
            return this.getLocalPoint(t)
        }
        getPage() {
            return this.getPagePoint()
        }
        static changeName(t, e) {
            St.changeName(t, e)
        }
    }
    t.PointerEvent = class extends cl {
    }
    ,
    t.PointerEvent.POINTER = "pointer",
    t.PointerEvent.BEFORE_DOWN = "pointer.before_down",
    t.PointerEvent.BEFORE_MOVE = "pointer.before_move",
    t.PointerEvent.BEFORE_UP = "pointer.before_up",
    t.PointerEvent.DOWN = "pointer.down",
    t.PointerEvent.MOVE = "pointer.move",
    t.PointerEvent.UP = "pointer.up",
    t.PointerEvent.OVER = "pointer.over",
    t.PointerEvent.OUT = "pointer.out",
    t.PointerEvent.ENTER = "pointer.enter",
    t.PointerEvent.LEAVE = "pointer.leave",
    t.PointerEvent.TAP = "tap",
    t.PointerEvent.DOUBLE_TAP = "double_tap",
    t.PointerEvent.CLICK = "click",
    t.PointerEvent.DOUBLE_CLICK = "double_click",
    t.PointerEvent.LONG_PRESS = "long_press",
    t.PointerEvent.LONG_TAP = "long_tap",
    t.PointerEvent.MENU = "pointer.menu",
    t.PointerEvent.MENU_TAP = "pointer.menu_tap",
    t.PointerEvent = zt([so()], t.PointerEvent);
    const ul = t.PointerEvent
      , pl = {};
    t.DragEvent = class extends t.PointerEvent {
        static setList(t) {
            this.list = t instanceof ra ? t : new ra(t)
        }
        static setData(t) {
            this.data = t
        }
        static getValidMove(t, e, i) {
            const {draggable: s, dragBounds: n} = t
              , o = t.getLocalPoint(i, null, !0);
            return D.move(o, e.x - t.x, e.y - t.y),
            n && this.getMoveInDragBounds(t.__local, "parent" === n ? t.parent.boxBounds : n, o, !0),
            "x" === s && (o.y = 0),
            "y" === s && (o.x = 0),
            o
        }
        static getMoveInDragBounds(t, e, i, s) {
            const n = t.x + i.x
              , o = t.y + i.y
              , r = n + t.width
              , a = o + t.height
              , h = e.x + e.width
              , l = e.y + e.height;
            return s || (i = Object.assign({}, i)),
            ot.includes(t, e) ? (n > e.x ? i.x += e.x - n : r < h && (i.x += h - r),
            o > e.y ? i.y += e.y - o : a < l && (i.y += l - a)) : (n < e.x ? i.x += e.x - n : r > h && (i.x += h - r),
            o < e.y ? i.y += e.y - o : a > l && (i.y += l - a)),
            i
        }
        getPageMove(t) {
            return this.assignMove(t),
            this.current.getPagePoint(pl, null, !0)
        }
        getInnerMove(t, e) {
            return t || (t = this.current),
            this.assignMove(e),
            t.getInnerPoint(pl, null, !0)
        }
        getLocalMove(t, e) {
            return t || (t = this.current),
            this.assignMove(e),
            t.getLocalPoint(pl, null, !0)
        }
        getPageTotal() {
            return this.getPageMove(!0)
        }
        getInnerTotal(t) {
            return this.getInnerMove(t, !0)
        }
        getLocalTotal(t) {
            return this.getLocalMove(t, !0)
        }
        getPageBounds() {
            const t = this.getPageTotal()
              , e = this.getPagePoint()
              , i = {};
            return ot.set(i, e.x - t.x, e.y - t.y, t.x, t.y),
            ot.unsign(i),
            i
        }
        assignMove(t) {
            pl.x = t ? this.totalX : this.moveX,
            pl.y = t ? this.totalY : this.moveY
        }
    }
    ,
    t.DragEvent.BEFORE_DRAG = "drag.before_drag",
    t.DragEvent.START = "drag.start",
    t.DragEvent.DRAG = "drag",
    t.DragEvent.END = "drag.end",
    t.DragEvent.OVER = "drag.over",
    t.DragEvent.OUT = "drag.out",
    t.DragEvent.ENTER = "drag.enter",
    t.DragEvent.LEAVE = "drag.leave",
    t.DragEvent = zt([so()], t.DragEvent);
    const _l = t.DragEvent;
    t.DropEvent = class extends t.PointerEvent {
        static setList(e) {
            t.DragEvent.setList(e)
        }
        static setData(e) {
            t.DragEvent.setData(e)
        }
    }
    ,
    t.DropEvent.DROP = "drop",
    t.DropEvent = zt([so()], t.DropEvent),
    t.MoveEvent = class extends t.DragEvent {
    }
    ,
    t.MoveEvent.BEFORE_MOVE = "move.before_move",
    t.MoveEvent.START = "move.start",
    t.MoveEvent.MOVE = "move",
    t.MoveEvent.END = "move.end",
    t.MoveEvent = zt([so()], t.MoveEvent),
    t.RotateEvent = class extends cl {
    }
    ,
    t.RotateEvent.BEFORE_ROTATE = "rotate.before_rotate",
    t.RotateEvent.START = "rotate.start",
    t.RotateEvent.ROTATE = "rotate",
    t.RotateEvent.END = "rotate.end",
    t.RotateEvent = zt([so()], t.RotateEvent),
    t.SwipeEvent = class extends t.DragEvent {
    }
    ,
    t.SwipeEvent.SWIPE = "swipe",
    t.SwipeEvent.LEFT = "swipe.left",
    t.SwipeEvent.RIGHT = "swipe.right",
    t.SwipeEvent.UP = "swipe.up",
    t.SwipeEvent.DOWN = "swipe.down",
    t.SwipeEvent = zt([so()], t.SwipeEvent),
    t.ZoomEvent = class extends cl {
    }
    ,
    t.ZoomEvent.BEFORE_ZOOM = "zoom.before_zoom",
    t.ZoomEvent.START = "zoom.start",
    t.ZoomEvent.ZOOM = "zoom",
    t.ZoomEvent.END = "zoom.end",
    t.ZoomEvent = zt([so()], t.ZoomEvent),
    t.KeyEvent = class extends cl {
    }
    ,
    t.KeyEvent.DOWN = "key.down",
    t.KeyEvent.HOLD = "key.hold",
    t.KeyEvent.UP = "key.up",
    t.KeyEvent = zt([so()], t.KeyEvent);
    const gl = {
        getDragEventData: (t, e, i) => Object.assign(Object.assign({}, i), {
            x: i.x,
            y: i.y,
            moveX: i.x - e.x,
            moveY: i.y - e.y,
            totalX: i.x - t.x,
            totalY: i.y - t.y
        }),
        getDropEventData: (t, e, i) => Object.assign(Object.assign({}, t), {
            list: e,
            data: i
        }),
        getSwipeDirection: e => e < -45 && e > -135 ? t.SwipeEvent.UP : e > 45 && e < 135 ? t.SwipeEvent.DOWN : e <= 45 && e >= -45 ? t.SwipeEvent.RIGHT : t.SwipeEvent.LEFT,
        getSwipeEventData: (t, e, i) => Object.assign(Object.assign({}, i), {
            moveX: e.moveX,
            moveY: e.moveY,
            totalX: i.x - t.x,
            totalY: i.y - t.y,
            type: fl.getSwipeDirection(D.getAngle(t, i))
        }),
        getBase(t) {
            const e = 1 === t.button ? 4 : t.button;
            return {
                altKey: t.altKey,
                ctrlKey: t.ctrlKey,
                shiftKey: t.shiftKey,
                metaKey: t.metaKey,
                buttons: void 0 === t.buttons ? 1 : 0 === t.buttons ? e : t.buttons,
                origin: t
            }
        },
        pathHasEventType(t, e) {
            const {list: i} = t;
            for (let t = 0, s = i.length; t < s; t++)
                if (i[t].hasEvent(e))
                    return !0;
            return !1
        },
        filterPathByEventType(t, e) {
            const i = new ra
              , {list: s} = t;
            for (let t = 0, n = s.length; t < n; t++)
                s[t].hasEvent(e) && i.add(s[t]);
            return i
        },
        pathCanDrag: e => e && e.list.some((e => e.draggable || e.editable || !e.isLeafer && e.hasEvent(t.DragEvent.DRAG))),
        pathHasOutside: t => t && t.list.some((t => t.isOutside))
    }
      , fl = gl
      , yl = new ra
      , {getDragEventData: ml, getDropEventData: vl, getSwipeEventData: wl} = gl;
    class xl {
        constructor(t) {
            this.interaction = t
        }
        setDragData(t) {
            this.animateWait && this.dragEndReal(),
            this.downData = this.interaction.downData,
            this.dragData = ml(t, t, t),
            this.canAnimate = this.canDragOut = !0
        }
        getList(e, i) {
            const {proxy: s} = this.interaction.selector
              , n = s && s.list.length
              , o = t.DragEvent.list || this.draggableList || yl;
            return this.dragging && (n ? e ? yl : new ra(i ? [...s.list, ...s.dragHoverExclude] : s.list) : o)
        }
        checkDrag(e, i) {
            const {interaction: s} = this;
            if (this.moving && e.buttons < 1)
                return this.canAnimate = !1,
                void s.pointerCancel();
            !this.moving && i && (this.moving = s.canMove(this.downData) || s.isHoldRightKey || s.isMobileDragEmpty) && (this.dragData.moveType = "drag",
            s.emit(t.MoveEvent.START, this.dragData)),
            this.moving || this.dragStart(e, i),
            this.drag(e)
        }
        dragStart(e, i) {
            this.dragging || (this.dragging = i && dl.left(e),
            this.dragging && (this.interaction.emit(t.DragEvent.START, this.dragData),
            this.getDraggableList(this.dragData.path),
            this.setDragStartPoints(this.realDraggableList = this.getList(!0))))
        }
        setDragStartPoints(t) {
            this.dragStartPoints = {},
            t.forEach((t => this.dragStartPoints[t.innerId] = {
                x: t.x,
                y: t.y
            }))
        }
        getDraggableList(t) {
            let e;
            for (let i = 0, s = t.length; i < s; i++)
                if (e = t.list[i],
                (e.draggable || e.editable) && e.hitSelf && !e.locked) {
                    this.draggableList = new ra(e);
                    break
                }
        }
        drag(e) {
            const {interaction: i, dragData: s, downData: n} = this
              , {path: o, throughPath: r} = n;
            this.dragData = ml(n, s, e),
            r && (this.dragData.throughPath = r),
            this.dragData.path = o,
            this.moving ? (this.dragData.moveType = "drag",
            i.emit(t.MoveEvent.BEFORE_MOVE, this.dragData),
            i.emit(t.MoveEvent.MOVE, this.dragData)) : this.dragging && (this.dragReal(),
            i.emit(t.DragEvent.BEFORE_DRAG, this.dragData),
            i.emit(t.DragEvent.DRAG, this.dragData))
        }
        dragReal() {
            const {running: e} = this.interaction
              , i = this.realDraggableList;
            if (i.length && e) {
                const {totalX: e, totalY: s} = this.dragData;
                i.forEach((i => i.draggable && i.move(t.DragEvent.getValidMove(i, this.dragStartPoints[i.innerId], {
                    x: e,
                    y: s
                }))))
            }
        }
        dragOverOrOut(e) {
            const {interaction: i} = this
              , {dragOverPath: s} = this
              , {path: n} = e;
            this.dragOverPath = n,
            s ? n.indexAt(0) !== s.indexAt(0) && (i.emit(t.DragEvent.OUT, e, s),
            i.emit(t.DragEvent.OVER, e, n)) : i.emit(t.DragEvent.OVER, e, n)
        }
        dragEnterOrLeave(e) {
            const {interaction: i} = this
              , {dragEnterPath: s} = this
              , {path: n} = e;
            i.emit(t.DragEvent.LEAVE, e, s, n),
            i.emit(t.DragEvent.ENTER, e, n, s),
            this.dragEnterPath = n
        }
        dragEnd(t, e) {
            (this.dragging || this.moving) && (this.checkDragEndAnimate(t, e) || this.dragEndReal(t))
        }
        dragEndReal(e) {
            const {interaction: i, downData: s, dragData: n} = this;
            e || (e = n);
            const {path: o, throughPath: r} = s
              , a = ml(s, e, e);
            if (r && (a.throughPath = r),
            a.path = o,
            this.moving && (this.moving = !1,
            a.moveType = "drag",
            i.emit(t.MoveEvent.END, a)),
            this.dragging) {
                const o = this.getList();
                this.dragging = !1,
                i.emit(t.DragEvent.END, a),
                this.swipe(e, s, n, a),
                this.drop(e, o, this.dragEnterPath)
            }
            this.autoMoveCancel(),
            this.dragReset(),
            this.animate(null, "off")
        }
        swipe(t, e, i, s) {
            const {interaction: n} = this;
            if (D.getDistance(e, t) > n.config.pointer.swipeDistance) {
                const t = wl(e, i, s);
                this.interaction.emit(t.type, t)
            }
        }
        drop(e, i, s) {
            const n = vl(e, i, t.DragEvent.data);
            n.path = s,
            this.interaction.emit(t.DropEvent.DROP, n),
            this.interaction.emit(t.DragEvent.LEAVE, e, s)
        }
        dragReset() {
            t.DragEvent.list = t.DragEvent.data = this.draggableList = this.dragData = this.downData = this.dragOverPath = this.dragEnterPath = null
        }
        checkDragEndAnimate(t, e) {
            return !1
        }
        animate(t, e) {}
        checkDragOut(t) {}
        autoMoveOnDragOut(t) {}
        autoMoveCancel() {}
        destroy() {
            this.dragReset()
        }
    }
    const bl = wt.get("emit");
    const El = ["move", "zoom", "rotate", "key"];
    function kl(t, e, i, s, n) {
        if (El.some((t => e.startsWith(t))) && t.__.hitChildren && !Bl(t, n)) {
            let o;
            for (let r = 0, a = t.children.length; r < a; r++)
                o = t.children[r],
                !i.path.has(o) && o.__.hittable && Tl(o, e, i, s, n)
        }
    }
    function Tl(t, e, i, s, n) {
        if (t.destroyed)
            return !1;
        if (t.__.hitSelf && !Bl(t, n) && (qa.updateEventStyle && !s && qa.updateEventStyle(t, e),
        t.hasEvent(e, s))) {
            i.phase = s ? 1 : t === i.target ? 2 : 3;
            const n = St.get(e, i);
            if (t.emitEvent(n, s),
            n.isStop)
                return !0
        }
        return !1
    }
    function Bl(t, e) {
        return e && e.has(t)
    }
    const Ll = {
        wheel: {
            zoomSpeed: .5,
            moveSpeed: .5,
            rotateSpeed: .5,
            delta: {
                x: 20,
                y: 8
            }
        },
        pointer: {
            hitRadius: 5,
            tapTime: 120,
            longPressTime: 800,
            transformTime: 500,
            hover: !0,
            dragHover: !0,
            dragDistance: 2,
            swipeDistance: 20
        },
        touch: {
            preventDefault: "auto"
        },
        multiTouch: {},
        move: {
            autoDistance: 2
        },
        zoom: {},
        cursor: !0,
        keyEvent: !0
    }
      , {pathHasEventType: Pl, pathCanDrag: Cl, pathHasOutside: Rl} = gl;
    class Sl {
        get dragging() {
            return this.dragger.dragging
        }
        get transforming() {
            return this.transformer.transforming
        }
        get moveMode() {
            return !0 === this.m.drag || this.isHoldSpaceKey || this.isHoldMiddleKey || this.isHoldRightKey && this.dragger.moving || this.isDragEmpty
        }
        get canHover() {
            return this.p.hover && !this.config.mobile
        }
        get isDragEmpty() {
            return this.m.dragEmpty && this.isRootPath(this.hoverData) && (!this.downData || this.isRootPath(this.downData))
        }
        get isMobileDragEmpty() {
            return this.m.dragEmpty && !this.canHover && this.downData && this.isTreePath(this.downData)
        }
        get isHoldMiddleKey() {
            return this.m.holdMiddleKey && this.downData && dl.middle(this.downData)
        }
        get isHoldRightKey() {
            return this.m.holdRightKey && this.downData && dl.right(this.downData)
        }
        get isHoldSpaceKey() {
            return this.m.holdSpaceKey && ll.isHoldSpaceKey()
        }
        get m() {
            return this.config.move
        }
        get p() {
            return this.config.pointer
        }
        get hitRadius() {
            return this.p.hitRadius
        }
        constructor(t, e, i, s) {
            this.config = Mt.clone(Ll),
            this.tapCount = 0,
            this.downKeyMap = {},
            this.target = t,
            this.canvas = e,
            this.selector = i,
            this.defaultPath = new ra(t),
            this.createTransformer(),
            this.dragger = new xl(this),
            s && (this.config = Mt.default(s, this.config)),
            this.__listenEvents()
        }
        start() {
            this.running = !0
        }
        stop() {
            this.running = !1
        }
        receive(t) {}
        pointerDown(e, i) {
            e || (e = this.hoverData),
            e && (dl.defaultLeft(e),
            this.updateDownData(e),
            this.checkPath(e, i),
            this.downTime = Date.now(),
            this.emit(t.PointerEvent.BEFORE_DOWN, e),
            this.emit(t.PointerEvent.DOWN, e),
            dl.left(e) && (this.tapWait(),
            this.longPressWait(e)),
            this.waitRightTap = dl.right(e),
            this.dragger.setDragData(e),
            this.isHoldRightKey || this.updateCursor(e))
        }
        pointerMove(t) {
            if (t || (t = this.hoverData),
            !t)
                return;
            const {downData: e} = this;
            e && dl.defaultLeft(t);
            (this.canvas.bounds.hitPoint(t) || e) && (this.pointerMoveReal(t),
            e && this.dragger.checkDragOut(t))
        }
        pointerMoveReal(e) {
            const {dragHover: i, dragDistance: s} = this.p;
            if (this.emit(t.PointerEvent.BEFORE_MOVE, e, this.defaultPath),
            this.downData) {
                const t = D.getDistance(this.downData, e) > s;
                t && (this.waitTap && this.pointerWaitCancel(),
                this.waitRightTap = !1),
                this.dragger.checkDrag(e, t)
            }
            this.dragger.moving || (this.updateHoverData(e),
            this.checkPath(e),
            this.emit(t.PointerEvent.MOVE, e),
            this.dragging && !i || this.pointerHover(e),
            this.dragger.dragging && (this.dragger.dragOverOrOut(e),
            this.dragger.dragEnterOrLeave(e))),
            this.updateCursor(this.downData || e)
        }
        pointerUp(e) {
            const {downData: i} = this;
            if (e || (e = i),
            !i)
                return;
            dl.defaultLeft(e),
            e.multiTouch = i.multiTouch,
            this.findPath(e);
            const s = Object.assign(Object.assign({}, e), {
                path: e.path.clone()
            });
            e.path.addList(i.path.list),
            this.checkPath(e),
            this.downData = null,
            this.emit(t.PointerEvent.BEFORE_UP, e),
            this.emit(t.PointerEvent.UP, e),
            this.touchLeave(e),
            e.isCancel || (this.tap(e),
            this.menuTap(e)),
            this.dragger.dragEnd(e),
            this.updateCursor(s)
        }
        pointerCancel() {
            const t = Object.assign({}, this.dragger.dragData);
            t.isCancel = !0,
            this.pointerUp(t)
        }
        menu(e) {
            this.findPath(e),
            this.emit(t.PointerEvent.MENU, e),
            this.waitMenuTap = !0,
            !this.downData && this.waitRightTap && this.menuTap(e)
        }
        menuTap(e) {
            this.waitRightTap && this.waitMenuTap && (this.emit(t.PointerEvent.MENU_TAP, e),
            this.waitRightTap = this.waitMenuTap = !1)
        }
        createTransformer() {}
        move(t) {}
        zoom(t) {}
        rotate(t) {}
        transformEnd() {}
        wheel(t) {}
        multiTouch(t, e) {}
        keyDown(e) {
            if (!this.config.keyEvent)
                return;
            const {code: i} = e;
            this.downKeyMap[i] || (this.downKeyMap[i] = !0,
            ll.setDownCode(i),
            this.emit(t.KeyEvent.HOLD, e, this.defaultPath),
            this.moveMode && (this.cancelHover(),
            this.updateCursor())),
            this.emit(t.KeyEvent.DOWN, e, this.defaultPath)
        }
        keyUp(e) {
            if (!this.config.keyEvent)
                return;
            const {code: i} = e;
            this.downKeyMap[i] = !1,
            ll.setUpCode(i),
            this.emit(t.KeyEvent.UP, e, this.defaultPath),
            "grab" === this.cursor && this.updateCursor()
        }
        pointerHover(t) {
            this.canHover && (this.pointerOverOrOut(t),
            this.pointerEnterOrLeave(t))
        }
        pointerOverOrOut(e) {
            const {path: i} = e
              , {overPath: s} = this;
            this.overPath = i,
            s ? i.indexAt(0) !== s.indexAt(0) && (this.emit(t.PointerEvent.OUT, e, s),
            this.emit(t.PointerEvent.OVER, e, i)) : this.emit(t.PointerEvent.OVER, e, i)
        }
        pointerEnterOrLeave(e) {
            let {path: i} = e;
            this.downData && !this.moveMode && (i = i.clone(),
            this.downData.path.forEach((t => i.add(t))));
            const {enterPath: s} = this;
            this.enterPath = i,
            this.emit(t.PointerEvent.LEAVE, e, s, i),
            this.emit(t.PointerEvent.ENTER, e, i, s)
        }
        touchLeave(e) {
            "touch" === e.pointerType && this.enterPath && (this.emit(t.PointerEvent.LEAVE, e),
            this.dragger.dragging && this.emit(t.DropEvent.LEAVE, e))
        }
        tap(e) {
            const {pointer: i} = this.config
              , s = this.longTap(e);
            if (!i.tapMore && s)
                return;
            if (!this.waitTap)
                return;
            i.tapMore && this.emitTap(e);
            const n = Date.now() - this.downTime
              , o = [t.PointerEvent.DOUBLE_TAP, t.PointerEvent.DOUBLE_CLICK].some((t => Pl(e.path, t)));
            n < i.tapTime + 50 && o ? (this.tapCount++,
            2 === this.tapCount ? (this.tapWaitCancel(),
            this.emitDoubleTap(e)) : (clearTimeout(this.tapTimer),
            this.tapTimer = setTimeout(( () => {
                i.tapMore || (this.tapWaitCancel(),
                this.emitTap(e))
            }
            ), i.tapTime))) : i.tapMore || (this.tapWaitCancel(),
            this.emitTap(e))
        }
        findPath(t, e) {
            const {hitRadius: i, through: s} = this.p
              , {bottomList: n} = this
              , o = this.selector.getByPoint(t, i, Object.assign({
                bottomList: n,
                name: t.type
            }, e || {
                through: s
            }));
            return o.throughPath && (t.throughPath = o.throughPath),
            t.path = o.path,
            o.path
        }
        isRootPath(t) {
            return t && t.path.list[0].isLeafer
        }
        isTreePath(t) {
            const e = this.target.app;
            return !(!e || !e.isApp) && (e.editor && !t.path.has(e.editor) && t.path.has(e.tree) && !t.target.syncEventer)
        }
        checkPath(t, e) {
            (e || this.moveMode && !Rl(t.path)) && (t.path = this.defaultPath)
        }
        canMove(t) {
            return t && (this.moveMode || "auto" === this.m.drag && !Cl(t.path)) && !Rl(t.path)
        }
        isDrag(t) {
            return this.dragger.getList().has(t)
        }
        isPress(t) {
            return this.downData && this.downData.path.has(t)
        }
        isHover(t) {
            return this.enterPath && this.enterPath.has(t)
        }
        isFocus(t) {
            return this.focusData === t
        }
        cancelHover() {
            const {hoverData: t} = this;
            t && (t.path = this.defaultPath,
            this.pointerHover(t))
        }
        updateDownData(t, e, i) {
            const {downData: s} = this;
            !t && s && (t = s),
            t && (this.findPath(t, e),
            i && s && t.path.addList(s.path.list),
            this.downData = t)
        }
        updateHoverData(e) {
            e || (e = this.hoverData),
            e && (this.findPath(e, {
                exclude: this.dragger.getList(!1, !0),
                name: t.PointerEvent.MOVE
            }),
            this.hoverData = e)
        }
        updateCursor(t) {
            if (!this.config.cursor || !this.canHover)
                return;
            if (t || (this.updateHoverData(),
            t = this.downData || this.hoverData),
            this.dragger.moving)
                return this.setCursor("grabbing");
            if (this.canMove(t))
                return this.setCursor(this.downData ? "grabbing" : "grab");
            if (!t)
                return;
            let e, i;
            const {path: s} = t;
            for (let t = 0, n = s.length; t < n && (e = s.list[t],
            i = e.syncEventer && e.syncEventer.cursor || e.cursor,
            !i); t++)
                ;
            this.setCursor(i)
        }
        setCursor(t) {
            this.cursor = t
        }
        getLocal(t, e) {
            const i = this.canvas.getClientBounds(e);
            return {
                x: t.clientX - i.x,
                y: t.clientY - i.y
            }
        }
        emitTap(e) {
            this.emit(t.PointerEvent.TAP, e),
            this.emit(t.PointerEvent.CLICK, e)
        }
        emitDoubleTap(e) {
            this.emit(t.PointerEvent.DOUBLE_TAP, e),
            this.emit(t.PointerEvent.DOUBLE_CLICK, e)
        }
        pointerWaitCancel() {
            this.tapWaitCancel(),
            this.longPressWaitCancel()
        }
        tapWait() {
            clearTimeout(this.tapTimer),
            this.waitTap = !0
        }
        tapWaitCancel() {
            clearTimeout(this.tapTimer),
            this.waitTap = !1,
            this.tapCount = 0
        }
        longPressWait(e) {
            clearTimeout(this.longPressTimer),
            this.longPressTimer = setTimeout(( () => {
                this.longPressed = !0,
                this.emit(t.PointerEvent.LONG_PRESS, e)
            }
            ), this.p.longPressTime)
        }
        longTap(e) {
            let i;
            return this.longPressed && (this.emit(t.PointerEvent.LONG_TAP, e),
            (Pl(e.path, t.PointerEvent.LONG_TAP) || Pl(e.path, t.PointerEvent.LONG_PRESS)) && (i = !0)),
            this.longPressWaitCancel(),
            i
        }
        longPressWaitCancel() {
            clearTimeout(this.longPressTimer),
            this.longPressed = !1
        }
        __onResize() {
            const {dragOut: t} = this.m;
            this.shrinkCanvasBounds = new lt(this.canvas.bounds),
            this.shrinkCanvasBounds.spread(-("number" == typeof t ? t : 2))
        }
        __listenEvents() {
            const {target: t} = this;
            this.__eventIds = [t.on_(Yo.RESIZE, this.__onResize, this)],
            t.once(Go.READY, ( () => this.__onResize()))
        }
        __removeListenEvents() {
            this.target.off_(this.__eventIds),
            this.__eventIds.length = 0
        }
        emit(t, e, i, s) {
            this.running && function(t, e, i, s) {
                if (!i && !e.path)
                    return;
                let n;
                e.type = t,
                i ? e = Object.assign(Object.assign({}, e), {
                    path: i
                }) : i = e.path,
                e.target = i.indexAt(0);
                try {
                    for (let o = i.length - 1; o > -1; o--) {
                        if (n = i.list[o],
                        Tl(n, t, e, !0, s))
                            return;
                        n.isApp && kl(n, t, e, !0, s)
                    }
                    for (let o = 0, r = i.length; o < r; o++)
                        if (n = i.list[o],
                        n.isApp && kl(n, t, e, !1, s),
                        Tl(n, t, e, !1, s))
                            return
                } catch (t) {
                    bl.error(t)
                }
            }(t, e, i, s)
        }
        destroy() {
            this.__eventIds.length && (this.stop(),
            this.__removeListenEvents(),
            this.dragger.destroy(),
            this.transformer && this.transformer.destroy(),
            this.downData = this.overPath = this.enterPath = null)
        }
    }
    class Ol {
        static set(t, e) {
            this.custom[t] = e
        }
        static get(t) {
            return this.custom[t]
        }
    }
    Ol.custom = {};
    class Dl extends Dt {
        constructor() {
            super(...arguments),
            this.maxTotal = 1e3,
            this.pathList = new ra,
            this.pixelList = new ra
        }
        getPixelType(t, e) {
            return this.__autoClear(),
            this.pixelList.add(t),
            i.hitCanvas(e)
        }
        getPathType(t) {
            return this.__autoClear(),
            this.pathList.add(t),
            i.hitCanvas()
        }
        clearImageType() {
            this.__clearLeafList(this.pixelList)
        }
        clearPathType() {
            this.__clearLeafList(this.pathList)
        }
        __clearLeafList(t) {
            t.length && (t.forEach((t => {
                t.__hitCanvas && (t.__hitCanvas.destroy(),
                t.__hitCanvas = null)
            }
            )),
            t.reset())
        }
        __autoClear() {
            this.pathList.length + this.pixelList.length > this.maxTotal && this.clear()
        }
        clear() {
            this.clearPathType(),
            this.clearImageType()
        }
    }
    const {toInnerRadiusPointOf: Ml, copy: Il, setRadius: Al} = D
      , Wl = {}
      , zl = t.Leaf.prototype;
    zl.__hitWorld = function(t) {
        if (!this.__.hitSelf)
            return !1;
        this.__.hitRadius && (Il(Wl, t),
        Al(t = Wl, this.__.hitRadius)),
        Ml(t, this.__world, Wl);
        const {width: e, height: i} = this.__world
          , s = e < 10 && i < 10;
        if (this.__.hitBox || s) {
            if (ot.hitRadiusPoint(this.__layout.boxBounds, Wl))
                return !0;
            if (s)
                return !1
        }
        return !this.__layout.hitCanvasChanged && this.__hitCanvas || (this.__updateHitCanvas(),
        this.__layout.boundsChanged || (this.__layout.hitCanvasChanged = !1)),
        this.__hit(Wl)
    }
    ,
    zl.__hitFill = function(t) {
        var e;
        return null === (e = this.__hitCanvas) || void 0 === e ? void 0 : e.hitFill(t, this.__.windingRule)
    }
    ,
    zl.__hitStroke = function(t, e) {
        var i;
        return null === (i = this.__hitCanvas) || void 0 === i ? void 0 : i.hitStroke(t, e)
    }
    ,
    zl.__hitPixel = function(t) {
        var e;
        return null === (e = this.__hitCanvas) || void 0 === e ? void 0 : e.hitPixel(t, this.__layout.renderBounds, this.__hitCanvas.hitScale)
    }
    ,
    zl.__drawHitPath = function(t) {
        t && this.__drawRenderPath(t)
    }
    ;
    const Fl = new U
      , Ul = t.UI.prototype;
    Ul.__updateHitCanvas = function() {
        const t = this.__
          , {hitCanvasManager: i} = this.leafer
          , s = (t.__pixelFill || t.__isCanvas) && "pixel" === t.hitFill
          , n = t.__pixelStroke && "pixel" === t.hitStroke
          , o = s || n;
        this.__hitCanvas || (this.__hitCanvas = o ? i.getPixelType(this, {
            contextSettings: {
                willReadFrequently: !0
            }
        }) : i.getPathType(this));
        const r = this.__hitCanvas;
        if (o) {
            const {renderBounds: i} = this.__layout
              , o = e.image.hitCanvasSize
              , a = r.hitScale = dt.set(0, 0, o, o).getFitMatrix(i).a
              , {x: h, y: l, width: d, height: c} = dt.set(i).scale(a);
            r.resize({
                width: d,
                height: c,
                pixelRatio: 1
            }),
            r.clear(),
            pn.patternLocked = !0,
            this.__renderShape(r, {
                matrix: Fl.setWith(this.__world).scaleWith(1 / a).invertWith().translate(-h, -l)
            }, !s, !n),
            pn.patternLocked = !1,
            r.resetTransform(),
            t.__isHitPixel = !0
        } else
            t.__isHitPixel && (t.__isHitPixel = !1);
        this.__drawHitPath(r),
        r.setStrokeOptions(t)
    }
    ,
    Ul.__hit = function(t) {
        "miniapp" === e.name && this.__drawHitPath(this.__hitCanvas);
        const i = this.__;
        if (i.__isHitPixel && this.__hitPixel(t))
            return !0;
        const {hitFill: s} = i
          , n = (i.fill || i.__isCanvas) && ("path" === s || "pixel" === s && !(i.__pixelFill || i.__isCanvas)) || "all" === s;
        if (n && this.__hitFill(t))
            return !0;
        const {hitStroke: o, __strokeWidth: r} = i
          , a = i.stroke && ("path" === o || "pixel" === o && !i.__pixelStroke) || "all" === o;
        if (!n && !a)
            return !1;
        const h = 2 * t.radiusX;
        let l = h;
        if (a)
            switch (i.strokeAlign) {
            case "inside":
                if (l += 2 * r,
                !n && this.__hitFill(t) && this.__hitStroke(t, l))
                    return !0;
                l = h;
                break;
            case "center":
                l += r;
                break;
            case "outside":
                if (l += 2 * r,
                !n) {
                    if (!this.__hitFill(t) && this.__hitStroke(t, l))
                        return !0;
                    l = h
                }
            }
        return !!l && this.__hitStroke(t, l)
    }
    ;
    const Hl = t.UI.prototype
      , Nl = t.Rect.prototype
      , Yl = t.Box.prototype;
    Nl.__updateHitCanvas = Yl.__updateHitCanvas = function() {
        this.stroke || this.cornerRadius || (this.fill || this.__.__isCanvas) && "pixel" === this.hitFill || "all" === this.hitStroke ? Hl.__updateHitCanvas.call(this) : this.__hitCanvas && (this.__hitCanvas = null)
    }
    ,
    Nl.__hitFill = Yl.__hitFill = function(t) {
        return this.__hitCanvas ? Hl.__hitFill.call(this, t) : ot.hitRadiusPoint(this.__layout.boxBounds, t)
    }
    ;
    const Xl = t.UI.prototype
      , Vl = t.Group.prototype;
    function jl(t) {
        return t.leafer ? t.leafer.selector : e.selector || (e.selector = i.selector())
    }
    Xl.find = function(t, e) {
        return jl(this).getBy(t, this, !1, e)
    }
    ,
    Xl.findOne = function(t, e) {
        return jl(this).getBy(t, this, !0, e)
    }
    ,
    Vl.pick = function(t, e) {
        return this.__layout.update(),
        e || (e = {}),
        jl(this).getByPoint(t, e.hitRadius || 0, Object.assign(Object.assign({}, e), {
            target: this
        }))
    }
    ;
    const Gl = Zt.prototype;
    Gl.hitFill = function(t, e) {
        return e ? this.context.isPointInPath(t.x, t.y, e) : this.context.isPointInPath(t.x, t.y)
    }
    ,
    Gl.hitStroke = function(t, e) {
        return this.strokeWidth = e,
        this.context.isPointInStroke(t.x, t.y)
    }
    ,
    Gl.hitPixel = function(t, e, i=1) {
        let {x: s, y: n, radiusX: o, radiusY: r} = t;
        e && (s -= e.x,
        n -= e.y),
        dt.set(s - o, n - r, 2 * o, 2 * r).scale(i).ceil();
        const {data: a} = this.context.getImageData(dt.x, dt.y, dt.width || 1, dt.height || 1);
        for (let t = 0, e = a.length; t < e; t += 4)
            if (a[t + 3] > 0)
                return !0;
        return a[3] > 0
    }
    ;
    const Zl = {
        convert(t, e) {
            const i = gl.getBase(t)
              , s = Object.assign(Object.assign({}, i), {
                x: e.x,
                y: e.y,
                width: t.width,
                height: t.height,
                pointerType: t.pointerType,
                pressure: t.pressure
            });
            return "pen" === s.pointerType && (s.tangentialPressure = t.tangentialPressure,
            s.tiltX = t.tiltX,
            s.tiltY = t.tiltY,
            s.twist = t.twist),
            s
        },
        convertMouse(t, e) {
            const i = gl.getBase(t);
            return Object.assign(Object.assign({}, i), {
                x: e.x,
                y: e.y,
                width: 1,
                height: 1,
                pointerType: "mouse",
                pressure: .5
            })
        },
        convertTouch(t, e) {
            const i = Zl.getTouch(t)
              , s = gl.getBase(t);
            return Object.assign(Object.assign({}, s), {
                x: e.x,
                y: e.y,
                width: 1,
                height: 1,
                pointerType: "touch",
                multiTouch: t.touches.length > 1,
                pressure: i.force
            })
        },
        getTouch: t => t.targetTouches[0] || t.changedTouches[0]
    }
      , Kl = {
        convert(t) {
            const e = gl.getBase(t);
            return Object.assign(Object.assign({}, e), {
                code: t.code,
                key: t.key
            })
        }
    }
      , {pathCanDrag: ql} = gl;
    class Jl extends Sl {
        __listenEvents() {
            super.__listenEvents();
            const t = this.view = this.canvas.view;
            this.viewEvents = {
                pointerdown: this.onPointerDown,
                mousedown: this.onMouseDown,
                touchstart: this.onTouchStart,
                contextmenu: this.onContextMenu,
                wheel: this.onWheel,
                gesturestart: this.onGesturestart,
                gesturechange: this.onGesturechange,
                gestureend: this.onGestureend
            },
            this.windowEvents = {
                pointermove: this.onPointerMove,
                pointerup: this.onPointerUp,
                pointercancel: this.onPointerCancel,
                mousemove: this.onMouseMove,
                mouseup: this.onMouseUp,
                touchmove: this.onTouchMove,
                touchend: this.onTouchEnd,
                touchcancel: this.onTouchCancel,
                keydown: this.onKeyDown,
                keyup: this.onKeyUp,
                scroll: this.onScroll
            };
            const {viewEvents: e, windowEvents: i} = this;
            for (let i in e)
                e[i] = e[i].bind(this),
                t.addEventListener(i, e[i]);
            for (let t in i)
                i[t] = i[t].bind(this),
                window.addEventListener(t, i[t])
        }
        __removeListenEvents() {
            super.__removeListenEvents();
            const {viewEvents: t, windowEvents: e} = this;
            for (let e in t)
                this.view.removeEventListener(e, t[e]),
                this.viewEvents = {};
            for (let t in e)
                window.removeEventListener(t, e[t]),
                this.windowEvents = {}
        }
        getTouches(t) {
            const e = [];
            for (let i = 0, s = t.length; i < s; i++)
                e.push(t[i]);
            return e
        }
        preventDefaultPointer(t) {
            const {pointer: e} = this.config;
            e.preventDefault && t.preventDefault()
        }
        preventDefaultWheel(t) {
            const {wheel: e} = this.config;
            e.preventDefault && t.preventDefault()
        }
        preventWindowPointer(t) {
            return !this.downData && t.target !== this.view
        }
        onKeyDown(t) {
            this.keyDown(Kl.convert(t))
        }
        onKeyUp(t) {
            this.keyUp(Kl.convert(t))
        }
        onContextMenu(t) {
            this.config.pointer.preventDefaultMenu && t.preventDefault(),
            this.menu(Zl.convert(t, this.getLocal(t)))
        }
        onScroll() {
            this.canvas.updateClientBounds()
        }
        onPointerDown(t) {
            this.preventDefaultPointer(t),
            this.config.pointer.touch || this.useMultiTouch || (this.usePointer || (this.usePointer = !0),
            this.pointerDown(Zl.convert(t, this.getLocal(t))))
        }
        onPointerMove(t) {
            this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(t) || (this.usePointer || (this.usePointer = !0),
            this.pointerMove(Zl.convert(t, this.getLocal(t, !0))))
        }
        onPointerUp(t) {
            this.downData && this.preventDefaultPointer(t),
            this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(t) || this.pointerUp(Zl.convert(t, this.getLocal(t)))
        }
        onPointerCancel() {
            this.useMultiTouch || this.pointerCancel()
        }
        onMouseDown(t) {
            this.preventDefaultPointer(t),
            this.useTouch || this.usePointer || this.pointerDown(Zl.convertMouse(t, this.getLocal(t)))
        }
        onMouseMove(t) {
            this.useTouch || this.usePointer || this.preventWindowPointer(t) || this.pointerMove(Zl.convertMouse(t, this.getLocal(t, !0)))
        }
        onMouseUp(t) {
            this.downData && this.preventDefaultPointer(t),
            this.useTouch || this.usePointer || this.preventWindowPointer(t) || this.pointerUp(Zl.convertMouse(t, this.getLocal(t)))
        }
        onMouseCancel() {
            this.useTouch || this.usePointer || this.pointerCancel()
        }
        onTouchStart(t) {
            const e = Zl.getTouch(t)
              , i = this.getLocal(e, !0)
              , {preventDefault: s} = this.config.touch;
            (!0 === s || "auto" === s && ql(this.findPath(i))) && t.preventDefault(),
            this.multiTouchStart(t),
            this.usePointer || (this.touchTimer && (window.clearTimeout(this.touchTimer),
            this.touchTimer = 0),
            this.useTouch = !0,
            this.pointerDown(Zl.convertTouch(t, i)))
        }
        onTouchMove(t) {
            if (this.multiTouchMove(t),
            this.usePointer || this.preventWindowPointer(t))
                return;
            const e = Zl.getTouch(t);
            this.pointerMove(Zl.convertTouch(t, this.getLocal(e)))
        }
        onTouchEnd(t) {
            if (this.multiTouchEnd(),
            this.usePointer || this.preventWindowPointer(t))
                return;
            this.touchTimer && clearTimeout(this.touchTimer),
            this.touchTimer = setTimeout(( () => {
                this.useTouch = !1
            }
            ), 500);
            const e = Zl.getTouch(t);
            this.pointerUp(Zl.convertTouch(t, this.getLocal(e)))
        }
        onTouchCancel() {
            this.usePointer || this.pointerCancel()
        }
        multiTouchStart(t) {
            this.useMultiTouch = t.touches.length > 1,
            this.touches = this.useMultiTouch ? this.getTouches(t.touches) : void 0,
            this.useMultiTouch && this.pointerCancel()
        }
        multiTouchMove(t) {
            if (this.useMultiTouch && t.touches.length > 1) {
                const e = this.getTouches(t.touches)
                  , i = this.getKeepTouchList(this.touches, e);
                i.length > 1 && (this.multiTouch(gl.getBase(t), i),
                this.touches = e)
            }
        }
        multiTouchEnd() {
            this.touches = null,
            this.useMultiTouch = !1,
            this.transformEnd()
        }
        getKeepTouchList(t, e) {
            let i;
            const s = [];
            return t.forEach((t => {
                i = e.find((e => e.identifier === t.identifier)),
                i && s.push({
                    from: this.getLocal(t),
                    to: this.getLocal(i)
                })
            }
            )),
            s
        }
        getLocalTouchs(t) {
            return t.map((t => this.getLocal(t)))
        }
        onWheel(t) {
            this.preventDefaultWheel(t),
            this.wheel(Object.assign(Object.assign(Object.assign({}, gl.getBase(t)), this.getLocal(t)), {
                deltaX: t.deltaX,
                deltaY: t.deltaY
            }))
        }
        onGesturestart(t) {
            this.useMultiTouch || (this.preventDefaultWheel(t),
            this.lastGestureScale = 1,
            this.lastGestureRotation = 0)
        }
        onGesturechange(t) {
            if (this.useMultiTouch)
                return;
            this.preventDefaultWheel(t);
            const e = gl.getBase(t);
            Object.assign(e, this.getLocal(t));
            const i = t.scale / this.lastGestureScale
              , s = (t.rotation - this.lastGestureRotation) / Math.PI * 180 * (h.within(this.config.wheel.rotateSpeed, 0, 1) / 4 + .1);
            this.zoom(Object.assign(Object.assign({}, e), {
                scale: i * i
            })),
            this.rotate(Object.assign(Object.assign({}, e), {
                rotation: s
            })),
            this.lastGestureScale = t.scale,
            this.lastGestureRotation = t.rotation
        }
        onGestureend(t) {
            this.useMultiTouch || (this.preventDefaultWheel(t),
            this.transformEnd())
        }
        setCursor(t) {
            super.setCursor(t);
            const e = [];
            this.eachCursor(t, e),
            "object" == typeof e[e.length - 1] && e.push("default"),
            this.canvas.view.style.cursor = e.map((t => "object" == typeof t ? `url(${t.url}) ${t.x || 0} ${t.y || 0}` : t)).join(",")
        }
        eachCursor(t, e, i=0) {
            if (i++,
            t instanceof Array)
                t.forEach((t => this.eachCursor(t, e, i)));
            else {
                const s = "string" == typeof t && Ol.get(t);
                s && i < 2 ? this.eachCursor(s, e, i) : e.push(t)
            }
        }
        destroy() {
            this.view && (super.destroy(),
            this.view = null,
            this.touches = null)
        }
    }
    function $l(t, e) {
        let i;
        const {rows: s, decorationY: n, decorationHeight: o} = t.__.__textDrawData;
        for (let t = 0, r = s.length; t < r; t++)
            i = s[t],
            i.text ? e.fillText(i.text, i.x, i.y) : i.data && i.data.forEach((t => {
                e.fillText(t.char, t.x, i.y)
            }
            )),
            n && e.fillRect(i.x, i.y + n, i.width, o)
    }
    function Ql(t, e, i) {
        const {strokeAlign: s} = e.__
          , n = "string" != typeof t;
        switch (s) {
        case "center":
            i.setStroke(n ? void 0 : t, e.__.strokeWidth, e.__),
            n ? id(t, !0, e, i) : ed(e, i);
            break;
        case "inside":
            td("inside", t, n, e, i);
            break;
        case "outside":
            td("outside", t, n, e, i)
        }
    }
    function td(t, e, i, s, n) {
        const {__strokeWidth: o, __font: r} = s.__
          , a = n.getSameCanvas(!0, !0);
        a.setStroke(i ? void 0 : e, 2 * o, s.__),
        a.font = r,
        i ? id(e, !0, s, a) : ed(s, a),
        a.blendMode = "outside" === t ? "destination-out" : "destination-in",
        $l(s, a),
        a.blendMode = "normal",
        s.__worldFlipped ? n.copyWorldByReset(a, s.__nowWorld) : n.copyWorldToInner(a, s.__nowWorld, s.__layout.renderBounds),
        a.recycle(s.__nowWorld)
    }
    function ed(t, e) {
        let i;
        const {rows: s, decorationY: n, decorationHeight: o} = t.__.__textDrawData;
        for (let t = 0, r = s.length; t < r; t++)
            i = s[t],
            i.text ? e.strokeText(i.text, i.x, i.y) : i.data && i.data.forEach((t => {
                e.strokeText(t.char, t.x, i.y)
            }
            )),
            n && e.strokeRect(i.x, i.y + n, i.width, o)
    }
    function id(t, e, i, s) {
        let n;
        for (let o = 0, r = t.length; o < r; o++)
            n = t[o],
            n.image && ja.checkImage(i, s, n, !1) || n.style && (s.strokeStyle = n.style,
            n.blendMode ? (s.saveBlendMode(n.blendMode),
            e ? ed(i, s) : s.stroke(),
            s.restoreBlendMode()) : e ? ed(i, s) : s.stroke())
    }
    function sd(t, e) {
        t.__.dashPattern && (e.beginPath(),
        t.__drawPathByData(e, t.__.__pathForArrow),
        e.dashPattern = null,
        e.stroke())
    }
    const {getSpread: nd, getOuterOf: od, getByMove: rd, getIntersectData: ad} = ot;
    let hd;
    function ld(t, e, i) {
        if ("object" != typeof e || !1 === e.visible || 0 === e.opacity)
            return;
        const {boxBounds: s} = i.__layout;
        switch (e.type) {
        case "solid":
            let {type: n, blendMode: o, color: r, opacity: a} = e;
            return {
                type: n,
                blendMode: o,
                style: Na.string(r, a)
            };
        case "image":
            return ja.image(i, t, e, s, !hd || !hd[e.url]);
        case "linear":
            return Ga.linearGradient(e, s);
        case "radial":
            return Ga.radialGradient(e, s);
        case "angular":
            return Ga.conicGradient(e, s);
        default:
            return void 0 !== e.r ? {
                type: "solid",
                style: Na.string(e)
            } : void 0
        }
    }
    const dd = {
        compute: function(t, e) {
            const i = e.__
              , s = [];
            let n, o = i.__input[t];
            o instanceof Array || (o = [o]),
            hd = ja.recycleImage(t, i);
            for (let i, n = 0, r = o.length; n < r; n++)
                i = ld(t, o[n], e),
                i && s.push(i);
            i["_" + t] = s.length ? s : void 0,
            s.length && s[0].image && (n = s[0].image.hasOpacityPixel),
            "fill" === t ? i.__pixelFill = n : i.__pixelStroke = n
        },
        fill: function(t, e, i) {
            i.fillStyle = t,
            e.__.__font ? $l(e, i) : e.__.windingRule ? i.fill(e.__.windingRule) : i.fill()
        },
        fills: function(t, e, i) {
            let s;
            const {windingRule: n, __font: o} = e.__;
            for (let r = 0, a = t.length; r < a; r++)
                s = t[r],
                s.image && ja.checkImage(e, i, s, !o) || s.style && (i.fillStyle = s.style,
                s.transform ? (i.save(),
                i.transform(s.transform),
                s.blendMode && (i.blendMode = s.blendMode),
                o ? $l(e, i) : n ? i.fill(n) : i.fill(),
                i.restore()) : s.blendMode ? (i.saveBlendMode(s.blendMode),
                o ? $l(e, i) : n ? i.fill(n) : i.fill(),
                i.restoreBlendMode()) : o ? $l(e, i) : n ? i.fill(n) : i.fill())
        },
        fillText: $l,
        stroke: function(t, e, i) {
            const s = e.__
              , {__strokeWidth: n, strokeAlign: o, __font: r} = s;
            if (n)
                if (r)
                    Ql(t, e, i);
                else
                    switch (o) {
                    case "center":
                        i.setStroke(t, n, s),
                        i.stroke(),
                        s.__useArrow && sd(e, i);
                        break;
                    case "inside":
                        i.save(),
                        i.setStroke(t, 2 * n, s),
                        s.windingRule ? i.clip(s.windingRule) : i.clip(),
                        i.stroke(),
                        i.restore();
                        break;
                    case "outside":
                        const o = i.getSameCanvas(!0, !0);
                        o.setStroke(t, 2 * n, s),
                        e.__drawRenderPath(o),
                        o.stroke(),
                        s.windingRule ? o.clip(s.windingRule) : o.clip(),
                        o.clearWorld(e.__layout.renderBounds),
                        e.__worldFlipped ? i.copyWorldByReset(o, e.__nowWorld) : i.copyWorldToInner(o, e.__nowWorld, e.__layout.renderBounds),
                        o.recycle(e.__nowWorld)
                    }
        },
        strokes: function(t, e, i) {
            const s = e.__
              , {__strokeWidth: n, strokeAlign: o, __font: r} = s;
            if (n)
                if (r)
                    Ql(t, e, i);
                else
                    switch (o) {
                    case "center":
                        i.setStroke(void 0, n, s),
                        id(t, !1, e, i),
                        s.__useArrow && sd(e, i);
                        break;
                    case "inside":
                        i.save(),
                        i.setStroke(void 0, 2 * n, s),
                        s.windingRule ? i.clip(s.windingRule) : i.clip(),
                        id(t, !1, e, i),
                        i.restore();
                        break;
                    case "outside":
                        const {renderBounds: o} = e.__layout
                          , r = i.getSameCanvas(!0, !0);
                        e.__drawRenderPath(r),
                        r.setStroke(void 0, 2 * n, s),
                        id(t, !1, e, r),
                        s.windingRule ? r.clip(s.windingRule) : r.clip(),
                        r.clearWorld(o),
                        e.__worldFlipped ? i.copyWorldByReset(r, e.__nowWorld) : i.copyWorldToInner(r, e.__nowWorld, o),
                        r.recycle(e.__nowWorld)
                    }
        },
        strokeText: Ql,
        drawTextStroke: ed,
        shape: function(t, e, i) {
            const s = e.getSameCanvas()
              , n = t.__nowWorld;
            let o, r, a, h, {scaleX: l, scaleY: d} = n;
            if (l < 0 && (l = -l),
            d < 0 && (d = -d),
            e.bounds.includes(n))
                h = s,
                o = a = n;
            else {
                const {renderShapeSpread: s} = t.__layout
                  , c = ad(s ? nd(e.bounds, l === d ? s * l : [s * d, s * l]) : e.bounds, n);
                r = e.bounds.getFitMatrix(c);
                let {a: u, d: p} = r;
                if (r.a < 1 && (h = e.getSameCanvas(),
                t.__renderShape(h, i),
                l *= u,
                d *= p),
                a = od(n, r),
                o = rd(a, -r.e, -r.f),
                i.matrix) {
                    const {matrix: t} = i;
                    r.multiply(t),
                    u *= t.scaleX,
                    p *= t.scaleY
                }
                i = Object.assign(Object.assign({}, i), {
                    matrix: r.withScale(u, p)
                })
            }
            return t.__renderShape(s, i),
            {
                canvas: s,
                matrix: r,
                bounds: o,
                worldCanvas: h,
                shapeBounds: a,
                scaleX: l,
                scaleY: d
            }
        }
    };
    let cd = {};
    const {get: ud, rotateOfOuter: pd, translate: _d, scaleOfOuter: gd, scale: fd, rotate: yd} = b;
    function md(t, e, i, s, n, o, r) {
        const a = ud();
        _d(a, e.x + i, e.y + s),
        fd(a, n, o),
        r && pd(a, {
            x: e.x + e.width / 2,
            y: e.y + e.height / 2
        }, r),
        t.transform = a
    }
    function vd(t, e, i, s, n, o, r) {
        const a = ud();
        _d(a, e.x + i, e.y + s),
        n && fd(a, n, o),
        r && yd(a, r),
        t.transform = a
    }
    function wd(t, e, i, s, n, o, r, a, h, l) {
        const d = ud();
        if (h)
            if ("center" === l)
                pd(d, {
                    x: i / 2,
                    y: s / 2
                }, h);
            else
                switch (yd(d, h),
                h) {
                case 90:
                    _d(d, s, 0);
                    break;
                case 180:
                    _d(d, i, s);
                    break;
                case 270:
                    _d(d, 0, i)
                }
        cd.x = e.x + n,
        cd.y = e.y + o,
        _d(d, cd.x, cd.y),
        r && gd(d, cd, r, a),
        t.transform = d
    }
    const {get: xd, translate: bd} = b
      , Ed = new lt
      , kd = {}
      , Td = {};
    function Bd(t, e, i, s) {
        const {blendMode: n, sync: o} = i;
        n && (t.blendMode = n),
        o && (t.sync = o),
        t.data = Ld(i, s, e)
    }
    function Ld(t, e, i) {
        let {width: s, height: n} = i;
        t.padding && (e = Ed.set(e).shrink(t.padding)),
        "strench" === t.mode && (t.mode = "stretch");
        const {opacity: o, mode: r, align: a, offset: l, scale: d, size: c, rotation: u, repeat: p} = t
          , _ = e.width === s && e.height === n
          , g = {
            mode: r
        }
          , f = "center" !== a && (u || 0) % 180 == 90
          , y = f ? n : s
          , m = f ? s : n;
        let v, w, x = 0, b = 0;
        if (r && "cover" !== r && "fit" !== r)
            (d || c) && (h.getScaleData(d, c, i, Td),
            v = Td.scaleX,
            w = Td.scaleY);
        else if (!_ || u) {
            const t = e.width / y
              , i = e.height / m;
            v = w = "fit" === r ? Math.min(t, i) : Math.max(t, i),
            x += (e.width - s * v) / 2,
            b += (e.height - n * w) / 2
        }
        if (a) {
            const t = {
                x: x,
                y: b,
                width: y,
                height: m
            };
            v && (t.width *= v,
            t.height *= w),
            mt.toPoint(a, t, e, kd, !0),
            x += kd.x,
            b += kd.y
        }
        switch (l && (x += l.x,
        b += l.y),
        r) {
        case "stretch":
            _ || (s = e.width,
            n = e.height);
            break;
        case "normal":
        case "clip":
            (x || b || v || u) && vd(g, e, x, b, v, w, u);
            break;
        case "repeat":
            (!_ || v || u) && wd(g, e, s, n, x, b, v, w, u, a),
            p || (g.repeat = "repeat");
            break;
        default:
            v && md(g, e, x, b, v, w, u)
        }
        return g.transform || (e.x || e.y) && (g.transform = xd(),
        bd(g.transform, e.x, e.y)),
        v && "stretch" !== r && (g.scaleX = v,
        g.scaleY = w),
        g.width = s,
        g.height = n,
        o && (g.opacity = o),
        p && (g.repeat = "string" == typeof p ? "x" === p ? "repeat-x" : "repeat-y" : "repeat"),
        g
    }
    let Pd, Cd = new lt;
    const {isSame: Rd} = ot;
    function Sd(t, e, i, s, n, o) {
        if ("fill" === e && !t.__.__naturalWidth) {
            const e = t.__;
            if (e.__naturalWidth = s.width / e.pixelRatio,
            e.__naturalHeight = s.height / e.pixelRatio,
            e.__autoSide)
                return t.forceUpdate("width"),
                t.__proxyData && (t.setProxyAttr("width", e.width),
                t.setProxyAttr("height", e.height)),
                !1
        }
        return n.data || Bd(n, s, i, o),
        !0
    }
    function Od(t, e) {
        Id(t, No.LOAD, e)
    }
    function Dd(t, e) {
        Id(t, No.LOADED, e)
    }
    function Md(t, e, i) {
        e.error = i,
        t.forceUpdate("surface"),
        Id(t, No.ERROR, e)
    }
    function Id(t, e, i) {
        t.hasEvent(e) && t.emitEvent(new No(e,i))
    }
    function Ad(t, e) {
        const {leafer: i} = t;
        i && i.viewReady && (i.renderer.ignore = e)
    }
    const {get: Wd, scale: zd, copy: Fd} = b
      , {ceil: Ud, abs: Hd} = Math;
    function Nd(t, i, s) {
        let {scaleX: n, scaleY: o} = pn.patternLocked ? t.__world : t.__nowWorld;
        const r = n + "-" + o + "-" + s;
        if (i.patternId === r || t.destroyed)
            return !1;
        {
            n = Hd(n),
            o = Hd(o);
            const {image: t, data: a} = i;
            let h, l, {width: d, height: c, scaleX: u, scaleY: p, opacity: _, transform: g, repeat: f} = a;
            u && (l = Wd(),
            Fd(l, g),
            zd(l, 1 / u, 1 / p),
            n *= u,
            o *= p),
            n *= s,
            o *= s,
            d *= n,
            c *= o;
            const y = d * c;
            if (!f && y > e.image.maxCacheSize)
                return !1;
            let m = e.image.maxPatternSize;
            if (!t.isSVG) {
                const e = t.width * t.height;
                m > e && (m = e)
            }
            y > m && (h = Math.sqrt(y / m)),
            h && (n /= h,
            o /= h,
            d /= h,
            c /= h),
            u && (n /= u,
            o /= p),
            (g || 1 !== n || 1 !== o) && (l || (l = Wd(),
            g && Fd(l, g)),
            zd(l, 1 / n, 1 / o));
            const v = t.getCanvas(Ud(d) || 1, Ud(c) || 1, _)
              , w = t.getPattern(v, f || e.origin.noRepeat || "no-repeat", l, i);
            return i.style = w,
            i.patternId = r,
            !0
        }
    }
    const {abs: Yd} = Math;
    const Xd = {
        image: function(t, e, i, s, n) {
            let o, r;
            const a = pn.get(i);
            return Pd && i === Pd.paint && Rd(s, Pd.boxBounds) ? o = Pd.leafPaint : (o = {
                type: i.type,
                image: a
            },
            Pd = a.use > 1 ? {
                leafPaint: o,
                paint: i,
                boxBounds: Cd.set(s)
            } : null),
            (n || a.loading) && (r = {
                image: a,
                attrName: e,
                attrValue: i
            }),
            a.ready ? (Sd(t, e, i, a, o, s),
            n && (Od(t, r),
            Dd(t, r))) : a.error ? n && Md(t, r, a.error) : (n && (Ad(t, !0),
            Od(t, r)),
            o.loadId = a.load(( () => {
                Ad(t, !1),
                t.destroyed || (Sd(t, e, i, a, o, s) && (a.hasOpacityPixel && (t.__layout.hitCanvasChanged = !0),
                t.forceUpdate("surface")),
                Dd(t, r)),
                o.loadId = null
            }
            ), (e => {
                Ad(t, !1),
                Md(t, r, e),
                o.loadId = null
            }
            ))),
            o
        },
        checkImage: function(t, i, s, n) {
            const {scaleX: o, scaleY: r} = pn.patternLocked ? t.__world : t.__nowWorld
              , {pixelRatio: a} = i;
            if (!s.data || s.patternId === o + "-" + r + "-" + a && !Ka.running)
                return !1;
            {
                const {data: h} = s;
                if (n)
                    if (h.repeat)
                        n = !1;
                    else {
                        let {width: t, height: i} = h;
                        t *= Yd(o) * a,
                        i *= Yd(r) * a,
                        h.scaleX && (t *= h.scaleX,
                        i *= h.scaleY),
                        n = t * i > e.image.maxCacheSize || Ka.running
                    }
                return n ? (i.save(),
                t.windingRule ? i.clip(t.windingRule) : i.clip(),
                s.blendMode && (i.blendMode = s.blendMode),
                h.opacity && (i.opacity *= h.opacity),
                h.transform && i.transform(h.transform),
                i.drawImage(s.image.view, 0, 0, h.width, h.height),
                i.restore(),
                !0) : (!s.style || s.sync || Ka.running ? Nd(t, s, a) : s.patternTask || (s.patternTask = pn.patternTasker.add(( () => Ft(this, void 0, void 0, (function*() {
                    s.patternTask = null,
                    i.bounds.hit(t.__nowWorld) && Nd(t, s, a),
                    t.forceUpdate("surface")
                }
                ))), 300)),
                !1)
            }
        },
        createPattern: Nd,
        recycleImage: function(t, e) {
            const i = e["_" + t];
            if (i instanceof Array) {
                let s, n, o, r;
                for (let a = 0, h = i.length; a < h; a++)
                    s = i[a].image,
                    r = s && s.url,
                    r && (n || (n = {}),
                    n[r] = !0,
                    pn.recycle(s),
                    s.loading && (o || (o = e.__input && e.__input[t] || [],
                    o instanceof Array || (o = [o])),
                    s.unload(i[a].loadId, !o.some((t => t.url === r)))));
                return n
            }
            return null
        },
        createData: Bd,
        getPatternData: Ld,
        fillOrFitMode: md,
        clipMode: vd,
        repeatMode: wd
    }
      , {toPoint: Vd} = gt
      , jd = {}
      , Gd = {};
    function Zd(t, e, i) {
        if (e) {
            let s;
            for (let n = 0, o = e.length; n < o; n++)
                s = e[n],
                "string" == typeof s ? t.addColorStop(n / (o - 1), Na.string(s, i)) : t.addColorStop(s.offset, Na.string(s.color, i))
        }
    }
    const {getAngle: Kd, getDistance: qd} = D
      , {get: Jd, rotateOfOuter: $d, scaleOfOuter: Qd} = b
      , {toPoint: tc} = gt
      , ec = {}
      , ic = {};
    function sc(t, e, i, s, n) {
        let o;
        const {width: r, height: a} = t;
        if (r !== a || s) {
            const t = Kd(e, i);
            o = Jd(),
            n ? (Qd(o, e, r / a * (s || 1), 1),
            $d(o, e, t + 90)) : (Qd(o, e, 1, r / a * (s || 1)),
            $d(o, e, t))
        }
        return o
    }
    const {getDistance: nc} = D
      , {toPoint: oc} = gt
      , rc = {}
      , ac = {};
    const hc = {
        linearGradient: function(t, i) {
            let {from: s, to: n, type: o, blendMode: r, opacity: a} = t;
            Vd(s || "top", i, jd),
            Vd(n || "bottom", i, Gd);
            const h = e.canvas.createLinearGradient(jd.x, jd.y, Gd.x, Gd.y);
            Zd(h, t.stops, a);
            const l = {
                type: o,
                style: h
            };
            return r && (l.blendMode = r),
            l
        },
        radialGradient: function(t, i) {
            let {from: s, to: n, type: o, opacity: r, blendMode: a, stretch: h} = t;
            tc(s || "center", i, ec),
            tc(n || "bottom", i, ic);
            const l = e.canvas.createRadialGradient(ec.x, ec.y, 0, ec.x, ec.y, qd(ec, ic));
            Zd(l, t.stops, r);
            const d = {
                type: o,
                style: l
            }
              , c = sc(i, ec, ic, h, !0);
            return c && (d.transform = c),
            a && (d.blendMode = a),
            d
        },
        conicGradient: function(t, i) {
            let {from: s, to: n, type: o, opacity: r, blendMode: a, stretch: h} = t;
            oc(s || "center", i, rc),
            oc(n || "bottom", i, ac);
            const l = e.conicGradientSupport ? e.canvas.createConicGradient(0, rc.x, rc.y) : e.canvas.createRadialGradient(rc.x, rc.y, 0, rc.x, rc.y, nc(rc, ac));
            Zd(l, t.stops, r);
            const d = {
                type: o,
                style: l
            }
              , c = sc(i, rc, ac, h || 1, e.conicGradientRotate90);
            return c && (d.transform = c),
            a && (d.blendMode = a),
            d
        },
        getTransform: sc
    }
      , {copy: lc, toOffsetOutBounds: dc} = ot
      , cc = {}
      , uc = {};
    function pc(t, i, s, n) {
        const {bounds: o, shapeBounds: r} = n;
        if (e.fullImageShadow) {
            if (lc(cc, t.bounds),
            cc.x += i.x - r.x,
            cc.y += i.y - r.y,
            s) {
                const {matrix: t} = n;
                cc.x -= (o.x + (t ? t.e : 0) + o.width / 2) * (s - 1),
                cc.y -= (o.y + (t ? t.f : 0) + o.height / 2) * (s - 1),
                cc.width *= s,
                cc.height *= s
            }
            t.copyWorld(n.canvas, t.bounds, cc)
        } else
            s && (lc(cc, i),
            cc.x -= i.width / 2 * (s - 1),
            cc.y -= i.height / 2 * (s - 1),
            cc.width *= s,
            cc.height *= s),
            t.copyWorld(n.canvas, r, s ? cc : i)
    }
    const {toOffsetOutBounds: _c} = ot
      , gc = {};
    const fc = {
        shadow: function(t, e, i) {
            let s, n;
            const {__nowWorld: o, __layout: r} = t
              , {shadow: a} = t.__
              , {worldCanvas: h, bounds: l, shapeBounds: d, scaleX: c, scaleY: u} = i
              , p = e.getSameCanvas()
              , _ = a.length - 1;
            dc(l, uc),
            a.forEach(( (a, g) => {
                p.setWorldShadow(uc.offsetX + a.x * c, uc.offsetY + a.y * u, a.blur * c, a.color),
                n = a.spread ? 1 + 2 * a.spread / (r.boxBounds.width + 2 * (r.strokeBoxSpread || 0)) : 0,
                pc(p, uc, n, i),
                s = l,
                a.box && (p.restore(),
                p.save(),
                h && (p.copyWorld(p, l, o, "copy"),
                s = o),
                h ? p.copyWorld(h, o, o, "destination-out") : p.copyWorld(i.canvas, d, l, "destination-out")),
                t.__worldFlipped ? e.copyWorldByReset(p, s, o, a.blendMode) : e.copyWorldToInner(p, s, r.renderBounds, a.blendMode),
                _ && g < _ && p.clearWorld(s, !0)
            }
            )),
            p.recycle(s)
        },
        innerShadow: function(t, e, i) {
            let s, n;
            const {__nowWorld: o, __layout: r} = t
              , {innerShadow: a} = t.__
              , {worldCanvas: h, bounds: l, shapeBounds: d, scaleX: c, scaleY: u} = i
              , p = e.getSameCanvas()
              , _ = a.length - 1;
            _c(l, gc),
            a.forEach(( (a, g) => {
                p.save(),
                p.setWorldShadow(gc.offsetX + a.x * c, gc.offsetY + a.y * u, a.blur * c),
                n = a.spread ? 1 - 2 * a.spread / (r.boxBounds.width + 2 * (r.strokeBoxSpread || 0)) : 0,
                pc(p, gc, n, i),
                p.restore(),
                h ? (p.copyWorld(p, l, o, "copy"),
                p.copyWorld(h, o, o, "source-out"),
                s = o) : (p.copyWorld(i.canvas, d, l, "source-out"),
                s = l),
                p.fillWorld(s, a.color, "source-in"),
                t.__worldFlipped ? e.copyWorldByReset(p, s, o, a.blendMode) : e.copyWorldToInner(p, s, r.renderBounds, a.blendMode),
                _ && g < _ && p.clearWorld(s, !0)
            }
            )),
            p.recycle(s)
        },
        blur: function(t, e, i) {
            const {blur: s} = t.__;
            i.setWorldBlur(s * t.__nowWorld.a),
            i.copyWorldToInner(e, t.__nowWorld, t.__layout.renderBounds),
            i.filter = "none"
        },
        backgroundBlur: function(t, e, i) {}
    }
      , {excludeRenderBounds: yc} = Eo;
    function mc(t, e, i, s, n, o) {
        switch (e) {
        case "grayscale":
            n.useGrayscaleAlpha(t.__nowWorld);
        case "alpha":
            !function(t, e, i, s) {
                const n = t.__nowWorld;
                i.resetTransform(),
                i.opacity = 1,
                i.useMask(s, n),
                s.recycle(n),
                wc(t, e, i, 1)
            }(t, i, s, n);
            break;
        case "opacity-path":
            wc(t, i, s, o);
            break;
        case "path":
            i.restore()
        }
    }
    function vc(t) {
        return t.getSameCanvas(!1, !0)
    }
    function wc(t, e, i, s) {
        const n = t.__nowWorld;
        e.resetTransform(),
        e.opacity = s,
        e.copyWorld(i, n),
        i.recycle(n)
    }
    t.Group.prototype.__renderMask = function(t, e) {
        let i, s, n, o, r, a;
        const {children: h} = this;
        for (let l = 0, d = h.length; l < d; l++)
            i = h[l],
            a = i.__.mask,
            a && (r && (mc(this, r, t, n, s, o),
            s = n = null),
            "path" === a || "clipping-path" === a ? (i.opacity < 1 ? (r = "opacity-path",
            o = i.opacity,
            n || (n = vc(t))) : (r = "path",
            t.save()),
            i.__clip(n || t, e)) : (r = "grayscale" === a ? "grayscale" : "alpha",
            s || (s = vc(t)),
            n || (n = vc(t)),
            i.__render(s, e)),
            "clipping" !== a && "clipping-path" !== a) || yc(i, e) || i.__render(n || t, e);
        mc(this, r, t, n, s, o)
    }
    ;
    const xc = ">)]}%!?,.:;'\"》）」〉』〗】〕｝┐＞’”！？，、。：；‰"
      , bc = xc + "_#~&*+\\=|≮≯≈≠＝…"
      , Ec = new RegExp([[19968, 40959], [13312, 19903], [131072, 173791], [173824, 177983], [177984, 178207], [178208, 183983], [183984, 191471], [196608, 201551], [201552, 205743], [11904, 12031], [12032, 12255], [12272, 12287], [12288, 12351], [12736, 12783], [12800, 13055], [13056, 13311], [63744, 64255], [65072, 65103], [127488, 127743], [194560, 195103]].map(( ([t,e]) => `[\\u${t.toString(16)}-\\u${e.toString(16)}]`)).join("|"));
    function kc(t) {
        const e = {};
        return t.split("").forEach((t => e[t] = !0)),
        e
    }
    const Tc = kc("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz")
      , Bc = kc("{[(<'\"《（「〈『〖【〔｛┌＜‘“＝¥￥＄€£￡¢￠")
      , Lc = kc(xc)
      , Pc = kc(bc)
      , Cc = kc("- —／～｜┆·");
    var Rc;
    !function(t) {
        t[t.Letter = 0] = "Letter",
        t[t.Single = 1] = "Single",
        t[t.Before = 2] = "Before",
        t[t.After = 3] = "After",
        t[t.Symbol = 4] = "Symbol",
        t[t.Break = 5] = "Break"
    }(Rc || (Rc = {}));
    const {Letter: Sc, Single: Oc, Before: Dc, After: Mc, Symbol: Ic, Break: Ac} = Rc;
    function Wc(t) {
        return Tc[t] ? Sc : Cc[t] ? Ac : Bc[t] ? Dc : Lc[t] ? Mc : Pc[t] ? Ic : Ec.test(t) ? Oc : Sc
    }
    const zc = {
        trimRight(t) {
            const {words: e} = t;
            let i, s = 0, n = e.length;
            for (let o = n - 1; o > -1 && (i = e[o].data[0],
            " " === i.char); o--)
                s++,
                t.width -= i.width;
            s && e.splice(n - s, s)
        }
    };
    function Fc(t, e, i) {
        switch (e) {
        case "title":
            return i ? t.toUpperCase() : t;
        case "upper":
            return t.toUpperCase();
        case "lower":
            return t.toLowerCase();
        default:
            return t
        }
    }
    const {trimRight: Uc} = zc
      , {Letter: Hc, Single: Nc, Before: Yc, After: Xc, Symbol: Vc, Break: jc} = Rc;
    let Gc, Zc, Kc, qc, Jc, $c, Qc, tu, eu, iu, su, nu, ou, ru, au, hu, lu, du = [];
    function cu(t, e) {
        eu && !tu && (tu = eu),
        Gc.data.push({
            char: t,
            width: e
        }),
        Kc += e
    }
    function uu() {
        qc += Kc,
        Gc.width = Kc,
        Zc.words.push(Gc),
        Gc = {
            data: []
        },
        Kc = 0
    }
    function pu() {
        ru && (au.paraNumber++,
        Zc.paraStart = !0,
        ru = !1),
        eu && (Zc.startCharSize = tu,
        Zc.endCharSize = eu,
        tu = 0),
        Zc.width = qc,
        hu.width ? Uc(Zc) : lu && _u(),
        du.push(Zc),
        Zc = {
            words: []
        },
        qc = 0
    }
    function _u() {
        qc > (au.maxWidth || 0) && (au.maxWidth = qc)
    }
    const gu = 0
      , fu = 1
      , yu = 2;
    const {top: mu, right: vu, bottom: wu, left: xu} = t.Direction4;
    function bu(t, e, i) {
        const {bounds: s, rows: n} = t;
        s[e] += i;
        for (let t = 0; t < n.length; t++)
            n[t][e] += i
    }
    const Eu = {
        getDrawData: function(t, i) {
            "string" != typeof t && (t = String(t));
            let s = 0
              , n = 0
              , o = i.__getInput("width") || 0
              , r = i.__getInput("height") || 0;
            const {textDecoration: a, __font: h, __padding: l} = i;
            l && (o ? (s = l[xu],
            o -= l[vu] + l[xu]) : i.autoSizeAlign || (s = l[xu]),
            r ? (n = l[mu],
            r -= l[mu] + l[wu]) : i.autoSizeAlign || (n = l[mu]));
            const d = {
                bounds: {
                    x: s,
                    y: n,
                    width: o,
                    height: r
                },
                rows: [],
                paraNumber: 0,
                font: e.canvas.font = h
            };
            return function(t, i, s) {
                au = t,
                du = t.rows,
                hu = t.bounds,
                lu = !hu.width && !s.autoSizeAlign;
                const {__letterSpacing: n, paraIndent: o, textCase: r} = s
                  , {canvas: a} = e
                  , {width: h, height: l} = hu;
                if (h || l || n || "none" !== r) {
                    const t = "none" !== s.textWrap
                      , e = "break" === s.textWrap;
                    ru = !0,
                    su = null,
                    tu = Qc = eu = Kc = qc = 0,
                    Gc = {
                        data: []
                    },
                    Zc = {
                        words: []
                    };
                    for (let s = 0, l = i.length; s < l; s++)
                        $c = i[s],
                        "\n" === $c ? (Kc && uu(),
                        Zc.paraEnd = !0,
                        pu(),
                        ru = !0) : (iu = Wc($c),
                        iu === Hc && "none" !== r && ($c = Fc($c, r, !Kc)),
                        Qc = a.measureText($c).width,
                        n && (n < 0 && (eu = Qc),
                        Qc += n),
                        nu = iu === Nc && (su === Nc || su === Hc) || su === Nc && iu !== Xc,
                        ou = !(iu !== Yc && iu !== Nc || su !== Vc && su !== Xc),
                        Jc = ru && o ? h - o : h,
                        t && h && qc + Kc + Qc > Jc && (e ? (Kc && uu(),
                        qc && pu()) : (ou || (ou = iu === Hc && su == Xc),
                        nu || ou || iu === jc || iu === Yc || iu === Nc || Kc + Qc > Jc ? (Kc && uu(),
                        qc && pu()) : qc && pu())),
                        " " === $c && !0 !== ru && qc + Kc === 0 || (iu === jc ? (" " === $c && Kc && uu(),
                        cu($c, Qc),
                        uu()) : nu || ou ? (Kc && uu(),
                        cu($c, Qc)) : cu($c, Qc)),
                        su = iu);
                    Kc && uu(),
                    qc && pu(),
                    du.length > 0 && (du[du.length - 1].paraEnd = !0)
                } else
                    i.split("\n").forEach((t => {
                        au.paraNumber++,
                        qc = a.measureText(t).width,
                        du.push({
                            x: o || 0,
                            text: t,
                            width: qc,
                            paraStart: !0
                        }),
                        lu && _u()
                    }
                    ))
            }(d, t, i),
            l && function(t, e, i, s, n) {
                if (!s && i.autoSizeAlign)
                    switch (i.textAlign) {
                    case "left":
                        bu(e, "x", t[xu]);
                        break;
                    case "right":
                        bu(e, "x", -t[vu])
                    }
                if (!n && i.autoSizeAlign)
                    switch (i.verticalAlign) {
                    case "top":
                        bu(e, "y", t[mu]);
                        break;
                    case "bottom":
                        bu(e, "y", -t[wu])
                    }
            }(l, d, i, o, r),
            function(t, e) {
                const {rows: i, bounds: s} = t
                  , {__lineHeight: n, __baseLine: o, __letterSpacing: r, __clipText: a, textAlign: h, verticalAlign: l, paraSpacing: d, autoSizeAlign: c} = e;
                let {x: u, y: p, width: _, height: g} = s
                  , f = n * i.length + (d ? d * (t.paraNumber - 1) : 0)
                  , y = o;
                if (a && f > g)
                    f = Math.max(g, n),
                    t.overflow = i.length;
                else if (g || c)
                    switch (l) {
                    case "middle":
                        p += (g - f) / 2;
                        break;
                    case "bottom":
                        p += g - f
                    }
                y += p;
                let m, v, w, x = _ || c ? _ : t.maxWidth;
                for (let o = 0, l = i.length; o < l; o++) {
                    if (m = i[o],
                    m.x = u,
                    m.width < _ || m.width > _ && !a)
                        switch (h) {
                        case "center":
                            m.x += (x - m.width) / 2;
                            break;
                        case "right":
                            m.x += x - m.width
                        }
                    m.paraStart && d && o > 0 && (y += d),
                    m.y = y,
                    y += n,
                    t.overflow > o && y > f && (m.isOverflow = !0,
                    t.overflow = o + 1),
                    v = m.x,
                    w = m.width,
                    r < 0 && (m.width < 0 ? (w = -m.width + e.fontSize + r,
                    v -= w,
                    w += e.fontSize) : w -= r),
                    v < s.x && (s.x = v),
                    w > s.width && (s.width = w),
                    a && _ && _ < w && (m.isOverflow = !0,
                    t.overflow || (t.overflow = i.length))
                }
                s.y = p,
                s.height = f
            }(d, i),
            function(t, e, i, s) {
                const {rows: n} = t
                  , {textAlign: o, paraIndent: r, letterSpacing: a} = e;
                let h, l, d, c, u;
                n.forEach((t => {
                    t.words && (d = r && t.paraStart ? r : 0,
                    l = i && "justify" === o && t.words.length > 1 ? (i - t.width - d) / (t.words.length - 1) : 0,
                    c = a || t.isOverflow ? gu : l > .01 ? fu : yu,
                    t.isOverflow && !a && (t.textMode = !0),
                    c === yu ? (t.x += d,
                    function(t) {
                        t.text = "",
                        t.words.forEach((e => {
                            e.data.forEach((e => {
                                t.text += e.char
                            }
                            ))
                        }
                        ))
                    }(t)) : (t.x += d,
                    h = t.x,
                    t.data = [],
                    t.words.forEach((e => {
                        c === fu ? (u = {
                            char: "",
                            x: h
                        },
                        h = function(t, e, i) {
                            return t.forEach((t => {
                                i.char += t.char,
                                e += t.width
                            }
                            )),
                            e
                        }(e.data, h, u),
                        (t.isOverflow || " " !== u.char) && t.data.push(u)) : h = function(t, e, i, s) {
                            return t.forEach((t => {
                                (s || " " !== t.char) && (t.x = e,
                                i.push(t)),
                                e += t.width
                            }
                            )),
                            e
                        }(e.data, h, t.data, t.isOverflow),
                        !t.paraEnd && l && (h += l,
                        t.width += l)
                    }
                    ))),
                    t.words = null)
                }
                ))
            }(d, i, o),
            d.overflow && function(t, i, s, n) {
                if (!n)
                    return;
                const {rows: o, overflow: r} = t;
                let {textOverflow: a} = i;
                if (o.splice(r),
                a && "show" !== a) {
                    let t, h;
                    "hide" === a ? a = "" : "ellipsis" === a && (a = "...");
                    const l = a ? e.canvas.measureText(a).width : 0
                      , d = s + n - l;
                    ("none" === i.textWrap ? o : [o[r - 1]]).forEach((e => {
                        if (e.isOverflow && e.data) {
                            let i = e.data.length - 1;
                            for (let s = i; s > -1 && (t = e.data[s],
                            h = t.x + t.width,
                            !(s === i && h < d)); s--) {
                                if (h < d && " " !== t.char) {
                                    e.data.splice(s + 1),
                                    e.width -= t.width;
                                    break
                                }
                                e.width -= t.width
                            }
                            e.width += l,
                            e.data.push({
                                char: a,
                                x: h
                            }),
                            e.textMode && function(t) {
                                t.text = "",
                                t.data.forEach((e => {
                                    t.text += e.char
                                }
                                )),
                                t.data = null
                            }(e)
                        }
                    }
                    ))
                }
            }(d, i, s, o),
            "none" !== a && function(t, e) {
                const {fontSize: i} = e;
                switch (t.decorationHeight = i / 11,
                e.textDecoration) {
                case "under":
                    t.decorationY = .15 * i;
                    break;
                case "delete":
                    t.decorationY = .35 * -i
                }
            }(d, i),
            d
        }
    };
    const ku = {
        string: function(t, e) {
            const i = "number" == typeof e && 1 !== e;
            if ("string" == typeof t) {
                if (!i || !Na.object)
                    return t;
                t = Na.object(t)
            }
            let s = void 0 === t.a ? 1 : t.a;
            i && (s *= e);
            const n = t.r + "," + t.g + "," + t.b;
            return 1 === s ? "rgb(" + n + ")" : "rgba(" + n + "," + s + ")"
        }
    }
      , {setPoint: Tu, addPoint: Bu, toBounds: Lu} = N;
    const Pu = {
        export(t, s, n) {
            this.running = !0;
            const o = hn.fileType(s)
              , r = s.includes(".");
            return n = hn.getExportOptions(n),
            function(t) {
                Cu || (Cu = new un);
                return new Promise((e => {
                    Cu.add(( () => Ft(this, void 0, void 0, (function*() {
                        return yield t(e)
                    }
                    ))), {
                        parallel: !1
                    })
                }
                ))
            }((a => new Promise((l => {
                const d = t => {
                    a(t),
                    l(),
                    this.running = !1
                }
                  , {toURL: c} = e
                  , {download: u} = e.origin;
                if ("json" === o)
                    return r && u(c(JSON.stringify(t.toJSON(n.json)), "text"), s),
                    d({
                        data: !!r || t.toJSON(n.json)
                    });
                if ("svg" === o)
                    return r && u(c(t.toSVG(), "svg"), s),
                    d({
                        data: !!r || t.toSVG()
                    });
                const {leafer: p} = t;
                p ? (Ru(t),
                p.waitViewCompleted(( () => Ft(this, void 0, void 0, (function*() {
                    let e, o, r = 1, a = 1;
                    const {worldTransform: l, isLeafer: c, isFrame: u} = t
                      , {slice: _, trim: g, onCanvas: f} = n
                      , y = void 0 === n.smooth ? p.config.smooth : n.smooth
                      , m = n.contextSettings || p.config.contextSettings
                      , v = n.screenshot || t.isApp
                      , w = c && v && void 0 === n.fill ? t.fill : n.fill
                      , x = hn.isOpaqueImage(s) || w
                      , b = new U;
                    if (v)
                        e = !0 === v ? c ? p.canvas.bounds : t.worldRenderBounds : v;
                    else {
                        let i = n.relative || (c ? "inner" : "local");
                        switch (r = l.scaleX,
                        a = l.scaleY,
                        i) {
                        case "inner":
                            b.set(l);
                            break;
                        case "local":
                            b.set(l).divide(t.localTransform),
                            r /= t.scaleX,
                            a /= t.scaleY;
                            break;
                        case "world":
                            r = 1,
                            a = 1;
                            break;
                        case "page":
                            i = t.leafer;
                        default:
                            b.set(l).divide(t.getTransform(i));
                            const e = i.worldTransform;
                            r /= r / e.scaleX,
                            a /= a / e.scaleY
                        }
                        e = t.getBounds("render", i)
                    }
                    const E = {
                        scaleX: 1,
                        scaleY: 1
                    };
                    h.getScaleData(n.scale, n.size, e, E);
                    let k = n.pixelRatio || 1;
                    t.isApp && (E.scaleX *= k,
                    E.scaleY *= k,
                    k = t.app.pixelRatio);
                    const {x: T, y: B, width: L, height: P} = new lt(e).scale(E.scaleX, E.scaleY)
                      , C = {
                        matrix: b.scale(1 / E.scaleX, 1 / E.scaleY).invert().translate(-T, -B).withScale(1 / r * E.scaleX, 1 / a * E.scaleY)
                    };
                    let R, S = i.canvas({
                        width: Math.round(L),
                        height: Math.round(P),
                        pixelRatio: k,
                        smooth: y,
                        contextSettings: m
                    });
                    if (_ && (R = t,
                    R.__worldOpacity = 0,
                    t = p,
                    C.bounds = S.bounds),
                    S.save(),
                    u && void 0 !== w) {
                        const e = t.get("fill");
                        t.fill = "",
                        t.__render(S, C),
                        t.fill = e
                    } else
                        t.__render(S, C);
                    if (S.restore(),
                    R && R.__updateWorldOpacity(),
                    g) {
                        o = function(t) {
                            const {width: e, height: i} = t.view
                              , {data: s} = t.context.getImageData(0, 0, e, i);
                            let n, o, r, a = 0;
                            for (let t = 0; t < s.length; t += 4)
                                0 !== s[t + 3] && (n = a % e,
                                o = (a - n) / e,
                                r ? Bu(r, n, o) : Tu(r = {}, n, o)),
                                a++;
                            const h = new lt;
                            return Lu(r, h),
                            h.scale(1 / t.pixelRatio).ceil()
                        }(S);
                        const t = S
                          , {width: e, height: s} = o
                          , n = {
                            x: 0,
                            y: 0,
                            width: e,
                            height: s,
                            pixelRatio: k
                        };
                        S = i.canvas(n),
                        S.copyWorld(t, o, n)
                    }
                    x && S.fillWorld(S.bounds, w || "#FFFFFF", "destination-over"),
                    f && f(S);
                    const O = "canvas" === s ? S : yield S.export(s, n);
                    d({
                        data: O,
                        width: S.pixelWidth,
                        height: S.pixelHeight,
                        renderBounds: e,
                        trimBounds: o
                    })
                }
                ))))) : d({
                    data: !1
                })
            }
            ))))
        }
    };
    let Cu;
    function Ru(t) {
        t.__.__needComputePaint && t.__.__computePaint(),
        t.isBranch && t.children.forEach((t => Ru(t)))
    }
    const Su = Zt.prototype
      , Ou = wt.get("@leafer-ui/export");
    function Du(t) {
        return t ? t instanceof Array ? t : [t] : []
    }
    Su.export = function(t, e) {
        const {quality: i, blob: s} = hn.getExportOptions(e);
        return t.includes(".") ? this.saveAs(t, i) : s ? this.toBlob(t, i) : this.toDataURL(t, i)
    }
    ,
    Su.toBlob = function(t, i) {
        return new Promise((s => {
            e.origin.canvasToBolb(this.view, t, i).then((t => {
                s(t)
            }
            )).catch((t => {
                Ou.error(t),
                s(null)
            }
            ))
        }
        ))
    }
    ,
    Su.toDataURL = function(t, i) {
        return e.origin.canvasToDataURL(this.view, t, i)
    }
    ,
    Su.saveAs = function(t, i) {
        return new Promise((s => {
            e.origin.canvasSaveAs(this.view, t, i).then(( () => {
                s(!0)
            }
            )).catch((t => {
                Ou.error(t),
                s(!1)
            }
            ))
        }
        ))
    }
    ,
    Object.assign(Ha, Eu),
    Object.assign(Na, ku),
    Object.assign(Va, dd),
    Object.assign(ja, Xd),
    Object.assign(Ga, hc),
    Object.assign(Za, fc),
    Object.assign(Ka, Pu),
    Object.assign(i, {
        interaction: (t, e, i, s) => new Jl(t,e,i,s),
        hitCanvas: (t, e) => new la(t,e),
        hitCanvasManager: () => new Dl
    }),
    ua();
    class Mu extends Fo {
        get list() {
            return Du(this.value)
        }
        get oldList() {
            return Du(this.oldValue)
        }
        constructor(t, e) {
            super(t),
            e && Object.assign(this, e)
        }
    }
    Mu.SELECT = "editor.select",
    Mu.HOVER = "editor.hover";
    class Iu extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    Iu.MOVE = "editor.move";
    class Au extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    Au.SCALE = "editor.scale";
    class Wu extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    Wu.ROTATE = "editor.rotate";
    class zu extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    function Fu(t) {
        return (e, i) => {
            const s = "_" + i;
            mn(e, i, {
                get() {
                    return this[s]
                },
                set(e) {
                    const i = this[s];
                    i !== e && (this[s] = e,
                    t(this, i))
                }
            })
        }
    }
    zu.SKEW = "editor.skew";
    const {abs: Uu} = Math
      , {copy: Hu, scale: Nu} = b
      , {setListWithFn: Yu} = ot
      , {worldBounds: Xu} = Eo
      , Vu = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    }
      , ju = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    class Gu extends t.UI {
        constructor() {
            super(),
            this.list = [],
            this.hittable = !1,
            this.strokeAlign = "center"
        }
        setTarget(t, e) {
            this.set(e),
            this.target = t,
            this.update()
        }
        update() {
            const {list: t} = this;
            t.length ? (Yu(ju, t, Xu),
            this.set(ju)) : this.width = this.height = 1
        }
        __draw(t, e) {
            const {list: i} = this;
            if (i.length) {
                let s;
                const n = this.__
                  , {stroke: o, strokeWidth: r, fill: a} = n
                  , {bounds: h} = e;
                for (let l = 0; l < i.length; l++) {
                    s = i[l];
                    const {worldTransform: d, worldRenderBounds: c} = s;
                    if (!h || h.hit(c, e.matrix)) {
                        const i = Uu(d.scaleX)
                          , h = Uu(d.scaleY);
                        if (i !== h) {
                            Hu(Vu, d),
                            Nu(Vu, 1 / i, 1 / h),
                            t.setWorld(Vu, e.matrix),
                            t.beginPath(),
                            n.strokeWidth = r;
                            const {x: o, y: a, width: l, height: c} = s.__layout.boxBounds;
                            t.rect(o * i, a * h, l * i, c * h)
                        } else
                            t.setWorld(d, e.matrix),
                            t.beginPath(),
                            s.__.__useArrow ? s.__drawPath(t) : s.__.__pathForRender ? s.__drawRenderPath(t) : s.__drawPathByBox(t),
                            n.strokeWidth = r / Uu(d.scaleX);
                        o && ("string" == typeof o ? Va.stroke(o, this, t) : Va.strokes(o, this, t)),
                        a && ("string" == typeof a ? Va.fill(a, this, t) : Va.fills(a, this, t))
                    }
                }
                n.strokeWidth = r
            }
        }
        destroy() {
            this.target = null,
            super.destroy()
        }
    }
    zt([Fu((function(t) {
        const e = t.target;
        t.list = e ? e instanceof Array ? e : [e] : []
    }
    ))], Gu.prototype, "target", void 0);
    class Zu extends t.Group {
        constructor(e) {
            super(e),
            this.strokeArea = new t.Rect({
                strokeAlign: "center"
            }),
            this.fillArea = new t.Rect,
            this.visible = this.hittable = !1,
            this.addMany(this.fillArea, this.strokeArea)
        }
        setStyle(t, e) {
            const {visible: i, stroke: s, strokeWidth: n} = t;
            this.visible = i,
            this.strokeArea.reset(Object.assign({
                stroke: s,
                strokeWidth: n
            }, e || {})),
            this.fillArea.reset({
                visible: !e,
                fill: s,
                opacity: .2
            })
        }
        setBounds(t) {
            this.strokeArea.set(t),
            this.fillArea.set(t)
        }
    }
    const {No: Ku, Yes: qu, NoAndSkip: Ju, YesAndSkip: $u} = t.Answer
      , Qu = {
        findOne: t => t.list.find((t => t.editable)),
        findBounds(t, e) {
            if (t.__.hittable && t.__.visible && !t.__.locked && e.hit(t.__world)) {
                if (t.__.editable) {
                    if (t.isBranch && !t.__.hitChildren)
                        return t.__.hitSelf ? $u : Ju;
                    if (t.isFrame)
                        return e.includes(t.__layout.boxBounds, t.__world) ? $u : Ku;
                    if (e.hit(t.__layout.boxBounds, t.__world) && t.__.hitSelf)
                        return qu
                }
                return Ku
            }
            return t.isBranch ? Ju : Ku
        }
    }
      , {findOne: tp} = Qu;
    class ep extends t.Group {
        get dragging() {
            return !!this.originList
        }
        get running() {
            const {editor: t} = this;
            return this.hittable && t.visible && t.hittable && t.mergeConfig.selector
        }
        get isMoveMode() {
            return this.app && this.app.interaction.moveMode
        }
        constructor(t) {
            super(),
            this.hoverStroker = new Gu,
            this.targetStroker = new Gu,
            this.bounds = new lt,
            this.selectArea = new Zu,
            this.__eventIds = [],
            this.editor = t,
            this.addMany(this.targetStroker, this.hoverStroker, this.selectArea),
            this.__listenEvents()
        }
        onHover() {
            const {editor: t} = this;
            if (!this.running || this.dragging || t.dragging)
                this.hoverStroker.target = null;
            else {
                const {stroke: e, strokeWidth: i, hover: s, hoverStyle: n} = t.mergeConfig;
                this.hoverStroker.setTarget(s ? this.editor.hoverTarget : null, Object.assign({
                    stroke: e,
                    strokeWidth: i
                }, n || {}))
            }
        }
        onSelect() {
            if (this.running) {
                const {mergeConfig: t, list: e} = this.editor
                  , {stroke: i, strokeWidth: s} = t;
                this.targetStroker.setTarget(e, {
                    stroke: i,
                    strokeWidth: Math.max(1, s / 2)
                }),
                this.hoverStroker.target = null
            }
        }
        update() {
            this.hoverStroker.update(),
            this.targetStroker.update()
        }
        onPointerMove(t) {
            const {app: e, editor: i} = this;
            if (this.running && !this.isMoveMode && e.interaction.canHover && !e.interaction.dragging) {
                const e = this.findUI(t);
                i.hoverTarget = i.hasItem(e) ? null : e
            }
            this.isMoveMode && (i.hoverTarget = null)
        }
        onBeforeDown(t) {
            if (t.multiTouch)
                return;
            const {select: e} = this.editor.mergeConfig;
            "press" === e && (this.app.config.mobile ? this.waitSelect = () => this.checkAndSelect(t) : this.checkAndSelect(t))
        }
        onTap(t) {
            if (t.multiTouch)
                return;
            const {editor: e} = this
              , {select: i} = e.mergeConfig;
            "tap" === i ? this.checkAndSelect(t) : this.waitSelect && this.waitSelect(),
            this.needRemoveItem ? e.removeItem(this.needRemoveItem) : this.isMoveMode && (e.target = null)
        }
        checkAndSelect(t) {
            if (this.needRemoveItem = null,
            this.allowSelect(t)) {
                const {editor: e} = this
                  , i = this.findUI(t);
                i ? this.isMultipleSelect(t) ? e.hasItem(i) ? this.needRemoveItem = i : e.addItem(i) : e.target = i : this.allow(t.target) && (t.shiftKey || (e.target = null))
            }
        }
        onDragStart(t) {
            if (!t.multiTouch && (this.waitSelect && this.waitSelect(),
            this.allowDrag(t))) {
                const {editor: e} = this
                  , {stroke: i, area: s} = e.mergeConfig
                  , {x: n, y: o} = t.getInnerPoint(this);
                this.bounds.set(n, o),
                this.selectArea.setStyle({
                    visible: !0,
                    stroke: i,
                    x: n,
                    y: o
                }, s),
                this.selectArea.setBounds(this.bounds.get()),
                this.originList = e.leafList.clone()
            }
        }
        onDrag(t) {
            if (!t.multiTouch) {
                if (this.editor.dragging)
                    return this.onDragEnd(t);
                if (this.dragging) {
                    const {editor: e} = this
                      , i = t.getInnerTotal(this)
                      , s = this.bounds.clone().unsign()
                      , n = new ra(e.app.find(Qu.findBounds, s));
                    if (this.bounds.width = i.x,
                    this.bounds.height = i.y,
                    this.selectArea.setBounds(s.get()),
                    n.length) {
                        const t = [];
                        this.originList.forEach((e => {
                            n.has(e) || t.push(e)
                        }
                        )),
                        n.forEach((e => {
                            this.originList.has(e) || t.push(e)
                        }
                        )),
                        (t.length !== e.list.length || e.list.some(( (e, i) => e !== t[i]))) && (e.target = t)
                    } else
                        e.target = this.originList.list
                }
            }
        }
        onDragEnd(t) {
            t.multiTouch || this.dragging && (this.originList = null,
            this.selectArea.visible = !1)
        }
        onAutoMove(t) {
            if (this.dragging) {
                const {x: e, y: i} = t.getLocalMove(this);
                this.bounds.x += e,
                this.bounds.y += i
            }
        }
        allow(t) {
            return t.leafer !== this.editor.leafer
        }
        allowDrag(t) {
            return !(!this.running || !this.editor.mergeConfig.boxSelect || t.target.draggable) && (!this.editor.editing && this.allow(t.target) || t.shiftKey && !tp(t.path))
        }
        allowSelect(t) {
            return this.running && !this.isMoveMode && !t.middle
        }
        findDeepOne(t) {
            const e = {
                exclude: new ra(this.editor.editBox.rect)
            };
            return tp(t.target.leafer.interaction.findPath(t, e))
        }
        findUI(t) {
            return this.isMultipleSelect(t) ? this.findDeepOne(t) : tp(t.path)
        }
        isMultipleSelect(t) {
            return t.shiftKey || this.editor.mergeConfig.continuousSelect
        }
        __listenEvents() {
            const {editor: e} = this;
            e.waitLeafer(( () => {
                const {app: i} = e;
                i.selector.proxy = e,
                this.__eventIds = [e.on_(Mu.HOVER, this.onHover, this), e.on_(Mu.SELECT, this.onSelect, this), i.on_(t.PointerEvent.MOVE, this.onPointerMove, this), i.on_(t.PointerEvent.BEFORE_DOWN, this.onBeforeDown, this), i.on_(t.PointerEvent.TAP, this.onTap, this), i.on_(t.DragEvent.START, this.onDragStart, this, !0), i.on_(t.DragEvent.DRAG, this.onDrag, this), i.on_(t.DragEvent.END, this.onDragEnd, this), i.on_(t.MoveEvent.MOVE, this.onAutoMove, this), i.on_([t.ZoomEvent.ZOOM, t.MoveEvent.MOVE], ( () => {
                    this.editor.hoverTarget = null
                }
                ))]
            }
            ))
        }
        __removeListenEvents() {
            this.__eventIds && (this.off_(this.__eventIds),
            this.__eventIds.length = 0)
        }
        destroy() {
            this.editor = this.originList = this.needRemoveItem = null,
            this.__removeListenEvents(),
            super.destroy()
        }
    }
    const {topLeft: ip, top: sp, topRight: np, right: op, bottomRight: rp, bottom: ap, bottomLeft: hp, left: lp} = t.Direction9
      , {toPoint: dp} = gt
      , {within: cp} = h
      , up = {
        getScaleData(t, e, i, s, n, o, r, a) {
            let h, l = {}, d = 1, c = 1;
            const {boxBounds: u, widthRange: p, heightRange: _} = t
              , {width: g, height: f} = e;
            o && (s.x *= 2,
            s.y *= 2);
            const y = t.scaleX / e.scaleX
              , m = t.scaleY / e.scaleY
              , v = y < 0 ? -1 : 1
              , w = m < 0 ? -1 : 1
              , x = a ? y : v * u.width / g
              , b = a ? m : w * u.height / f;
            s.x *= a ? y : v,
            s.y *= a ? m : w,
            Math.abs(s.x) === g && (s.x += .1),
            Math.abs(s.y) === f && (s.y += .1);
            const E = (-s.y + f) / f
              , k = (s.x + g) / g
              , T = (s.y + f) / f
              , B = (-s.x + g) / g;
            switch (i) {
            case sp:
                c = E,
                h = "bottom";
                break;
            case op:
                d = k,
                h = "left";
                break;
            case ap:
                c = T,
                h = "top";
                break;
            case lp:
                d = B,
                h = "right";
                break;
            case ip:
                c = E,
                d = B,
                h = "bottom-right";
                break;
            case np:
                c = E,
                d = k,
                h = "bottom-left";
                break;
            case rp:
                c = T,
                d = k,
                h = "top-left";
                break;
            case hp:
                c = T,
                d = B,
                h = "top-right"
            }
            if (n) {
                if (!("corner" === n && i % 2)) {
                    let t;
                    switch (i) {
                    case sp:
                    case ap:
                        t = c;
                        break;
                    case lp:
                    case op:
                        t = d;
                        break;
                    default:
                        t = Math.sqrt(Math.abs(d * c))
                    }
                    d = d < 0 ? -t : t,
                    c = c < 0 ? -t : t
                }
            }
            if (d /= x,
            c /= b,
            !r) {
                const {worldTransform: e} = t;
                d < 0 && (d = 1 / u.width / e.scaleX),
                c < 0 && (c = 1 / u.height / e.scaleY)
            }
            if (p) {
                const e = u.width * t.scaleX;
                d = cp(e * d, p) / e
            }
            if (_) {
                const e = u.height * t.scaleY;
                c = cp(e * c, _) / e
            }
            return dp(o || h, u, l, !0),
            {
                origin: l,
                scaleX: d,
                scaleY: c,
                direction: i,
                lockRatio: n,
                around: o
            }
        },
        getRotateData(t, e, i, s, n) {
            let o, r = {};
            switch (e) {
            case ip:
                o = "bottom-right";
                break;
            case np:
                o = "bottom-left";
                break;
            case rp:
                o = "top-left";
                break;
            case hp:
                o = "top-right";
                break;
            default:
                o = "center"
            }
            return dp(n || o, t, r, !0),
            {
                origin: r,
                rotation: D.getRotation(s, r, i)
            }
        },
        getSkewData(t, e, i, s) {
            let n, o, r = {}, a = 0, h = 0;
            switch (e) {
            case sp:
                o = {
                    x: .5,
                    y: 0
                },
                n = "bottom",
                a = 1;
                break;
            case ap:
                o = {
                    x: .5,
                    y: 1
                },
                n = "top",
                a = 1;
                break;
            case lp:
                o = {
                    x: 0,
                    y: .5
                },
                n = "right",
                h = 1;
                break;
            case op:
                o = {
                    x: 1,
                    y: .5
                },
                n = "left",
                h = 1
            }
            const {width: l, height: d} = t;
            o.x = o.x * l,
            o.y = o.y * d,
            dp(s || n, t, r, !0);
            const c = D.getRotation(o, r, {
                x: o.x + (a ? i.x : 0),
                y: o.y + (h ? i.y : 0)
            });
            return a ? a = -c : h = c,
            {
                origin: r,
                skewX: a,
                skewY: h
            }
        },
        getAround: (t, e) => e && !t ? "center" : t,
        getRotateDirection: (t, e, i=8) => ((t = (t + Math.round(e / (360 / i))) % i) < 0 && (t += i),
        t),
        getFlipDirection(t, e, i) {
            if (e)
                switch (t) {
                case lp:
                    t = op;
                    break;
                case ip:
                    t = np;
                    break;
                case hp:
                    t = rp;
                    break;
                case op:
                    t = lp;
                    break;
                case np:
                    t = ip;
                    break;
                case rp:
                    t = hp
                }
            if (i)
                switch (t) {
                case sp:
                    t = ap;
                    break;
                case ip:
                    t = hp;
                    break;
                case np:
                    t = rp;
                    break;
                case ap:
                    t = sp;
                    break;
                case hp:
                    t = ip;
                    break;
                case rp:
                    t = np
                }
            return t
        }
    }
      , pp = {};
    function _p(t, e) {
        const {editBox: i} = t
          , s = i.enterPoint;
        if (!s || !t.editing || !i.visible)
            return;
        if ("circle" === s.name)
            return;
        if ("button" === s.pointType)
            return void (s.cursor || (s.cursor = "pointer"));
        let {rotation: n} = i;
        const {resizeCursor: o, rotateCursor: r, skewCursor: a, resizeable: l, rotateable: d, skewable: c} = t.mergeConfig
          , {pointType: u} = s
          , {flippedX: p, flippedY: _} = i;
        let g = "resize" === u;
        g && d && (e.metaKey || e.ctrlKey || !l) && (g = !1);
        const f = c && !g && "resize-line" === s.name ? a : g ? o : r;
        n += 45 * (up.getFlipDirection(s.direction, p, _) + 1),
        n = 2 * Math.round(h.formatRotation(n, !0) / 2);
        const {url: y, x: m, y: v} = f
          , w = y + n;
        pp[w] ? s.cursor = pp[w] : pp[w] = s.cursor = {
            url: fp(y, n),
            x: m,
            y: v
        }
    }
    function gp(t) {
        const {moveCursor: e, moveable: i} = t.mergeConfig;
        t.editBox.rect.cursor = i ? e : void 0
    }
    function fp(t, e) {
        return '"data:image/svg+xml,' + encodeURIComponent(t.replace("{{rotation}}", e.toString())) + '"'
    }
    class yp extends t.Box {
    }
    const mp = ["top", "right", "bottom", "left"];
    class vp extends t.Group {
        get flipped() {
            return this.flippedX || this.flippedY
        }
        get flippedX() {
            return this.scaleX < 0
        }
        get flippedY() {
            return this.scaleY < 0
        }
        get flippedOne() {
            return this.scaleX * this.scaleY < 0
        }
        constructor(e) {
            super(),
            this.view = new t.Group,
            this.rect = new t.Box({
                name: "rect",
                hitFill: "all",
                hitStroke: "none",
                strokeAlign: "center",
                hitRadius: 5
            }),
            this.circle = new yp({
                name: "circle",
                strokeAlign: "center",
                around: "center",
                cursor: "crosshair",
                hitRadius: 5
            }),
            this.buttons = new t.Group({
                around: "center",
                hitSelf: !1
            }),
            this.resizePoints = [],
            this.rotatePoints = [],
            this.resizeLines = [],
            this.__eventIds = [],
            this.editor = e,
            this.visible = !1,
            this.create(),
            this.__listenEvents()
        }
        create() {
            let t, e, i;
            const {view: s, resizePoints: n, rotatePoints: o, resizeLines: r, rect: a, circle: h, buttons: l} = this
              , d = ["bottom-right", "bottom", "bottom-left", "left", "top-left", "top", "top-right", "right"];
            for (let s = 0; s < 8; s++)
                t = new yp({
                    name: "rotate-point",
                    around: d[s],
                    width: 15,
                    height: 15,
                    hitFill: "all"
                }),
                o.push(t),
                this.listenPointEvents(t, "rotate", s),
                s % 2 && (e = new yp({
                    name: "resize-line",
                    around: "center",
                    width: 10,
                    height: 10,
                    hitFill: "all"
                }),
                r.push(e),
                this.listenPointEvents(e, "resize", s)),
                i = new yp({
                    name: "resize-point",
                    hitRadius: 5
                }),
                n.push(i),
                this.listenPointEvents(i, "resize", s);
            this.listenPointEvents(h, "rotate", 2),
            s.addMany(...o, a, h, l, ...r, ...n),
            this.add(s)
        }
        load() {
            const {mergeConfig: t, element: e, single: i} = this.editor
              , {rect: s, circle: n, resizePoints: o} = this
              , {stroke: r, strokeWidth: a} = t
              , h = this.getPointsStyle()
              , l = this.getMiddlePointsStyle();
            let d;
            for (let t = 0; t < 8; t++)
                d = o[t],
                d.set(this.getPointStyle(t % 2 ? l[(t - 1) / 2 % l.length] : h[t / 2 % h.length])),
                t % 2 || (d.rotation = t / 2 * 90);
            n.set(this.getPointStyle(t.circle || t.rotatePoint || h[0])),
            s.set(Object.assign({
                stroke: r,
                strokeWidth: a
            }, t.rect || {})),
            s.hittable = !i,
            s.syncEventer = i && this.editor,
            i && (e.syncEventer = s,
            this.app.interaction.bottomList = [{
                target: s,
                proxy: e
            }])
        }
        update(t) {
            if (this.visible = !this.editor.element.locked,
            this.view.worldOpacity) {
                const {mergeConfig: e} = this.editor
                  , {width: i, height: s} = t
                  , {rect: n, circle: o, buttons: r, resizePoints: a, rotatePoints: h, resizeLines: l} = this
                  , {middlePoint: d, resizeable: c, rotateable: u, hideOnSmall: p} = e
                  , _ = "number" == typeof p ? p : 10
                  , g = !(p && i < _ && s < _);
                let f, y, m, v = {};
                for (let n = 0; n < 8; n++)
                    gt.toPoint(gt.directionData[n], t, v),
                    y = a[n],
                    f = h[n],
                    m = l[Math.floor(n / 2)],
                    y.set(v),
                    f.set(v),
                    m.set(v),
                    y.visible = m.visible = g && !(!c && !u),
                    f.visible = g && u && c && !e.rotatePoint,
                    n % 2 && (y.visible = f.visible = g && !!d,
                    (n + 1) / 2 % 2 ? (m.width = i,
                    y.width > i - 30 && (y.visible = !1)) : (m.height = s,
                    y.rotation = 90,
                    y.width > s - 30 && (y.visible = !1)));
                o.visible = g && u && !(!e.circle && !e.rotatePoint),
                o.visible && this.layoutCircle(e),
                n.path && (n.path = null),
                n.set(Object.assign(Object.assign({}, t), {
                    visible: !0
                })),
                r.visible = g && r.children.length > 0,
                r.visible && this.layoutButtons(e)
            }
        }
        layoutCircle(t) {
            const {circleDirection: e, circleMargin: i, buttonsMargin: s, buttonsDirection: n, middlePoint: o} = t
              , r = mp.indexOf(e || (this.buttons.children.length && "bottom" === n ? "top" : "bottom"));
            this.setButtonPosition(this.circle, r, i || s, !!o)
        }
        layoutButtons(t) {
            const {buttons: e} = this
              , {buttonsDirection: i, buttonsFixed: s, buttonsMargin: n, middlePoint: o} = t
              , {flippedX: r, flippedY: a} = this;
            let h = mp.indexOf(i);
            (h % 2 && r || (h + 1) % 2 && a) && s && (h = (h + 2) % 4);
            const l = s ? up.getRotateDirection(h, this.flippedOne ? this.rotation : -this.rotation, 4) : h;
            this.setButtonPosition(e, l, n, !!o),
            s && (e.rotation = 90 * (l - h)),
            e.scaleX = r ? -1 : 1,
            e.scaleY = a ? -1 : 1
        }
        setButtonPosition(t, e, i, s) {
            const n = this.resizePoints[2 * e + 1]
              , o = e % 2
              , r = e && 3 !== e ? 1 : -1
              , a = (i + (e % 2 ? (s ? n.width : 0) + t.boxBounds.width : (s ? n.height : 0) + t.boxBounds.height) / 2) * r;
            o ? (t.x = n.x + a,
            t.y = n.y) : (t.x = n.x,
            t.y = n.y + a)
        }
        unload() {
            this.visible = !1
        }
        getPointStyle(t) {
            const {stroke: e, strokeWidth: i, pointFill: s, pointSize: n, pointRadius: o} = this.editor.mergeConfig
              , r = {
                fill: s,
                stroke: e,
                strokeWidth: i,
                around: "center",
                strokeAlign: "center",
                width: n,
                height: n,
                cornerRadius: o,
                offsetX: 0,
                offsetY: 0
            };
            return t ? Object.assign(r, t) : r
        }
        getPointsStyle() {
            const {point: t} = this.editor.mergeConfig;
            return t instanceof Array ? t : [t]
        }
        getMiddlePointsStyle() {
            const {middlePoint: t} = this.editor.mergeConfig;
            return t instanceof Array ? t : t ? [t] : this.getPointsStyle()
        }
        onSelect(t) {
            1 === t.oldList.length && (t.oldList[0].syncEventer = null,
            this.app && (this.app.interaction.bottomList = null))
        }
        onDragStart(t) {
            this.dragging = !0;
            const {editor: e} = this;
            "rect" === t.current.name ? (this.moving = !0,
            e.dragStartPoint = {
                x: e.element.x,
                y: e.element.y
            },
            e.opacity = e.mergeConfig.hideOnMove ? 0 : 1) : "resize" === t.current.pointType && (e.dragStartBounds = Object.assign({}, e.element.getLayoutBounds("box", "local")),
            e.resizeDirection = t.current.direction)
        }
        onDragEnd(t) {
            this.dragging = !1,
            this.moving = !1,
            "rect" === t.current.name && (this.editor.opacity = 1),
            this.editor.resizeDirection = void 0
        }
        onDrag(t) {
            const {editor: e} = this
              , i = this.enterPoint = t.current;
            "rotate" === i.pointType || t.metaKey || t.ctrlKey || !e.mergeConfig.resizeable ? e.mergeConfig.rotateable && e.onRotate(t) : "resize" === i.pointType && e.onScale(t),
            _p(e, t)
        }
        onArrow(t) {
            if (this.editor.editing && this.editor.mergeConfig.keyEvent) {
                const e = {
                    x: 0,
                    y: 0
                }
                  , i = t.shiftKey ? 10 : 1;
                switch (t.code) {
                case "ArrowDown":
                    e.y = i;
                    break;
                case "ArrowUp":
                    e.y = -i;
                    break;
                case "ArrowLeft":
                    e.x = -i;
                    break;
                case "ArrowRight":
                    e.x = i
                }
                this.editor.move(e)
            }
        }
        onDoubleTap(t) {
            "double" === this.editor.mergeConfig.openInner && this.openInner(t)
        }
        onLongPress(t) {
            "long" === this.editor.mergeConfig.openInner && this.openInner(t)
        }
        openInner(e) {
            const {editor: i} = this;
            if (i.single) {
                const {element: s} = i;
                if (s.isBranch && !s.editInner) {
                    if (s.textBox) {
                        const {children: e} = s
                          , n = e.find((e => e.editable && e instanceof t.Text)) || e.find((e => e instanceof t.Text));
                        if (n)
                            return i.openInnerEditor(n)
                    }
                    i.openGroup(s),
                    i.target = i.selector.findDeepOne(e)
                } else
                    i.openInnerEditor()
            }
        }
        listenPointEvents(e, i, s) {
            const {editor: n} = this;
            e.direction = s,
            e.pointType = i,
            e.on_(t.DragEvent.START, this.onDragStart, this),
            e.on_(t.DragEvent.DRAG, this.onDrag, this),
            e.on_(t.DragEvent.END, this.onDragEnd, this),
            e.on_(t.PointerEvent.LEAVE, ( () => this.enterPoint = null)),
            "circle" !== e.name && e.on_(t.PointerEvent.ENTER, (t => {
                this.enterPoint = e,
                _p(n, t)
            }
            ))
        }
        __listenEvents() {
            const {rect: e, editor: i} = this;
            this.__eventIds = [i.on_(Mu.SELECT, this.onSelect, this), e.on_(t.DragEvent.START, this.onDragStart, this), e.on_(t.DragEvent.DRAG, i.onMove, i), e.on_(t.DragEvent.END, this.onDragEnd, this), e.on_(t.PointerEvent.ENTER, ( () => gp(i))), e.on_(t.PointerEvent.DOUBLE_TAP, this.onDoubleTap, this), e.on_(t.PointerEvent.LONG_PRESS, this.onLongPress, this)]
        }
        __removeListenEvents() {
            this.off_(this.__eventIds),
            this.__eventIds.length = 0
        }
        destroy() {
            this.editor = null,
            this.__removeListenEvents(),
            super.destroy()
        }
    }
    class wp extends t.UI {
        constructor(t) {
            super(),
            this.editor = t,
            this.hittable = !1
        }
        __draw(t, e) {
            const {editor: i} = this
              , {mask: s} = i.mergeConfig;
            if (s && i.list.length) {
                const {rect: n} = i.editBox
                  , {width: o, height: r} = n.__;
                t.resetTransform(),
                t.fillWorld(t.bounds, !0 === s ? "rgba(0,0,0,0.8)" : s),
                t.setWorld(n.__world, e.matrix),
                t.clearRect(0, 0, o, r)
            }
        }
        destroy() {
            this.editor = null,
            super.destroy()
        }
    }
    const xp = '\n<feOffset dy="1"/>\n<feGaussianBlur stdDeviation="1.5"/>\n<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>\n<feBlend mode="normal" in="SourceGraphic" result="shape"/>'
      , bp = {
        editSize: "size",
        keyEvent: !0,
        stroke: "#836DFF",
        strokeWidth: 2,
        pointFill: "#FFFFFF",
        pointSize: 10,
        pointRadius: 16,
        rotateGap: 45,
        buttonsDirection: "bottom",
        buttonsMargin: 12,
        hideOnSmall: !0,
        moveCursor: "move",
        resizeCursor: {
            url: `\n<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">\n<g filter="url(#f)">\n<g transform="rotate({{rotation}},12,12)">\n<path d="M7.5 8.0H8.5V5.9L6.8 7.2L7.5 8.0ZM3 11.4L2.3 10.6L1.3 11.4L2.3 12.2L3 11.4ZM7.5 10.4H6.5V11.4H7.5V10.4ZM16.5 10.4V11.4H17.5V10.4H16.5ZM16.5 8.0L17.1 7.2L15.5 5.9V8.0H16.5ZM21 11.4L21.6 12.2L22.6 11.4L21.6 10.6L21 11.4ZM16.5 14.9H15.5V16.9L17.1 15.7L16.5 14.9ZM16.5 12.4H17.5V11.4H16.5V12.4ZM7.5 12.4V11.4H6.5V12.4H7.5ZM7.5 14.9L6.8 15.7L8.5 16.9V14.9H7.5ZM6.8 7.2L2.3 10.6L3.6 12.2L8.1 8.7L6.8 7.2ZM8.5 10.4V8.0H6.5V10.4H8.5ZM16.5 9.4H7.5V11.4H16.5V9.4ZM17.5 10.4V8.0H15.5V10.4H17.5ZM15.8 8.7L20.3 12.2L21.6 10.6L17.1 7.2L15.8 8.7ZM20.3 10.6L15.8 14.1L17.1 15.7L21.6 12.2L20.3 10.6ZM17.5 14.9V12.4H15.5V14.9H17.5ZM7.5 13.4H16.5V11.4H7.5V13.4ZM8.5 14.9V12.4H6.5V14.9H8.5ZM2.3 12.2L6.8 15.7L8.1 14.1L3.6 10.6L2.3 12.2Z" fill="white"/>\n<path fill-rule="evenodd" d="M3 11.4L7.5 8.0V10.4H16.5V8.0L21 11.4L16.5 14.9V12.4H7.5V14.9L3 11.4Z" fill="black"/>\n</g>\n</g>\n<defs>\n<filter id="f" x="-1.6" y="3.9" width="27.2" height="16.9" filterUnits="userSpaceOnUse">\n${xp}\n</filter>\n</defs>\n</svg>\n`,
            x: 12,
            y: 12
        },
        rotateCursor: {
            url: `\n<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">\n<g filter="url(#f)">\n<g transform="rotate(135,12,12),rotate({{rotation}},12,12)">\n<path d="M20.4 8H21.4L20.8 7.1L17.3 2.6L17 2.1L16.6 2.6L13.1 7.1L12.5 8H13.5H15.4C14.9 11.8 11.8 14.9 8 15.4V13.5V12.5L7.1 13.1L2.6 16.6L2.1 17L2.6 17.3L7.1 20.8L8 21.4V20.4V18.4C13.5 17.9 17.9 13.5 18.4 8H20.4Z" stroke="white"/>\n<path fill-rule="evenodd" d="M17 3L20.4 7.5H17.9C17.7 13.1 13.1 17.7 7.5 17.9V20.4L3 17L7.5 13.5V15.9C12.0 15.7 15.7 12.0 15.9 7.5H13.5L17 3Z" fill="black"/>\n</g>\n</g>\n<defs>\n<filter id="f" x="-1.6" y="-0.6" width="27.1" height="27.1" filterUnits="userSpaceOnUse">\n${xp}\n</filter>\n</defs>\n</svg>\n`,
            x: 12,
            y: 12
        },
        skewCursor: {
            url: `\n<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">\n<g filter="url(#f)">\n<g transform="rotate(90,12,12),rotate({{rotation}},12,12)">\n<path d="M21 10.4L21 11.4L23.8 11.4L21.6 9.6L21 10.4ZM17 10.4V11.4L17 11.4L17 10.4ZM15.5 6L16.1 5.2L14.5 3.9V6H15.5ZM15.5 8.4V9.4H16.5V8.4H15.5ZM6 8.4V7.4H5V8.4H6ZM6 10.4H5V11.4H6V10.4ZM7 14.4V13.4L7 13.4L7 14.4ZM3 14.4L3 13.4L0.1 13.4L2.3 15.2L3 14.4ZM8.5 18.9L7.8 19.7L9.5 21.0V18.9H8.5ZM8.5 16.4V15.4H7.5V16.4H8.5ZM19 16.4V17.4H20V16.4H19ZM19 14.4H20V13.4H19V14.4ZM21 9.4L17 9.4L17 11.4L21 11.4L21 9.4ZM14.8 6.7L20.3 11.2L21.6 9.6L16.1 5.2L14.8 6.7ZM16.5 8.4V6H14.5V8.4H16.5ZM6 9.4H15.5V7.4H6V9.4ZM7 10.4V8.4H5V10.4H7ZM15.5 9.4H6V11.4H15.5V9.4ZM17 9.4H15.5V11.4H17V9.4ZM7 15.4H8.5V13.4H7V15.4ZM3 15.4L7 15.4L7 13.4L3 13.4L3 15.4ZM9.1 18.1L3.6 13.6L2.3 15.2L7.8 19.7L9.1 18.1ZM7.5 16.4V18.9H9.5V16.4H7.5ZM19 15.4H8.5V17.4H19V15.4ZM18 14.4V16.4H20V14.4H18ZM8.5 15.4H19V13.4H8.5V15.4Z" fill="white"/>\n<path fill-rule="evenodd" d="M17 10.4L21 10.4L15.5 6V8.4H6V10.4H15.5H17ZM8.5 14.4H7L3 14.4L8.5 18.9V16.4H19V14.4H8.5Z" fill="black"/>\n</g>\n</g>\n<defs>\n<filter x="-2.8" y="1.9" width="29.6" height="23.1" filterUnits="userSpaceOnUse" >\n${xp}\n</filter>\n</defs>\n</svg>\n`,
            x: 12,
            y: 12
        },
        selector: !0,
        hover: !0,
        select: "press",
        openInner: "double",
        boxSelect: !0,
        moveable: !0,
        resizeable: !0,
        flipable: !0,
        rotateable: !0,
        skewable: !0
    }
      , Ep = new lt;
    function kp(t) {
        const {simulateTarget: e, list: i} = t
          , {zoomLayer: s} = i[0].leafer.zoomLayer;
        e.safeChange(( () => e.reset(Ep.setListWithFn(i, (t => t.getBounds("box", "page"))).get()))),
        s.add(e)
    }
    const Tp = (t, e) => t.parent.children.indexOf(t) - e.parent.children.indexOf(e)
      , Bp = (t, e) => e.parent.children.indexOf(e) - t.parent.children.indexOf(t)
      , Lp = {
        group(e, i, s) {
            e.sort(Bp);
            const {app: n, parent: o} = e[0];
            let r;
            r = s && s.add ? s : new t.Group(s),
            o.addAt(r, o.children.indexOf(e[0])),
            e.sort(Tp);
            const a = new U(i.worldTransform);
            return a.divideParent(o.worldTransform),
            r.setTransform(a),
            r.editable = !0,
            r.hitChildren = !1,
            n.lockLayout(),
            e.forEach((t => t.dropTo(r))),
            n.unlockLayout(),
            r
        },
        ungroup(t) {
            const {app: e} = t[0]
              , i = [];
            return e.lockLayout(),
            t.forEach((t => {
                if (t.isBranch && !t.isBranchLeaf) {
                    const {parent: e, children: s} = t;
                    for (; s.length; )
                        i.push(s[0]),
                        s[0].dropTo(e, e.children.indexOf(t));
                    t.remove()
                } else
                    i.push(t)
            }
            )),
            e.unlockLayout(),
            i
        },
        toTop(t) {
            t.sort(Tp),
            t.forEach((t => {
                t.parent && t.parent.add(t)
            }
            ))
        },
        toBottom(t) {
            t.sort(Bp),
            t.forEach((t => {
                t.parent && t.parent.addAt(t, 0)
            }
            ))
        }
    }
      , Pp = wt.get("EditToolCreator");
    function Cp() {
        return t => {
            Sp.register(t)
        }
    }
    const Rp = Cp
      , Sp = {
        list: {},
        register(t) {
            const {tag: e} = t.prototype;
            Op[e] && Pp.repeat(e),
            Op[e] = t
        },
        get: (t, e) => new Op[t](e)
    }
      , {list: Op} = Sp;
    class Dp extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    Dp.BEFORE_OPEN = "innerEditor.before_open",
    Dp.OPEN = "innerEditor.open",
    Dp.BEFORE_CLOSE = "innerEditor.before_close",
    Dp.CLOSE = "innerEditor.close";
    class Mp extends Mu {
        constructor(t, e) {
            super(t, e)
        }
    }
    Mp.GROUP = "editor.group",
    Mp.BEFORE_UNGROUP = "editor.before_ungroup",
    Mp.UNGROUP = "editor.ungroup",
    Mp.OPEN = "editor.open_group",
    Mp.CLOSE = "editor.close_group";
    const {updateMatrix: Ip} = go
      , Ap = {
        x: 1,
        y: 1,
        scaleX: 1,
        scaleY: 1,
        rotation: 1,
        skewX: 1,
        skewY: 1
    }
      , Wp = "top-left";
    class zp extends t.Rect {
        get __tag() {
            return "SimulateElement"
        }
        constructor(t) {
            super(),
            this.checkChange = !0,
            this.canChange = !0,
            this.visible = this.hittable = !1,
            this.on(Ho.CHANGE, (e => {
                if (this.checkChange && Ap[e.attrName]) {
                    const {attrName: i, newValue: s, oldValue: n} = e
                      , o = "s" === i[0] ? (s || 1) / (n || 1) : (s || 0) - (n || 0);
                    this.canChange = !1;
                    const r = this.__;
                    r[i] = n,
                    Ip(this.parent),
                    Ip(this);
                    const a = new U(this.__world);
                    switch (r[i] = s,
                    this.__layout.rotationChange(),
                    Ip(this),
                    this.changedTransform = new U(this.__world).divide(a),
                    i) {
                    case "x":
                        t.move(o, 0);
                        break;
                    case "y":
                        t.move(0, o);
                        break;
                    case "rotation":
                        t.rotateOf(Wp, o);
                        break;
                    case "scaleX":
                        t.scaleOf(Wp, o, 1);
                        break;
                    case "scaleY":
                        t.scaleOf(Wp, 1, o);
                        break;
                    case "skewX":
                        t.skewOf(Wp, o, 0);
                        break;
                    case "skewY":
                        t.skewOf(Wp, 0, o)
                    }
                    this.canChange = !0
                }
            }
            ))
        }
        safeChange(t) {
            this.canChange && (this.checkChange = !1,
            t(),
            this.checkChange = !0)
        }
    }
    class Fp extends t.Group {
        get mergeConfig() {
            const {element: t, config: e} = this;
            return this.single && t.editConfig ? Object.assign(Object.assign({}, e), t.editConfig) : e
        }
        get list() {
            return this.leafList.list
        }
        get dragHoverExclude() {
            return [this.editBox.rect]
        }
        get editing() {
            return !!this.list.length
        }
        get groupOpening() {
            return !!this.openedGroupList.length
        }
        get multiple() {
            return this.list.length > 1
        }
        get single() {
            return 1 === this.list.length
        }
        get dragging() {
            return this.editBox.dragging
        }
        get moving() {
            return this.editBox.moving
        }
        get element() {
            return this.multiple ? this.simulateTarget : this.list[0]
        }
        get buttons() {
            return this.editBox.buttons
        }
        constructor(t, e) {
            super(e),
            this.config = Mt.clone(bp),
            this.leafList = new ra,
            this.openedGroupList = new ra,
            this.simulateTarget = new zp(this),
            this.editBox = new vp(this),
            this.editToolList = {},
            this.selector = new ep(this),
            this.editMask = new wp(this),
            this.targetEventIds = [],
            t && (this.config = Mt.default(t, this.config)),
            this.addMany(this.editMask, this.selector, this.editBox),
            Bt.check("resize", !0) || (this.config.editSize = "scale")
        }
        select(t) {
            this.target = t
        }
        cancel() {
            this.target = null
        }
        hasItem(t) {
            return this.leafList.has(t)
        }
        addItem(t) {
            this.hasItem(t) || t.locked || (this.leafList.add(t),
            this.target = this.leafList.list)
        }
        removeItem(t) {
            this.hasItem(t) && (this.leafList.remove(t),
            this.target = this.leafList.list)
        }
        shiftItem(t) {
            this.hasItem(t) ? this.removeItem(t) : this.addItem(t)
        }
        update() {
            this.editing && (this.innerEditing && this.innerEditor.update(),
            this.editTool.update(),
            this.selector.update())
        }
        updateEditBox() {
            this.multiple && kp(this),
            this.update()
        }
        updateEditTool() {
            const t = this.editTool;
            if (t && (this.editBox.unload(),
            t.unload(),
            this.editTool = null),
            this.editing) {
                const t = this.single ? this.list[0].editOuter : "EditTool";
                this.editTool = this.editToolList[t] = this.editToolList[t] || Sp.get(t, this),
                this.editBox.load(),
                this.editTool.load()
            }
        }
        getEditSize(t) {
            return this.mergeConfig.editSize
        }
        onMove(e) {
            if (e instanceof t.MoveEvent) {
                if ("drag" !== e.moveType) {
                    const {moveable: t, resizeable: i} = this.mergeConfig
                      , s = e.getLocalMove(this.element);
                    "move" === t ? (e.stop(),
                    this.move(s.x, s.y)) : "zoom" === i && e.stop()
                }
            } else {
                const i = {
                    x: e.totalX,
                    y: e.totalY
                };
                e.shiftKey && (Math.abs(i.x) > Math.abs(i.y) ? i.y = 0 : i.x = 0),
                this.move(t.DragEvent.getValidMove(this.element, this.dragStartPoint, i))
            }
        }
        onScale(e) {
            const {element: i} = this;
            let {around: s, lockRatio: n, resizeable: o, flipable: r, editSize: a} = this.mergeConfig;
            if (e instanceof t.ZoomEvent)
                "zoom" === o && (e.stop(),
                this.scaleOf(i.getBoxPoint(e), e.scale, e.scale));
            else {
                const {direction: t} = e.current;
                (e.shiftKey || i.lockRatio) && (n = !0);
                const o = up.getScaleData(i, this.dragStartBounds, t, e.getInnerTotal(i), n, up.getAround(s, e.altKey), r, this.multiple || "scale" === a);
                this.editTool.onScaleWithDrag ? (o.drag = e,
                this.scaleWithDrag(o)) : this.scaleOf(o.origin, o.scaleX, o.scaleY)
            }
        }
        onRotate(e) {
            const {skewable: i, rotateable: s, around: n, rotateGap: o} = this.mergeConfig
              , {direction: r, name: a} = e.current;
            if (i && "resize-line" === a)
                return this.onSkew(e);
            const {element: l} = this;
            let d, c;
            if (e instanceof t.RotateEvent) {
                if ("rotate" !== s)
                    return;
                e.stop(),
                c = e.rotation,
                d = l.getBoxPoint(e)
            } else {
                const t = {
                    x: e.x - e.moveX,
                    y: e.y - e.moveY
                }
                  , i = up.getRotateData(l.boxBounds, r, e.getBoxPoint(l), l.getBoxPoint(t), e.shiftKey ? null : l.around || l.origin || n || "center");
                c = i.rotation,
                d = i.origin
            }
            c = h.getGapRotation(c, o, l.rotation),
            c && (l.scaleX * l.scaleY < 0 && (c = -c),
            this.rotateOf(d, h.float(c, 2)))
        }
        onSkew(t) {
            const {element: e} = this
              , {around: i} = this.mergeConfig
              , {origin: s, skewX: n, skewY: o} = up.getSkewData(e.boxBounds, t.current.direction, t.getInnerMove(e), up.getAround(i, t.altKey));
            (n || o) && this.skewOf(s, n, o)
        }
        move(t, e=0) {
            if (!this.checkTransform("moveable"))
                return;
            const {element: i} = this
              , s = i.getWorldPointByLocal("object" == typeof t ? Object.assign({}, t) : {
                x: t,
                y: e
            }, null, !0);
            this.multiple && i.safeChange(( () => i.move(t, e)));
            const n = new Iu(Iu.MOVE,{
                target: i,
                editor: this,
                moveX: s.x,
                moveY: s.y
            });
            this.editTool.onMove(n),
            this.emitEvent(n)
        }
        scaleWithDrag(t) {
            if (!this.checkTransform("resizeable"))
                return;
            const {element: e} = this
              , i = new Au(Au.SCALE,Object.assign(Object.assign({}, t), {
                target: e,
                editor: this,
                worldOrigin: e.getWorldPoint(t.origin)
            }));
            this.editTool.onScaleWithDrag(i),
            this.emitEvent(i)
        }
        scaleOf(t, e, i=e, s) {
            if (!this.checkTransform("resizeable"))
                return;
            const {element: n} = this
              , o = this.getWorldOrigin(t)
              , r = this.multiple && this.getChangedTransform(( () => n.safeChange(( () => n.scaleOf(t, e, i)))))
              , a = new Au(Au.SCALE,{
                target: n,
                editor: this,
                worldOrigin: o,
                scaleX: e,
                scaleY: i,
                transform: r
            });
            this.editTool.onScale(a),
            this.emitEvent(a)
        }
        flip(t) {
            if (!this.checkTransform("resizeable"))
                return;
            const {element: e} = this
              , i = this.getWorldOrigin("center")
              , s = this.multiple ? this.getChangedTransform(( () => e.safeChange(( () => e.flip(t))))) : new U(go.getFlipTransform(e, t))
              , n = new Au(Au.SCALE,{
                target: e,
                editor: this,
                worldOrigin: i,
                scaleX: "x" === t ? -1 : 1,
                scaleY: "y" === t ? -1 : 1,
                transform: s
            });
            this.editTool.onScale(n),
            this.emitEvent(n)
        }
        rotateOf(t, e) {
            if (!this.checkTransform("rotateable"))
                return;
            const {element: i} = this
              , s = this.getWorldOrigin(t)
              , n = this.multiple && this.getChangedTransform(( () => i.safeChange(( () => i.rotateOf(t, e)))))
              , o = new Wu(Wu.ROTATE,{
                target: i,
                editor: this,
                worldOrigin: s,
                rotation: e,
                transform: n
            });
            this.editTool.onRotate(o),
            this.emitEvent(o)
        }
        skewOf(t, e, i=0, s) {
            if (!this.checkTransform("skewable"))
                return;
            const {element: n} = this
              , o = this.getWorldOrigin(t)
              , r = this.multiple && this.getChangedTransform(( () => n.safeChange(( () => n.skewOf(t, e, i)))))
              , a = new zu(zu.SKEW,{
                target: n,
                editor: this,
                worldOrigin: o,
                skewX: e,
                skewY: i,
                transform: r
            });
            this.editTool.onSkew(a),
            this.emitEvent(a)
        }
        checkTransform(t) {
            return this.element && !this.element.locked && this.mergeConfig[t]
        }
        getWorldOrigin(t) {
            return this.element.getWorldPoint(go.getInnerOrigin(this.element, t))
        }
        getChangedTransform(t) {
            const {element: e} = this;
            if (this.multiple && !e.canChange)
                return e.changedTransform;
            const i = new U(e.worldTransform);
            return t(),
            new U(e.worldTransform).divide(i)
        }
        group(t) {
            return this.multiple && (this.target = Lp.group(this.list, this.element, t),
            this.emitGroupEvent(Mp.GROUP, this.target)),
            this.target
        }
        ungroup() {
            const {list: t} = this;
            return t.length && (t.forEach((t => t.isBranch && this.emitGroupEvent(Mp.BEFORE_UNGROUP, t))),
            this.target = Lp.ungroup(t),
            t.forEach((t => t.isBranch && this.emitGroupEvent(Mp.UNGROUP, t)))),
            this.list
        }
        openGroup(t) {
            this.openedGroupList.add(t),
            t.hitChildren = !0,
            this.emitGroupEvent(Mp.OPEN, t)
        }
        closeGroup(t) {
            this.openedGroupList.remove(t),
            t.hitChildren = !1,
            this.emitGroupEvent(Mp.CLOSE, t)
        }
        checkOpenedGroups() {
            const t = this.openedGroupList;
            if (t.length) {
                let {list: e} = t;
                this.editing && (e = [],
                t.forEach((t => this.list.every((e => !go.hasParent(e, t))) && e.push(t)))),
                e.forEach((t => this.closeGroup(t)))
            }
            this.editing && !this.selector.dragging && this.checkDeepSelect()
        }
        checkDeepSelect() {
            let t, {list: e} = this;
            for (let i = 0; i < e.length; i++)
                for (t = e[i].parent; t && !t.hitChildren; )
                    this.openGroup(t),
                    t = t.parent
        }
        emitGroupEvent(t, e) {
            const i = new Mp(t,{
                editTarget: e
            });
            this.emitEvent(i),
            e.emitEvent(i)
        }
        openInnerEditor(t, e) {
            if (t && e && (this.target = t),
            this.single) {
                const e = t || this.element
                  , i = e.editInner;
                i && Sp.list[i] && (this.editTool.unload(),
                this.innerEditing = !0,
                this.innerEditor = this.editToolList[i] || Sp.get(i, this),
                this.innerEditor.editTarget = e,
                this.emitInnerEvent(Dp.BEFORE_OPEN),
                this.innerEditor.load(),
                this.emitInnerEvent(Dp.OPEN))
            }
        }
        closeInnerEditor() {
            this.innerEditing && (this.innerEditing = !1,
            this.emitInnerEvent(Dp.BEFORE_CLOSE),
            this.innerEditor.unload(),
            this.emitInnerEvent(Dp.CLOSE),
            this.editTool.load(),
            this.innerEditor = null)
        }
        emitInnerEvent(t) {
            const {innerEditor: e} = this
              , {editTarget: i} = e
              , s = new Dp(t,{
                editTarget: i,
                innerEditor: e
            });
            this.emitEvent(s),
            i.emitEvent(s)
        }
        lock() {
            this.list.forEach((t => t.locked = !0)),
            this.update()
        }
        unlock() {
            this.list.forEach((t => t.locked = !1)),
            this.update()
        }
        toTop() {
            this.list.length && (Lp.toTop(this.list),
            this.leafList.update())
        }
        toBottom() {
            this.list.length && (Lp.toBottom(this.list),
            this.leafList.update())
        }
        listenTargetEvents() {
            if (!this.targetEventIds.length) {
                const {app: e, leafer: i} = this;
                this.targetEventIds = [i.on_(jo.START, this.update, this), e.on_(jo.CHILD_START, this.forceRender, this), e.on_(t.MoveEvent.BEFORE_MOVE, this.onMove, this, !0), e.on_(t.ZoomEvent.BEFORE_ZOOM, this.onScale, this, !0), e.on_(t.RotateEvent.BEFORE_ROTATE, this.onRotate, this, !0), e.on_([t.KeyEvent.HOLD, t.KeyEvent.UP], (t => {
                    _p(this, t)
                }
                )), e.on_(t.KeyEvent.DOWN, this.editBox.onArrow, this.editBox)]
            }
        }
        removeTargetEvents() {
            const {targetEventIds: t} = this;
            t.length && (this.off_(t),
            t.length = 0)
        }
        destroy() {
            this.destroyed || (this.target = this.hoverTarget = null,
            Object.values(this.editToolList).forEach((t => t.destroy())),
            this.simulateTarget.destroy(),
            this.editToolList = {},
            this.simulateTarget = this.editTool = this.innerEditor = null,
            super.destroy())
        }
    }
    zt([Fu((function(t, e) {
        t.emitEvent(new Mu(Mu.HOVER,{
            editor: t,
            value: t.hoverTarget,
            oldValue: e
        }))
    }
    ))], Fp.prototype, "hoverTarget", void 0),
    zt([Fu((function(t, e) {
        const {target: i} = t;
        i ? t.leafList = i instanceof ra ? i : new ra(i) : (t.simulateTarget.remove(),
        t.leafList.reset(),
        t.closeInnerEditor()),
        t.emitEvent(new Mu(Mu.SELECT,{
            editor: t,
            value: i,
            oldValue: e
        })),
        t.checkOpenedGroups(),
        t.editing ? t.waitLeafer(( () => {
            t.multiple && kp(t),
            gp(t),
            t.updateEditTool(),
            t.update(),
            t.listenTargetEvents()
        }
        )) : (t.updateEditTool(),
        t.removeTargetEvents())
    }
    ))], Fp.prototype, "target", void 0);
    class Up {
        static registerInnerEditor() {
            Sp.register(this)
        }
        get tag() {
            return "InnerEditor"
        }
        get editBox() {
            return this.editor.editBox
        }
        constructor(t) {
            this.editor = t,
            this.create()
        }
        onCreate() {}
        create() {
            this.view = new t.Group,
            this.onCreate()
        }
        onLoad() {}
        load() {
            const {editor: t} = this;
            t && (t.app && (t.selector.hittable = t.app.tree.hitChildren = !1),
            this.onLoad())
        }
        onUpdate() {}
        update() {
            this.onUpdate()
        }
        onUnload() {}
        unload() {
            const {editor: t} = this;
            t && (t.app && (t.selector.hittable = t.app.tree.hitChildren = !0),
            this.onUnload())
        }
        onDestroy() {}
        destroy() {
            this.onDestroy(),
            this.editor && (this.view && this.view.destroy(),
            this.eventIds && this.editor.off_(this.eventIds),
            this.editor = this.view = this.eventIds = null)
        }
    }
    t.EditTool = class extends Up {
        static registerEditTool() {
            Sp.register(this)
        }
        get tag() {
            return "EditTool"
        }
        onMove(t) {
            const {moveX: e, moveY: i, editor: s} = t
              , {app: n, list: o} = s;
            n.lockLayout(),
            o.forEach((t => {
                t.moveWorld(e, i)
            }
            )),
            n.unlockLayout()
        }
        onScale(t) {
            const {scaleX: e, scaleY: i, transform: s, worldOrigin: n, editor: o} = t
              , {app: r, list: a} = o;
            r.lockLayout(),
            a.forEach((t => {
                const r = "scale" !== o.getEditSize(t);
                s ? t.transformWorld(s, r) : t.scaleOfWorld(n, e, i, r)
            }
            )),
            r.unlockLayout()
        }
        onRotate(t) {
            const {rotation: e, transform: i, worldOrigin: s, editor: n} = t
              , {app: o, list: r} = n;
            o.lockLayout(),
            r.forEach((t => {
                const o = "scale" !== n.getEditSize(t);
                i ? t.transformWorld(i, o) : t.rotateOfWorld(s, e)
            }
            )),
            o.unlockLayout()
        }
        onSkew(t) {
            const {skewX: e, skewY: i, transform: s, worldOrigin: n, editor: o} = t
              , {app: r, list: a} = o;
            r.lockLayout(),
            a.forEach((t => {
                const r = "scale" !== o.getEditSize(t);
                s ? t.transformWorld(s, r) : t.skewOfWorld(n, e, i, r)
            }
            )),
            r.unlockLayout()
        }
        load() {
            this.editBox.view.visible = !0,
            this.onLoad()
        }
        update() {
            const {editor: t, editBox: e} = this
              , {x: i, y: s, scaleX: n, scaleY: o, rotation: r, skewX: a, skewY: h, width: l, height: d} = t.element.getLayoutBounds("box", t, !0);
            e.set({
                x: i,
                y: s,
                scaleX: n,
                scaleY: o,
                rotation: r,
                skewX: a,
                skewY: h
            }),
            e.update({
                x: 0,
                y: 0,
                width: l,
                height: d
            }),
            this.onUpdate()
        }
        unload() {
            this.editBox.view.visible = !1,
            this.onUnload()
        }
    }
    ,
    t.EditTool = zt([Cp()], t.EditTool);
    const {left: Hp, right: Np} = t.Direction9
      , {move: Yp, copy: Xp, toNumberPoints: Vp} = D;
    t.LineEditTool = class extends t.EditTool {
        constructor() {
            super(...arguments),
            this.scaleOfEvent = !0
        }
        get tag() {
            return "LineEditTool"
        }
        onScaleWithDrag(t) {
            const {drag: e, direction: i, lockRatio: s, around: n} = t
              , o = t.target
              , r = i === Hp;
            if (o.pathInputed) {
                const {path: t} = o.__
                  , {from: i, to: a} = this.getFromToByPath(t);
                this.dragPoint(i, a, r, n, this.getInnerMove(o, e, s)),
                t[1] = i.x,
                t[2] = i.y,
                t[4] = a.x,
                t[5] = a.y,
                o.path = t
            } else if (o.points) {
                const {points: t} = o
                  , {from: i, to: a} = this.getFromToByPoints(t);
                this.dragPoint(i, a, r, n, this.getInnerMove(o, e, s)),
                t[0] = i.x,
                t[1] = i.y,
                t[2] = a.x,
                t[3] = a.y,
                o.points = t
            } else {
                const t = {
                    x: 0,
                    y: 0
                }
                  , {toPoint: i} = o;
                o.rotation = 0,
                this.dragPoint(t, i, r, n, this.getInnerMove(o, e, s)),
                o.getLocalPointByInner(t, null, null, !0),
                o.getLocalPointByInner(i, null, null, !0),
                o.x = t.x,
                o.y = t.y,
                o.getInnerPointByLocal(i, null, null, !0),
                o.toPoint = i
            }
        }
        getInnerMove(t, e, i) {
            const s = e.getInnerMove(t);
            return i && (Math.abs(s.x) > Math.abs(s.y) ? s.y = 0 : s.x = 0),
            s
        }
        getFromToByPath(t) {
            return {
                from: {
                    x: t[1],
                    y: t[2]
                },
                to: {
                    x: t[4],
                    y: t[5]
                }
            }
        }
        getFromToByPoints(t) {
            const e = Vp(t);
            return {
                from: {
                    x: e[0],
                    y: e[1]
                },
                to: {
                    x: e[2],
                    y: e[3]
                }
            }
        }
        dragPoint(t, e, i, s, n) {
            const {x: o, y: r} = n;
            i ? (Yp(t, o, r),
            s && Yp(e, -o, -r)) : (s && Yp(t, -o, -r),
            Yp(e, o, r))
        }
        onSkew(t) {}
        onUpdate() {
            const {editBox: t} = this
              , {rotatePoints: e, resizeLines: i, resizePoints: s, rect: n} = t
              , o = this.editor.element;
            let r, a;
            if (o.pathInputed ? r = this.getFromToByPath(o.__.path) : o.points && (r = this.getFromToByPoints(o.__.points)),
            r) {
                const {from: i, to: a} = r;
                o.innerToWorld(i, i, !1, t),
                o.innerToWorld(a, a, !1, t),
                n.pen.clearPath().moveTo(i.x, i.y).lineTo(a.x, a.y),
                Xp(s[7], i),
                Xp(e[7], i),
                Xp(s[3], a),
                Xp(e[3], a)
            }
            for (let t = 0; t < 8; t++)
                t < 4 && (i[t].visible = !1),
                a = t === Hp || t === Np,
                s[t].visible = a,
                e[t].visible = !r && a
        }
    }
    ,
    t.LineEditTool = zt([Cp()], t.LineEditTool);
    const {M: jp, L: Gp, C: Zp, Q: Kp, Z: qp, N: Jp, D: $p, X: Qp, G: t_, F: e_, O: i_, P: s_, U: n_} = Jt
      , o_ = {
        scale(t, e, i) {
            if (!t)
                return;
            let s, n = 0, o = t.length;
            for (; n < o; )
                switch (s = t[n],
                s) {
                case jp:
                case Gp:
                    r_(t, e, i, n, 1),
                    n += 3;
                    break;
                case Zp:
                    r_(t, e, i, n, 3),
                    n += 7;
                    break;
                case Kp:
                    r_(t, e, i, n, 2),
                    n += 5;
                    break;
                case qp:
                    n += 1;
                    break;
                case Jp:
                    r_(t, e, i, n, 2),
                    n += 5;
                    break;
                case $p:
                    r_(t, e, i, n, 2),
                    n += 9;
                    break;
                case Qp:
                    r_(t, e, i, n, 2),
                    n += 6;
                    break;
                case t_:
                    r_(t, e, i, n, 2),
                    n += 9;
                    break;
                case e_:
                    r_(t, e, i, n, 2),
                    n += 5;
                    break;
                case i_:
                    t[n] = t_,
                    t.splice(n + 4, 0, t[n + 3], 0),
                    r_(t, e, i, n, 2),
                    n += 9,
                    o += 2;
                    break;
                case s_:
                    t[n] = e_,
                    t.splice(n + 4, 0, t[n + 3]),
                    r_(t, e, i, n, 2),
                    n += 5,
                    o += 1;
                    break;
                case n_:
                    r_(t, e, i, n, 2),
                    n += 6
                }
        },
        scalePoints(t, e, i, s, n) {
            for (let o = n ? s + 1 : 0, r = n ? o + 2 * n : t.length; o < r; o += 2)
                t[o] *= e,
                t[o + 1] *= i
        }
    }
      , {scalePoints: r_} = o_
      , a_ = b.get()
      , {topLeft: h_, top: l_, topRight: d_, right: c_, bottom: u_, left: p_} = t.Direction9;
    function __(t, e, i) {
        t.pathInputed ? g_(t, e, i) : (1 !== e && (t.width *= e),
        1 !== i && (t.height *= i))
    }
    function g_(t, e, i) {
        o_.scale(t.__.path, e, i),
        t.path = t.__.path
    }
    function f_(t, e, i) {
        const {points: s} = t;
        "object" == typeof s[0] ? s.forEach((t => {
            t.x *= e,
            t.y *= i
        }
        )) : o_.scalePoints(s, e, i),
        t.points = s
    }
    function y_(t, e, i) {
        const {children: s} = t;
        for (let t = 0; t < s.length; t++)
            a_.a = e,
            a_.d = i,
            s[t].transform(a_, !0)
    }
    const m_ = t.Leaf.prototype;
    function v_(e, i, s) {
        w_(e.parentApp ? e.parentApp : e, i),
        e.isApp || s || e.__eventIds.push(e.on_(t.MoveEvent.BEFORE_MOVE, (t => {
            e.zoomLayer.move(e.getValidMove(t.moveX, t.moveY))
        }
        )), e.on_(t.ZoomEvent.BEFORE_ZOOM, (t => {
            const {zoomLayer: i} = e
              , s = e.getValidScale(t.scale);
            1 !== s && (D.scaleOf(i, t, s),
            i.scale = i.__.scaleX * s)
        }
        )))
    }
    function w_(t, e) {
        e && Mt.assign(t.config, e),
        Mt.assign(t.config, {
            wheel: {
                preventDefault: !0
            },
            touch: {
                preventDefault: !0
            },
            pointer: {
                preventDefaultMenu: !0
            }
        }, t.userConfig)
    }
    m_.scaleResize = function(t, e=t, i) {
        const s = this;
        i || s.editConfig && "scale" === s.editConfig.editSize ? (s.scaleX *= t,
        s.scaleY *= e) : (t < 0 && (s.scaleX *= -1,
        t = -t),
        e < 0 && (s.scaleY *= -1,
        e = -e),
        this.__scaleResize(t, e))
    }
    ,
    m_.__scaleResize = function(t, e) {
        __(this, t, e)
    }
    ,
    m_.resizeWidth = function(t) {
        const e = t / this.getBounds("box", "local").width;
        this.scaleOf(this.__layout.boxBounds, e, this.__.lockRatio ? e : 1, !0)
    }
    ,
    m_.resizeHeight = function(t) {
        const e = t / this.getBounds("box", "local").height;
        this.scaleOf(this.__layout.boxBounds, this.__.lockRatio ? e : 1, e, !0)
    }
    ,
    t.Text.prototype.__scaleResize = function(t, e) {
        this.__.resizeFontSize || this.editConfig && "font-size" === this.editConfig.editSize ? function(t, e, i) {
            const {app: s} = t
              , n = s && s.editor;
            let o = e;
            if (n.editing) {
                const s = t.__layout;
                let {width: r, height: a} = s.boxBounds;
                switch (r *= i - e,
                a *= e - i,
                n.resizeDirection) {
                case l_:
                case u_:
                    o = i,
                    s.affectScaleOrRotation ? t.moveInner(-r / 2, 0) : t.x -= r / 2;
                    break;
                case p_:
                case c_:
                    s.affectScaleOrRotation ? t.moveInner(0, -a / 2) : t.y -= a / 2;
                    break;
                case h_:
                case d_:
                    s.affectScaleOrRotation ? t.moveInner(0, -a) : t.y -= a
                }
            }
            t.fontSize *= o;
            const r = t.__;
            r.__autoWidth || (t.width *= o),
            r.__autoHeight || (t.height *= o)
        }(this, t, e) : __(this, t, e)
    }
    ,
    t.Path.prototype.__scaleResize = function(t, e) {
        g_(this, t, e)
    }
    ,
    t.Line.prototype.__scaleResize = function(t, e) {
        this.pathInputed ? g_(this, t, e) : this.points ? f_(this, t, e) : this.width *= t
    }
    ,
    t.Polygon.prototype.__scaleResize = function(t, e) {
        this.pathInputed ? g_(this, t, e) : this.points ? f_(this, t, e) : __(this, t, e)
    }
    ,
    t.Group.prototype.__scaleResize = function(t, e) {
        y_(this, t, e)
    }
    ,
    t.Box.prototype.__scaleResize = function(t, e) {
        this.__.__autoSize && this.children.length ? y_(this, t, e) : (__(this, t, e),
        this.__.resizeChildren && y_(this, t, e))
    }
    ,
    Bt.add("resize"),
    Bt.add("editor"),
    i.editor = function(t) {
        return new Fp(t)
    }
    ,
    En(!1)(t.Box.prototype, "textBox"),
    mn(t.UI.prototype, "editOuter", {
        get() {
            return this.__.__isLinePath ? "LineEditTool" : "EditTool"
        }
    }),
    mn(t.UI.prototype, "editInner", {
        get: () => "PathEditor"
    }),
    mn(t.Group.prototype, "editInner", {
        get: () => ""
    }),
    mn(t.Text.prototype, "editInner", {
        get: () => "TextEditor"
    }),
    t.UI.setEditConfig = function(t) {
        mn(this.prototype, "editConfig", {
            get() {
                return "function" == typeof t ? t(this) : t
            }
        })
    }
    ,
    t.UI.setEditOuter = function(t) {
        mn(this.prototype, "editOuter", {
            get() {
                return "string" == typeof t ? t : t(this)
            }
        })
    }
    ,
    t.UI.setEditInner = function(t) {
        mn(this.prototype, "editInner", {
            get() {
                return "string" == typeof t ? t : t(this)
            }
        })
    }
    ;
    const x_ = wt.get("LeaferTypeCreator")
      , b_ = {
        list: {},
        register(t, e) {
            E_[t] && x_.repeat(t),
            E_[t] = e
        },
        run(t, e) {
            const i = E_[t];
            i && i(e)
        }
    }
      , {list: E_, register: k_} = b_;
    k_("viewport", v_),
    k_("custom", (function(t) {
        v_(t, null, !0)
    }
    )),
    k_("design", (function(t) {
        v_(t, {
            zoom: {
                min: .01,
                max: 256
            },
            move: {
                holdSpaceKey: !0,
                holdMiddleKey: !0
            }
        })
    }
    )),
    k_("document", (function(t) {
        v_(t, {
            zoom: {
                min: 1
            },
            move: {
                scroll: "limit"
            }
        })
    }
    ));
    const T_ = {
        getData(t) {
            const e = t[0]
              , i = t[1]
              , s = D.getCenter(e.from, i.from)
              , n = D.getCenter(e.to, i.to)
              , o = {
                x: n.x - s.x,
                y: n.y - s.y
            }
              , r = D.getDistance(e.from, i.from);
            return {
                move: o,
                scale: D.getDistance(e.to, i.to) / r,
                rotation: D.getRotation(e.from, i.from, e.to, i.to),
                center: n
            }
        }
    }
      , B_ = {
        getMove(t, e) {
            let {moveSpeed: i} = e
              , {deltaX: s, deltaY: n} = t;
            return t.shiftKey && !s && (s = n,
            n = 0),
            s > 50 && (s = Math.max(50, s / 3)),
            n > 50 && (n = Math.max(50, n / 3)),
            {
                x: -s * i * 2,
                y: -n * i * 2
            }
        },
        getScale(t, i) {
            let s, n = 1, {zoomMode: o, zoomSpeed: r} = i;
            const a = t.deltaY || t.deltaX;
            if (o ? (s = "mouse" === o || !t.deltaX && (e.intWheelDeltaY ? Math.abs(a) > 17 : Math.ceil(a) !== a),
            (t.shiftKey || t.metaKey || t.ctrlKey) && (s = !0)) : s = !t.shiftKey && (t.metaKey || t.ctrlKey),
            s) {
                r = h.within(r, 0, 1);
                n = 1 - a / (4 * (t.deltaY ? i.delta.y : i.delta.x)) * r,
                n < .5 && (n = .5),
                n >= 1.5 && (n = 1.5)
            }
            return n
        }
    };
    class L_ {
        get transforming() {
            return !!(this.moveData || this.zoomData || this.rotateData)
        }
        constructor(t) {
            this.interaction = t
        }
        move(e) {
            const {interaction: i} = this;
            e.moveType || (e.moveType = "move"),
            this.moveData || (this.setPath(e),
            this.moveData = Object.assign(Object.assign({}, e), {
                moveX: 0,
                moveY: 0
            }),
            i.emit(t.MoveEvent.START, this.moveData)),
            e.path = this.moveData.path,
            i.emit(t.MoveEvent.BEFORE_MOVE, e),
            i.emit(t.MoveEvent.MOVE, e),
            this.transformEndWait()
        }
        zoom(e) {
            const {interaction: i} = this;
            this.zoomData || (this.setPath(e),
            this.zoomData = Object.assign(Object.assign({}, e), {
                scale: 1
            }),
            i.emit(t.ZoomEvent.START, this.zoomData)),
            e.path = this.zoomData.path,
            i.emit(t.ZoomEvent.BEFORE_ZOOM, e),
            i.emit(t.ZoomEvent.ZOOM, e),
            this.transformEndWait()
        }
        rotate(e) {
            const {interaction: i} = this;
            this.rotateData || (this.setPath(e),
            this.rotateData = Object.assign(Object.assign({}, e), {
                rotation: 0
            }),
            i.emit(t.RotateEvent.START, this.rotateData)),
            e.path = this.rotateData.path,
            i.emit(t.RotateEvent.BEFORE_ROTATE, e),
            i.emit(t.RotateEvent.ROTATE, e),
            this.transformEndWait()
        }
        setPath(t) {
            const {interaction: e} = this
              , {path: i} = e.selector.getByPoint(t, e.hitRadius);
            t.path = i,
            e.cancelHover()
        }
        transformEndWait() {
            clearTimeout(this.transformTimer),
            this.transformTimer = setTimeout(( () => {
                this.transformEnd()
            }
            ), this.interaction.p.transformTime)
        }
        transformEnd() {
            const {interaction: e, moveData: i, zoomData: s, rotateData: n} = this;
            i && e.emit(t.MoveEvent.END, i),
            s && e.emit(t.ZoomEvent.END, s),
            n && e.emit(t.RotateEvent.END, n),
            this.reset()
        }
        reset() {
            this.zoomData = this.moveData = this.rotateData = null
        }
        destroy() {
            this.reset()
        }
    }
    const P_ = t.Leafer.prototype
      , C_ = new lt;
    function R_(t, e) {
        return Object.assign(Object.assign({}, e), {
            moveX: t.x,
            moveY: t.y
        })
    }
    function S_(t, e) {
        return Object.assign(Object.assign({}, e), {
            scale: t
        })
    }
    P_.initType = function(t) {
        b_.run(t, this)
    }
    ,
    P_.getValidMove = function(t, e) {
        const {scroll: i, disabled: s} = this.app.config.move;
        if (i) {
            const s = !0 === i ? "" : i;
            if (s.includes("x") ? (t = t || e,
            e = 0) : s.includes("y") ? (e = e || t,
            t = 0) : Math.abs(t) > Math.abs(e) ? e = 0 : t = 0,
            s.includes("limit")) {
                const {x: i, y: s, width: n, height: o} = C_.set(this.__world).addPoint(this.zoomLayer)
                  , r = i + n - this.width
                  , a = s + o - this.height;
                i >= 0 && r <= 0 ? t = 0 : t > 0 ? i + t > 0 && (t = -i) : t < 0 && r + t < 0 && (t = -r),
                s >= 0 && a <= 0 ? e = 0 : e > 0 ? s + e > 0 && (e = -s) : e < 0 && a + e < 0 && (e = -a)
            }
        }
        return {
            x: s ? 0 : t,
            y: s ? 0 : e
        }
    }
    ,
    P_.getValidScale = function(t) {
        const {scaleX: e} = this.zoomLayer.__
          , {min: i, max: s, disabled: n} = this.app.config.zoom
          , o = Math.abs(e * t);
        return i && o < i ? t = i / e : s && o > s && (t = s / e),
        n ? 1 : h.float(t)
    }
    ;
    const O_ = Sl.prototype;
    O_.createTransformer = function() {
        this.transformer = new L_(this)
    }
    ,
    O_.move = function(t) {
        this.transformer.move(t)
    }
    ,
    O_.zoom = function(t) {
        this.transformer.zoom(t)
    }
    ,
    O_.rotate = function(t) {
        this.transformer.rotate(t)
    }
    ,
    O_.transformEnd = function() {
        this.transformer.transformEnd()
    }
    ,
    O_.wheel = function(t) {
        const {wheel: e} = this.config;
        if (e.disabled)
            return;
        const i = e.getScale ? e.getScale(t, e) : B_.getScale(t, e);
        1 !== i ? this.zoom(S_(i, t)) : this.move(R_(e.getMove ? e.getMove(t, e) : B_.getMove(t, e), t))
    }
    ,
    O_.multiTouch = function(t, e) {
        if (this.config.multiTouch.disabled)
            return;
        const {move: i, rotation: s, scale: n, center: o} = T_.getData(e);
        Object.assign(t, o),
        this.rotate(function(t, e) {
            return Object.assign(Object.assign({}, e), {
                rotation: t
            })
        }(s, t)),
        this.zoom(S_(n, t)),
        this.move(R_(i, t))
    }
    ;
    const D_ = xl.prototype
      , {abs: M_} = Math;
    function I_(t, e) {
        let i = 1;
        const s = "out" === e
          , n = Math.abs(t);
        if (n > 1) {
            for (; s ? i < n : i <= n; )
                i *= 2;
            s && (i /= 2)
        } else {
            for (; s ? i >= n : i > n; )
                i /= 2;
            s || (i *= 2)
        }
        return i / t
    }
    D_.checkDragEndAnimate = function(t, e) {
        const {moveX: i, moveY: s} = this.dragData
          , n = M_(i)
          , o = M_(s)
          , r = e ? 1 : .1
          , a = this.interaction.m.dragAnimate && this.canAnimate && this.moving && (n > r || o > r);
        if (a) {
            const r = "touch" === t.pointerType ? 3 : 1
              , a = 70;
            n * (e = e ? .95 : r) > a ? e = a / n : o * e > a && (e = a / o),
            t = Object.assign({}, t),
            D.move(t, i * e, s * e),
            this.drag(t),
            this.animate(( () => {
                this.dragEnd(t, 1)
            }
            ))
        }
        return a
    }
    ,
    D_.animate = function(t, e) {
        const i = t || this.animateWait;
        i && this.interaction.target.nextRender(i, null, e),
        this.animateWait = t
    }
    ,
    D_.checkDragOut = function(t) {
        const {interaction: e} = this;
        this.autoMoveCancel(),
        this.dragging && !e.shrinkCanvasBounds.hitPoint(t) && this.autoMoveOnDragOut(t)
    }
    ,
    D_.autoMoveOnDragOut = function(t) {
        const {interaction: e, downData: i, canDragOut: s} = this
          , {autoDistance: n, dragOut: o} = e.m;
        if (!o || !s || !n)
            return;
        const r = e.shrinkCanvasBounds
          , {x: a, y: h} = r
          , l = ot.maxX(r)
          , d = ot.maxY(r)
          , c = t.x < a ? n : l < t.x ? -n : 0
          , u = t.y < h ? n : d < t.y ? -n : 0;
        let p = 0
          , _ = 0;
        this.autoMoveTimer = setInterval(( () => {
            p += c,
            _ += u,
            D.move(i, c, u),
            D.move(this.dragData, c, u),
            e.move(Object.assign(Object.assign({}, t), {
                moveX: c,
                moveY: u,
                totalX: p,
                totalY: _,
                moveType: "drag"
            })),
            e.pointerMoveReal(t)
        }
        ), 10)
    }
    ,
    D_.autoMoveCancel = function() {
        this.autoMoveTimer && (clearInterval(this.autoMoveTimer),
        this.autoMoveTimer = 0)
    }
    ,
    Bt.add("viewport"),
    Bt.add("view"),
    t.Leafer.prototype.zoom = function(t, e, i) {
        const {zoomLayer: s} = this
          , n = this.canvas.bounds.clone().shrink(void 0 !== e ? e : 30)
          , o = new lt
          , r = {
            x: n.x + n.width / 2,
            y: n.y + n.height / 2
        };
        let a;
        const {scaleX: h} = this.__;
        if ("string" == typeof t)
            switch (t) {
            case "in":
                a = I_(h, "in");
                break;
            case "out":
                a = I_(h, "out");
                break;
            case "fit":
                t = this.boxBounds;
                break;
            case "fit-width":
                (t = new lt(this.boxBounds)).height = 0;
                break;
            case "fit-height":
                (t = new lt(this.boxBounds)).width = 0
            }
        else
            "number" == typeof t && (a = t / h);
        if (a)
            1 !== a && s.scaleOfWorld(r, this.getValidScale(a));
        else if ("object" == typeof t) {
            const e = t instanceof Array;
            if (e || t.tag) {
                const i = e ? t : [t];
                o.setListWithFn(i, Eo.worldBounds)
            } else {
                const e = function(t, e) {
                    let i, {x: s, y: n, width: o, height: r} = t;
                    return r || (r = o * (e.height / e.width),
                    i = !0),
                    o || (o = r * (e.width / e.height),
                    i = !0),
                    i ? {
                        x: s,
                        y: n,
                        width: o,
                        height: r
                    } : t
                }(t, n);
                o.set(s.getWorldBounds(e))
            }
            const {x: r, y: a, width: h, height: l} = o;
            let d = n.x - r
              , c = n.y - a;
            if (i)
                d += Math.max((n.width - h) / 2, 0),
                c += Math.max((n.height - l) / 2, 0);
            else {
                const t = this.getValidScale(Math.min(n.width / h, n.height / l));
                d += (n.width - h * t) / 2,
                c += (n.height - l * t) / 2,
                s.scaleOfWorld(o, t),
                o.scaleOf(o, t)
            }
            return s.move(d, c),
            o.move(d, c)
        }
        return s.worldBoxBounds
    }
    ;
    class A_ extends t.Group {
        get isOutside() {
            return !0
        }
        constructor(t, e) {
            super(),
            this.config = {
                theme: "light",
                padding: 0,
                minSize: 10
            },
            t.isApp && (t.sky.add(this),
            t = t.tree),
            this.target = t,
            e && Mt.assign(this.config, e),
            this.changeTheme(this.config.theme),
            this.waitLeafer(this.__listenEvents, this)
        }
        changeTheme(e) {
            let i;
            "string" == typeof e ? (i = {
                fill: "black",
                stroke: "rgba(255,255,255,0.8)"
            },
            "dark" === e && (i.fill = "white",
            i.stroke = "rgba(0,0,0,0.2)")) : i = e,
            this.scrollXBar || this.addMany(this.scrollXBar = new t.Box, this.scrollYBar = new t.Box),
            i = Object.assign({
                strokeAlign: "center",
                opacity: .5,
                width: 6,
                cornerRadius: 3,
                hoverStyle: {
                    opacity: .6
                },
                pressStyle: {
                    opacity: .7
                }
            }, i),
            i.height || (i.height = i.width),
            this.scrollXBar.set(Object.assign(Object.assign({}, i), {
                visible: !1
            })),
            this.scrollYBar.set(Object.assign(Object.assign({}, i), {
                visible: !1
            })),
            this.leafer && this.update()
        }
        update(t) {
            if (this.dragScrolling)
                return;
            const {minSize: e, padding: i} = this.config
              , {zoomLayer: s, canvas: n} = this.target.leafer
              , {worldRenderBounds: o} = s;
            if (t && this.scrollBounds && this.scrollBounds.isSame(o))
                return;
            this.scrollBounds = new lt(o);
            const r = n.bounds.clone().shrink(i)
              , a = r.clone().add(o)
              , h = this.ratioX = r.width / a.width
              , l = this.ratioY = r.height / a.height
              , d = (r.x - a.x) / a.width
              , c = (r.y - a.y) / a.height
              , u = h < 1
              , p = l < 1
              , {scrollXBar: _, scrollYBar: g} = this
              , {x: f, y: y, width: m, height: v} = r.shrink([2, p ? g.width + 6 : 2, u ? _.height + 6 : 2, 2]);
            _.set({
                x: f + m * d,
                y: y + v + 2,
                width: Math.max(m * h, e),
                visible: u
            }),
            g.set({
                x: f + m + 2,
                y: y + v * c,
                height: Math.max(v * l, e),
                visible: p
            })
        }
        onDrag(t) {
            this.dragScrolling = !0,
            this.__dragOut = this.app.config.move.dragOut,
            this.app.config.move.dragOut = !1;
            const e = t.current === this.scrollXBar
              , i = this.target.leafer.getValidMove(e ? -t.moveX / this.ratioX : 0, e ? 0 : -t.moveY / this.ratioY);
            this.target.moveWorld(i.x, i.y),
            t.current.moveWorld(i.x && -i.x * this.ratioX, i.y && -i.y * this.ratioY)
        }
        onDragEnd() {
            this.dragScrolling = !1,
            this.app.config.move.dragOut = this.__dragOut
        }
        __listenEvents() {
            const {scrollXBar: e, scrollYBar: i} = this;
            this.__eventIds = [e.on_(t.DragEvent.DRAG, this.onDrag, this), i.on_(t.DragEvent.DRAG, this.onDrag, this), e.on_(t.DragEvent.END, this.onDragEnd, this), i.on_(t.DragEvent.END, this.onDragEnd, this), this.target.on_(jo.BEFORE, ( () => this.update(!0))), this.target.leafer.on_(Yo.RESIZE, ( () => this.update()))]
        }
        __removeListenEvents() {
            this.off_(this.__eventIds)
        }
        destroy() {
            this.destroyed || (this.__removeListenEvents(),
            this.target = this.config = null,
            super.destroy())
        }
    }
    Bt.add("scroll");
    class W_ extends ah {
    }
    t.Arrow = class extends t.Line {
        get __tag() {
            return "Arrow"
        }
        constructor(t) {
            super(t),
            this.__.__useArrow = !0
        }
    }
    ,
    zt([Gn(W_)], t.Arrow.prototype, "__", void 0),
    zt([In("angle")], t.Arrow.prototype, "endArrow", void 0),
    t.Arrow = zt([io()], t.Arrow);
    const {M: z_, L: F_, C: U_, Q: H_, O: N_} = Jt
      , {rotate: Y_, copyFrom: X_, scale: V_} = D
      , j_ = {}
      , G_ = {
        layout(t, e, i, s, n, o, r) {
            let a, h, l = 0, d = t.length;
            for (; l < d; )
                switch (a = t[l],
                a) {
                case z_:
                case F_:
                    Z_(t, l + 1, e, i, s, n, o, r),
                    l += 3;
                    break;
                case U_:
                    for (h = 1; h < 6; h += 2)
                        Z_(t, l + h, e, i, s, n, o, r);
                    l += 7;
                    break;
                case H_:
                    for (h = 1; h < 4; h += 2)
                        Z_(t, l + h, e, i, s, n, o, r);
                    l += 5;
                    break;
                case N_:
                    t[l + 1] += e,
                    t[l + 2] += i,
                    s && (t[l + 3] *= s),
                    o && (t[l + 4] += o,
                    t[l + 5] += o),
                    l += 7
                }
        },
        rotate(t, e, i) {
            G_.layout(t, 0, 0, 1, 1, e, i)
        }
    };
    function Z_(t, e, i, s, n, o, r, a) {
        X_(j_, t[e], t[e + 1]),
        r && Y_(j_, r, a),
        n && V_(j_, n, o),
        t[e] = i + j_.x,
        t[e + 1] = s + j_.y
    }
    const {layout: K_, rotate: q_} = G_
      , {getAngle: J_} = D
      , $_ = {
        x: -.5
    }
      , Q_ = {
        connect: $_,
        offset: {
            x: -.71,
            bevelJoin: .36,
            roundJoin: .22
        },
        path: [1, -3, -3, 2, 0, 0, 2, -3, 3]
    }
      , tg = {
        connect: $_,
        offset: {
            x: -1.207,
            bevelJoin: .854,
            roundJoin: .707
        },
        path: [1, -3, -3, 2, 0, 0, 2, -1, 0]
    }
      , eg = {
        connect: $_,
        offset: {
            x: -.9,
            bevelJoin: .624,
            roundJoin: .4
        },
        path: [1, -3, 0, 2, -3, -2, 2, 0, 0, 2, -3, 2, 2, -3, 0, 1, -2.05, 1.1, 2, -2.05, -1.1],
        dashPath: [1, -2, 0, 2, -.5, 0]
    }
      , ig = {
        connect: $_,
        offset: {
            x: -1.1,
            bevelJoin: .872,
            roundJoin: .6
        },
        path: [1, -3, 0, 2, -3.5, -1.8, 2, 0, 0, 2, -3.5, 1.8, 2, -3, 0, 1, -2.25, .95, 2, -2.25, -.95],
        dashPath: [1, -3, 0, 2, -.5, 0]
    }
      , sg = {
        offset: $_,
        path: [...eg.path],
        dashPath: [1, -2.5, 0, 2, -1, 0]
    };
    q_(sg.path, 180, {
        x: -1.5,
        y: 0
    });
    const ng = {
        connect: {
            x: -1.3
        },
        path: [1, 1.8, -.1, 2, 1.8, 0, 26, 0, 0, 1.8, 0, 359, 0]
    }
      , og = {
        connect: {
            x: .5
        },
        path: [...ng.path, 1, 0, 0, 26, 0, 0, 1, 0, 360, 0],
        dashPath: [1, -.5, 0, 2, .5, 0]
    }
      , rg = {
        connect: {
            x: -1.3
        },
        path: [1, -1.4, 0, 2, -1.4, -1.4, 2, 1.4, -1.4, 2, 1.4, 1.4, 2, -1.4, 1.4, 2, -1.4, 0]
    }
      , ag = {
        path: [...rg.path, 2, -1.4, -.49, 2, 1, -.49, 1, -1.4, .49, 2, 1, .49]
    }
      , hg = Mt.clone(rg)
      , lg = Mt.clone(ag);
    q_(hg.path, 45),
    q_(lg.path, 45);
    const dg = {
        angle: Q_,
        "angle-side": tg,
        arrow: ig,
        triangle: eg,
        "triangle-flip": sg,
        circle: og,
        "circle-line": ng,
        square: ag,
        "square-line": rg,
        diamond: lg,
        "diamond-line": hg,
        mark: {
            offset: $_,
            path: [1, 0, -2, 2, 0, 2]
        }
    };
    function cg(t, e, i, s, n, o, r) {
        const {strokeCap: a, strokeJoin: h} = t.__
          , {offset: l, connect: d, path: c, dashPath: u} = "object" == typeof e ? e : dg[e];
        let p = d ? d.x : 0
          , _ = l ? l.x : 0;
        const g = [...c];
        return r && u && g.push(...u),
        "none" !== a && (p -= .5),
        l && ("round" === h && l.roundJoin ? _ += l.roundJoin : "bevel" === h && l.bevelJoin && (_ += l.bevelJoin)),
        _ && K_(g, _, 0),
        K_(g, s.x, s.y, n, n, J_(i, s)),
        o.x = (p + _) * n,
        g
    }
    const {M: ug, L: pg, C: _g, Q: gg, Z: fg, N: yg, D: mg, X: vg, G: wg, F: xg, O: bg, P: Eg, U: kg} = Jt
      , {copy: Tg, copyFrom: Bg, getDistancePoint: Lg} = D
      , Pg = {}
      , Cg = {}
      , Rg = {}
      , Sg = {}
      , Og = {}
      , Dg = {
        list: dg,
        addArrows(t, e) {
            const {startArrow: i, endArrow: s, strokeWidth: n, dashPattern: o, __pathForRender: r} = t.__;
            let a, h = 0, l = r.length, d = 0, c = i && "none" !== i;
            for (; h < l; ) {
                switch (a = r[h],
                a) {
                case ug:
                case pg:
                    (d < 2 || h + 6 >= l) && (Bg(Og, r[h + 1], r[h + 2]),
                    !d && c && Tg(Cg, Og)),
                    h += 3;
                    break;
                case _g:
                    1 !== d && h + 7 !== l || Mg(r, Sg, Og, h + 3),
                    h += 7;
                    break;
                case gg:
                    1 !== d && h + 5 !== l || Mg(r, Sg, Og, h + 1),
                    h += 5;
                    break;
                case fg:
                    return;
                case yg:
                    h += 5;
                    break;
                case mg:
                    h += 9;
                    break;
                case vg:
                    h += 6;
                    break;
                case wg:
                    h += 9;
                    break;
                case xg:
                    h += 5;
                    break;
                case bg:
                    h += 7;
                    break;
                case Eg:
                    h += 4;
                    break;
                case kg:
                    1 !== d && h + 6 !== l || Mg(r, Sg, Og, h + 1),
                    h += 6
                }
                if (d++,
                1 === d && a !== ug)
                    return;
                if (2 === d && c && Tg(Rg, a === pg ? Og : Sg),
                h === l) {
                    const l = t.__.__pathForRender = e ? [...r] : r
                      , d = t.__.__pathForArrow = [];
                    if (c) {
                        const e = cg(t, i, Rg, Cg, n, Pg, !!o);
                        o ? d.push(...e) : l.push(...e),
                        Pg.x && (Lg(Cg, Rg, -Pg.x, !0),
                        l[1] = Rg.x,
                        l[2] = Rg.y)
                    }
                    if (s && "none" !== s) {
                        const e = cg(t, s, Sg, Og, n, Pg, !!o);
                        if (o ? d.push(...e) : l.push(...e),
                        Pg.x) {
                            let t;
                            switch (Lg(Og, Sg, -Pg.x, !0),
                            a) {
                            case pg:
                                t = h - 3 + 1;
                                break;
                            case _g:
                                t = h - 7 + 5;
                                break;
                            case gg:
                                t = h - 5 + 3;
                                break;
                            case kg:
                                t = h - 6 + 3
                            }
                            t && Ig(l, Sg, t)
                        }
                    }
                } else
                    Tg(Sg, Og)
            }
        }
    };
    function Mg(t, e, i, s) {
        Bg(e, t[s], t[s + 1]),
        Bg(i, t[s + 2], t[s + 3])
    }
    function Ig(t, e, i) {
        t[i] = e.x,
        t[i + 1] = e.y
    }
    function Ag(t) {
        return wn(t, (t => ({
            set(e) {
                if (this.__setAttr(t, e)) {
                    const t = this.__;
                    t.__useArrow = "none" !== t.startArrow || "none" !== t.endArrow,
                    Mn(this)
                }
            }
        })))
    }
    Bt.add("arrow");
    const Wg = t.UI.prototype;
    Ag("none")(Wg, "startArrow"),
    Ag("none")(Wg, "endArrow"),
    Object.assign(Xa, Dg);
    const zg = {
        none: "none",
        title: "capitalize",
        upper: "uppercase",
        lower: "lowercase",
        "small-caps": "small-caps"
    }
      , Fg = {
        top: "flex-start",
        middle: "center",
        bottom: "flex-end"
    };
    function Ug(t, e, i) {
        const {style: s} = t
          , {fill: n, padding: o, textWrap: r, textOverflow: a, textDecoration: h} = e;
        s.fontFamily = e.fontFamily,
        s.fontSize = e.fontSize * i + "px",
        function(t, e) {
            let i = "black";
            e instanceof Array && (e = e[0]);
            if ("object" == typeof e)
                switch (e.type) {
                case "solid":
                    i = Na.string(e.color);
                    break;
                case "image":
                    break;
                case "linear":
                case "radial":
                case "angular":
                    const t = e.stops[0];
                    i = Na.string("string" == typeof t ? t : t.color);
                    break;
                default:
                    void 0 !== e.r && (i = Na.string(e))
                }
            else
                i = e;
            t.color = i
        }(s, n),
        s.fontStyle = e.italic ? "italic" : "normal",
        s.fontWeight = e.fontWeight,
        s.textDecoration = "delete" === h ? "line-through" : h,
        s.textTransform = zg[e.textCase],
        s.textAlign = e.textAlign,
        s.display = "flex",
        s.flexDirection = "column",
        s.justifyContent = Fg[e.verticalAlign],
        s.lineHeight = (e.__.__lineHeight || 0) * i + "px",
        s.letterSpacing = (e.__.__letterSpacing || 0) * i + "px",
        "none" === r ? s.whiteSpace = "nowrap" : "break" === r && (s.wordBreak = "break-all"),
        s.textIndent = (e.paraIndent || 0) * i + "px",
        s.padding = o instanceof Array ? o.map((t => t * i + "px")).join(" ") : (o || 0) * i + "px",
        s.textOverflow = "show" === a ? "" : "hide" === a ? "clip" : a
    }
    t.TextEditor = class extends Up {
        constructor() {
            super(...arguments),
            this.config = {
                selectAll: !0
            },
            this.eventIds = []
        }
        get tag() {
            return "TextEditor"
        }
        onLoad() {
            const {editor: e} = this
              , {config: i} = e.app
              , s = this.editTarget;
            s.visible = !1,
            this.isHTMLText = !(s instanceof t.Text),
            this._keyEvent = i.keyEvent,
            i.keyEvent = !1;
            const n = this.editDom = document.createElement("div")
              , {style: o} = n;
            n.contentEditable = "true",
            o.position = "fixed",
            o.transformOrigin = "left top",
            o.boxSizing = "border-box",
            this.isHTMLText ? n.innerHTML = String(s.text) : n.innerText = String(s.text);
            const {view: r} = e.app;
            (this.inBody = r instanceof HTMLCanvasElement) ? document.body.appendChild(n) : r.appendChild(n),
            this.eventIds = [e.app.on_(t.PointerEvent.DOWN, (t => {
                let i, {target: s} = t.origin;
                for (; s; )
                    s === n && (i = !0),
                    s = s.parentElement;
                i || e.closeInnerEditor()
            }
            ))],
            this.onFocus = this.onFocus.bind(this),
            this.onInput = this.onInput.bind(this),
            this.onUpdate = this.onUpdate.bind(this),
            this.onEscape = this.onEscape.bind(this),
            n.addEventListener("focus", this.onFocus),
            n.addEventListener("input", this.onInput),
            window.addEventListener("keydown", this.onEscape),
            window.addEventListener("scroll", this.onUpdate);
            const a = window.getSelection()
              , h = document.createRange();
            if (this.config.selectAll)
                h.selectNodeContents(n);
            else {
                const t = n.childNodes[0];
                h.setStartAfter(t),
                h.setEndAfter(t),
                h.collapse(!0)
            }
            a.removeAllRanges(),
            a.addRange(h)
        }
        onInput() {
            const {editDom: t} = this;
            this.editTarget.text = this.isHTMLText ? t.innerHTML : t.innerText.replace(/\n\n/, "\n")
        }
        onFocus() {
            this.editDom.style.outline = "none"
        }
        onEscape(t) {
            "Escape" === t.code && this.editor.closeInnerEditor()
        }
        onUpdate() {
            const {editTarget: t} = this;
            let e = 1;
            if (!this.isHTMLText) {
                const {scaleX: i, scaleY: s} = t.worldTransform;
                e = Math.max(Math.abs(i), Math.abs(s));
                t.fontSize * e < 12 && (e *= 12 / t.fontSize)
            }
            this.textScale = e;
            const {a: i, b: s, c: n, d: o, e: r, f: a} = new U(t.worldTransform).scale(1 / e);
            let {x: h, y: l} = this.inBody ? t.app.clientBounds : t.app.tree.clientBounds;
            this.inBody || (h -= window.scrollX,
            l -= window.scrollY);
            let {width: d, height: c} = t;
            d *= e,
            c *= e;
            const u = t.__;
            if (u.__autoWidth && u.autoSizeAlign)
                switch (d += 20,
                u.textAlign) {
                case "center":
                    h -= d / 2;
                    break;
                case "right":
                    h -= d
                }
            if (u.__autoHeight && u.autoSizeAlign)
                switch (c += 20,
                u.verticalAlign) {
                case "middle":
                    l -= c / 2;
                    break;
                case "bottom":
                    l -= c
                }
            const {style: p} = this.editDom;
            p.transform = `matrix(${i},${s},${n},${o},${r},${a})`,
            p.left = h + "px",
            p.top = l + "px",
            p.width = d + "px",
            p.height = c + "px",
            this.isHTMLText || Ug(this.editDom, t, e)
        }
        onUnload() {
            const {editTarget: t, editor: e, editDom: i} = this;
            t && (this.onInput(),
            t.visible = !0,
            e.app && (e.app.config.keyEvent = this._keyEvent),
            e.off_(this.eventIds),
            i.removeEventListener("focus", this.onFocus),
            i.removeEventListener("input", this.onInput),
            window.removeEventListener("keydown", this.onEscape),
            window.removeEventListener("scroll", this.onUpdate),
            i.remove(),
            this.editDom = this.eventIds = void 0)
        }
    }
    ,
    t.TextEditor = zt([Rp()], t.TextEditor),
    Bt.add("text-editor"),
    setTimeout(( () => Bt.check("editor", !0)));
    class Hg extends fh {
        setText(t) {
            this._text = t,
            this.__htmlChanged = !0
        }
    }
    return t.HTMLText = class extends t.Image {
        get __tag() {
            return "HTMLText"
        }
        get editInner() {
            return "TextEditor"
        }
        constructor(t) {
            super(t)
        }
        __updateBoxBounds() {
            const t = this.__;
            if (t.__htmlChanged) {
                const e = document.createElement("div")
                  , {style: i} = e;
                i.all = "initial",
                i.position = "absolute",
                i.visibility = "hidden",
                e.innerHTML = this.text,
                document.body.appendChild(e);
                const {width: s, height: n} = e.getBoundingClientRect()
                  , o = s + 10
                  , r = `<svg xmlns="http://www.w3.org/2000/svg" width="${o}" height="${n}">\n                        <foreignObject width="${o}" height="${n}">\n                            <style>\n                                * {\n                                    margin: 0;\n                                    padding: 0;\n                                    box-sizing: border-box;\n                                }\n                            </style>\n                            <body xmlns="http://www.w3.org/1999/xhtml">\n                                ${this.text}\n                            </body>\n                        </foreignObject>\n                    </svg>`;
                t.__setImageFill("data:image/svg+xml," + encodeURIComponent(r)),
                t.__naturalWidth = o / t.pixelRatio,
                t.__naturalHeight = n / t.pixelRatio,
                t.__htmlChanged = !1,
                e.remove()
            }
            super.__updateBoxBounds()
        }
    }
    ,
    zt([Gn(Hg)], t.HTMLText.prototype, "__", void 0),
    zt([Pn("")], t.HTMLText.prototype, "text", void 0),
    t.HTMLText = zt([io()], t.HTMLText),
    Bt.add("html"),
    t.AlignHelper = mt,
    t.AroundHelper = gt,
    t.ArrowData = W_,
    t.AutoBounds = ct,
    t.BezierHelper = Ee,
    t.Bounds = lt,
    t.BoundsHelper = ot,
    t.BoxData = nh,
    t.BranchHelper = To,
    t.BranchRender = Lr,
    t.CanvasData = yh,
    t.CanvasManager = Dt,
    t.ChildEvent = Uo,
    t.ColorConvert = Na,
    t.Creator = i,
    t.Cursor = Ol,
    t.DataHelper = Mt,
    t.Debug = wt,
    t.Dragger = xl,
    t.EditBox = vp,
    t.EditDataHelper = up,
    t.EditPoint = yp,
    t.EditSelect = ep,
    t.EditSelectHelper = Qu,
    t.EditToolCreator = Sp,
    t.Editor = Fp,
    t.EditorEvent = Mu,
    t.EditorGroupEvent = Mp,
    t.EditorHelper = Lp,
    t.EditorMoveEvent = Iu,
    t.EditorRotateEvent = Wu,
    t.EditorScaleEvent = Au,
    t.EditorSkewEvent = zu,
    t.Effect = Za,
    t.EllipseData = lh,
    t.EllipseHelper = Oe,
    t.Event = Fo,
    t.EventCreator = St,
    t.Eventer = Ko,
    t.Export = Ka,
    t.FileHelper = hn,
    t.FrameData = rh,
    t.GroupData = sh,
    t.HTMLTextData = Hg,
    t.HitCanvasManager = Dl,
    t.ImageData = fh,
    t.ImageEvent = No,
    t.ImageManager = pn,
    t.IncrementId = s,
    t.InnerEditor = Up,
    t.InnerEditorEvent = Dp,
    t.Interaction = Jl,
    t.InteractionBase = Sl,
    t.InteractionHelper = gl,
    t.Keyboard = ll,
    t.LayoutEvent = Vo,
    t.Layouter = Ba,
    t.LeafBounds = kr,
    t.LeafBoundsHelper = Eo,
    t.LeafData = At,
    t.LeafDataProxy = lr,
    t.LeafEventer = rr,
    t.LeafHelper = go,
    t.LeafLayout = zo,
    t.LeafLevelList = aa,
    t.LeafList = ra,
    t.LeafMatrix = fr,
    t.LeafRender = Tr,
    t.LeaferCanvas = la,
    t.LeaferCanvasBase = Zt,
    t.LeaferData = oh,
    t.LeaferEvent = Go,
    t.LeaferImage = yn,
    t.LeaferTypeCreator = b_,
    t.LineData = ah,
    t.MathHelper = h,
    t.Matrix = U,
    t.MatrixHelper = b,
    t.MultiTouchHelper = T_,
    t.MyDragEvent = _l,
    t.MyImage = il,
    t.MyPointerEvent = ul,
    t.NeedConvertToCanvasCommandMap = Qt,
    t.OneRadian = l,
    t.PI2 = d,
    t.PI_2 = c,
    t.Paint = Va,
    t.PaintGradient = Ga,
    t.PaintImage = ja,
    t.PathArrow = Xa,
    t.PathArrowModule = Dg,
    t.PathBounds = Ks,
    t.PathCommandDataHelper = Fi,
    t.PathCommandMap = Jt,
    t.PathConvert = fi,
    t.PathCorner = nn,
    t.PathCreator = is,
    t.PathData = uh,
    t.PathDrawer = ys,
    t.PathHelper = Kt,
    t.PathMatrixHelper = G_,
    t.PathNumberCommandLengthMap = se,
    t.PathNumberCommandMap = ie,
    t.PenData = ph,
    t.Platform = e,
    t.Plugin = Bt,
    t.Point = z,
    t.PointHelper = D,
    t.PointerButton = dl,
    t.PolygonData = dh,
    t.PropertyEvent = Ho,
    t.RectData = hh,
    t.RectHelper = ne,
    t.RectRender = xh,
    t.RenderEvent = jo,
    t.Renderer = Pa,
    t.ResizeEvent = Yo,
    t.Run = kt,
    t.ScrollBar = A_,
    t.SelectArea = Zu,
    t.Selector = Wa,
    t.StarData = ch,
    t.State = qa,
    t.StringNumberMap = vt,
    t.Stroker = Gu,
    t.TaskItem = cn,
    t.TaskProcessor = un,
    t.TextConvert = Ha,
    t.TextData = gh,
    t.Transformer = L_,
    t.Transition = Ja,
    t.TwoPointBoundsHelper = N,
    t.UIBounds = mh,
    t.UICreator = Pt,
    t.UIData = ih,
    t.UIEvent = cl,
    t.UIRender = vh,
    t.UnitConvert = Ya,
    t.WaitHelper = Co,
    t.WatchEvent = Xo,
    t.Watcher = _a,
    t.WheelEventHelper = B_,
    t.addViewport = v_,
    t.addViewportConfig = w_,
    t.affectRenderBoundsType = An,
    t.affectStrokeBoundsType = Dn,
    t.arrowType = Ag,
    t.attr = xn,
    t.autoLayoutType = Tn,
    t.boundsType = Pn,
    t.canvasPatch = an,
    t.canvasSizeAttrs = Gt,
    t.cursorType = jn,
    t.dataProcessor = Gn,
    t.dataType = En,
    t.decorateLeafAttr = wn,
    t.defineDataProcessor = Zn,
    t.defineKey = mn,
    t.defineLeafAttr = bn,
    t.doBoundsType = Rn,
    t.doStrokeType = Mn,
    t.effectType = za,
    t.emptyData = {},
    t.eraserType = Xn,
    t.getBoundsData = p,
    t.getDescriptor = vn,
    t.getMatrixData = _,
    t.getPointData = u,
    t.hitType = Vn,
    t.isNull = function(t) {
        return null == t
    }
    ,
    t.layoutProcessor = function(t) {
        return (e, i) => {
            mn(e, "__LayoutProcessor", {
                get: () => t
            })
        }
    }
    ,
    t.maskType = Yn,
    t.naturalBoundsType = Cn,
    t.opacityType = zn,
    t.pathInputType = Sn,
    t.pathType = On,
    t.pen = on,
    t.positionType = kn,
    t.registerEditTool = Cp,
    t.registerInnerEditor = Rp,
    t.registerUI = io,
    t.registerUIEvent = so,
    t.resizeType = Fa,
    t.rewrite = $n,
    t.rewriteAble = Qn,
    t.rotationType = Ln,
    t.scaleType = Bn,
    t.sortType = Nn,
    t.strokeType = In,
    t.surfaceType = Wn,
    t.tempBounds = dt,
    t.tempMatrix = H,
    t.tempPoint = F,
    t.useCanvas = ua,
    t.useModule = eo,
    t.version = "1.2.1",
    t.visibleType = Fn,
    t.zoomLayerType = Ua,
    t
}({});
