<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>åä¸ºè¿åŠ¨æ•°æ®è½¬GPX</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        .drop-area { border: 2px dashed #ccc; border-radius: 8px; padding: 3rem; text-align: center; margin: 2rem 0; cursor: pointer; }
        .drop-area.active { border-color: #2196F3; background: #f0f7ff; }
        #status { margin: 1rem 0; padding: 1rem; border-radius: 4px; display: none; }
        .success { background: #e8f5e9; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
        button { background: #2196F3; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 4px; cursor: pointer; font-size: 1rem; }
        button:disabled { background: #90caf9; cursor: not-allowed; }
        .feature-note { color: #666; margin: 1rem 0; padding: 1rem; background: #f5f5f5; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>åä¸ºè¿åŠ¨æ•°æ®è½¬GPXå·¥å…·</h1>
    <p>æ”¯æŒæ‹–å…¥æˆ–é€‰æ‹©åä¸ºè¿åŠ¨å¥åº·å¯¼å‡ºçš„HiTrackæ–‡ä»¶ï¼Œè½¬æ¢ä¸ºGPXæ ¼å¼å¹¶ä¸‹è½½</p>

    <div class="feature-note">
        âœ¨ æ ¸å¿ƒç‰¹æ€§ï¼š<br>
        - å®Œå…¨ä¿ç•™åŸå§‹æ•°æ®è®°å½•ï¼Œä¸è¡¥é½æ¯ç§’æ•°æ®<br>
        - æ–°å¢é€Ÿåº¦æ•°æ®è§£æï¼ˆtp=rsç±»å‹ï¼‰ï¼Œè½¬æ¢ä¸ºkm/h<br>
        - æ­¥é¢‘ã€å¿ƒç‡ã€æµ·æ‹”ã€é€Ÿåº¦åŒ¹é…åˆ°å¯¹åº”åŸå§‹ä½ç½®ç‚¹<br>
        - ä¸¥æ ¼éµå¾ªåŸå§‹æ•°æ®çš„æ—¶é—´é—´éš”
    </div>

    <div class="drop-area" id="dropArea">
        <p>ğŸ“‚ æ‹–å…¥æ–‡ä»¶åˆ°æ­¤å¤„</p>
        <p>æˆ–</p>
        <label for="fileInput">
            <button type="button">é€‰æ‹©æ–‡ä»¶</button>
            <input type="file" id="fileInput" style="display: none;">
        </label>
    </div>

    <div id="status"></div>

    <script>
        // å…¨å±€å˜é‡å­˜å‚¨è§£æåçš„æ•°æ®
        let trackData = {
            points: [], // å­˜å‚¨æ‰€æœ‰åŸå§‹è½¨è¿¹ç‚¹ { time, lat, lon, alt, hr, cadence, speed }
            startTime: null,
            endTime: null
        };

        // DOMå…ƒç´ 
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const statusEl = document.getElementById('status');

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            // æ‹–æ”¾äº‹ä»¶
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.classList.add('active');
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.classList.remove('active');
            });

            dropArea.addEventListener('drop', handleDrop, false);
            fileInput.addEventListener('change', handleFileSelect, false);
        }

        // å¤„ç†æ–‡ä»¶æ‹–æ”¾
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                processFile(files[0]);
            }
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length) {
                processFile(files[0]);
            }
        }

        // å¤„ç†æ–‡ä»¶è¯»å–å’Œè§£æ
        function processFile(file) {
            showStatus(`æ­£åœ¨è§£ææ–‡ä»¶: ${file.name}`, 'success');
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    parseHiTrackContent(content);
                    generateGPX(file.name.replace(/\.[^/.]+$/, "") + '.gpx');
                    showStatus(`è½¬æ¢æˆåŠŸï¼å·²ç”Ÿæˆä¿ç•™åŸå§‹æ•°æ®çš„GPXæ–‡ä»¶ï¼ˆå…±${trackData.points.length}ä¸ªåŸå§‹ä½ç½®ç‚¹ï¼‰`, 'success');
                } catch (err) {
                    showStatus(`è½¬æ¢å¤±è´¥: ${err.message}`, 'error');
                    console.error('è§£æé”™è¯¯:', err);
                }
            };

            reader.onerror = function() {
                showStatus('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            };

            reader.readAsText(file);
        }

        // è§£æHiTrackæ–‡ä»¶å†…å®¹ï¼ˆä»…ä¿ç•™åŸå§‹ä½ç½®ç‚¹+æ–°å¢é€Ÿåº¦è§£æï¼‰
        function parseHiTrackContent(content) {
            // é‡ç½®æ•°æ®
            trackData = { points: [], startTime: null, endTime: null };

            const lines = content.split('\n').filter(line => line.trim() !== '');
            const tempData = {
                locations: [], // åŸå§‹ä½ç½®æ•°æ®ï¼ˆä»…ä¿ç•™å®é™…å­˜åœ¨çš„ç‚¹ï¼‰
                heartRates: [], // å¿ƒç‡æ•°æ®
                altitudes: [], // æµ·æ‹”æ•°æ®
                cadences: [], // æ­¥é¢‘æ•°æ®
                speeds: [] // é€Ÿåº¦æ•°æ®ï¼ˆæ–°å¢ï¼‰
            };

            // æŒ‰è¡Œè§£æä¸åŒç±»å‹æ•°æ®
            lines.forEach(line => {
                const parts = line.trim().split(';').filter(part => part);
                const typePart = parts[0];
                if (!typePart.startsWith('tp=')) return;

                const type = typePart.split('=')[1];
                const dataObj = {};

                // è§£æé”®å€¼å¯¹
                parts.forEach(part => {
                    const [key, value] = part.split('=');
                    if (key && value !== undefined) {
                        dataObj[key] = value;
                    }
                });

                // å¤„ç†ä¸åŒç±»å‹æ•°æ®
                switch(type) {
                    case 'lbs': // ä½ç½®æ•°æ®ï¼ˆä»…ä¿ç•™æœ‰æ•ˆåŸå§‹ç‚¹ï¼‰
                        handleLocationData(dataObj, tempData.locations);
                        break;
                    case 'h-r': // å¿ƒç‡æ•°æ®
                        handleHeartRateData(dataObj, tempData.heartRates);
                        break;
                    case 'alti': // æµ·æ‹”æ•°æ®
                        handleAltitudeData(dataObj, tempData.altitudes);
                        break;
                    case 's-r': // æ­¥é¢‘æ•°æ®
                        handleCadenceData(dataObj, tempData.cadences);
                        break;
                    case 'rs': // é€Ÿåº¦æ•°æ®ï¼ˆæ–°å¢ï¼‰
                        handleSpeedData(dataObj, tempData.speeds);
                        break;
                    default:
                        // å¿½ç•¥å…¶ä»–ç±»å‹æ•°æ®
                        break;
                }
            });

            // åˆå¹¶æ‰€æœ‰æ•°æ®ï¼ˆä»…åŒ¹é…åŸå§‹ä½ç½®ç‚¹ï¼Œä¸æ–°å¢ä»»ä½•ç‚¹ï¼‰
            mergeTrackData(tempData);
        }

        // å¤„ç†ä½ç½®æ•°æ®ï¼ˆä»…ä¿ç•™æœ‰æ•ˆåŸå§‹ç‚¹ï¼Œä¸è¡¥é½ï¼‰
        function handleLocationData(dataObj, locations) {
            // è·³è¿‡æš‚åœæ ‡è®°ç‚¹ (lat=90, lon=-80)
            if (parseFloat(dataObj.lat) === 90 && parseFloat(dataObj.lon) === -80) {
                return;
            }

            // è½¬æ¢æ—¶é—´æˆ³
            const time = convertTimestamp(parseFloat(dataObj.t));
            if (!time) return;

            // ç›´æ¥æ·»åŠ åŸå§‹ä½ç½®ç‚¹ï¼Œä¸åšä»»ä½•è¡¥é½
            locations.push({
                time: time,
                lat: parseFloat(dataObj.lat),
                lon: parseFloat(dataObj.lon),
                alt: dataObj.alt ? parseFloat(dataObj.alt) : null
            });
        }

        // å¤„ç†å¿ƒç‡æ•°æ®
        function handleHeartRateData(dataObj, heartRates) {
            const time = convertTimestamp(parseFloat(dataObj.k));
            if (!time) return;

            heartRates.push({
                time: time,
                hr: parseInt(dataObj.v, 10)
            });
        }

        // å¤„ç†æµ·æ‹”æ•°æ®
        function handleAltitudeData(dataObj, altitudes) {
            const time = convertTimestamp(parseFloat(dataObj.k));
            if (!time) return;

            altitudes.push({
                time: time,
                alt: parseFloat(dataObj.v)
            });
        }

        // å¤„ç†æ­¥é¢‘æ•°æ®
        function handleCadenceData(dataObj, cadences) {
            const time = convertTimestamp(parseFloat(dataObj.k));
            if (!time) return;

            const cadenceValue = parseInt(dataObj.v, 10);
            // è¿‡æ»¤æ— æ•ˆæ­¥é¢‘å€¼ï¼ˆ0é€šå¸¸è¡¨ç¤ºæš‚åœæˆ–éª‘è¡ŒçŠ¶æ€ï¼‰
            if (cadenceValue > 0) { // ä»…ä¿ç•™æœ‰æ•ˆæ­¥é¢‘å€¼ï¼ˆ>0ï¼‰
                cadences.push({
                    time: time,
                    cadence: cadenceValue
                });
            }
        }

        // å¤„ç†é€Ÿåº¦æ•°æ®ï¼ˆæ–°å¢ï¼‰
        function handleSpeedData(dataObj, speeds) {
            // è§£æç›¸å¯¹æ—¶é—´ï¼ˆkï¼šè¿åŠ¨å¼€å§‹åçš„ç§’æ•°ï¼‰å’Œé€Ÿåº¦å€¼ï¼ˆvï¼šåˆ†ç±³/ç§’ dm/sï¼‰
            const relativeTime = parseInt(dataObj.k, 10);
            const speedDmPerSec = parseFloat(dataObj.v);

            // è¿‡æ»¤æ— æ•ˆé€Ÿåº¦å€¼ï¼ˆè´Ÿæ•°æˆ–0è¡¨ç¤ºé™æ­¢/æ— æ•ˆï¼‰
            if (speedDmPerSec <= 0) return;

            speeds.push({
                relativeTime: relativeTime, // ç›¸å¯¹è¿åŠ¨å¼€å§‹æ—¶é—´çš„ç§’æ•°
                speedDmPerSec: speedDmPerSec // åŸå§‹å•ä½ï¼šåˆ†ç±³/ç§’
            });
        }

        // è½¬æ¢åä¸ºæ—¶é—´æˆ³ä¸ºISOæ ¼å¼
        function convertTimestamp(timestamp) {
            try {
                // å¤„ç†ä¸åŒæ ¼å¼çš„æ—¶é—´æˆ³ï¼ˆç§’ã€æ¯«ç§’ã€ç§‘å­¦è®¡æ•°æ³•ï¼‰
                if (timestamp > 1e12) {
                    // æ¯«ç§’çº§æ—¶é—´æˆ³
                    timestamp = timestamp / 1000;
                } else if (timestamp > 1e11) {
                    // 13ä½æ¯«ç§’çº§ï¼ˆå¦‚1762335282000ï¼‰
                    timestamp = timestamp / 1000;
                } else if (timestamp < 604800) {
                    // ç›¸å¯¹æ—¶é—´ï¼ˆå°äº7å¤©ï¼‰ï¼Œæš‚ä¸å¤„ç†
                    return null;
                }

                // è½¬æ¢ä¸ºISOæ ¼å¼ï¼ˆUTC+0ï¼‰
                const date = new Date(timestamp * 1000);
                if (isNaN(date.getTime())) return null;

                // GPXè¦æ±‚çš„ISOæ ¼å¼ï¼šYYYY-MM-DDTHH:mm:ssZ
                return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
            } catch (err) {
                return null;
            }
        }

        // åˆå¹¶æ‰€æœ‰æ•°æ®ï¼ˆä»…åŒ¹é…åŸå§‹ä½ç½®ç‚¹ï¼Œä¸æ–°å¢ä»»ä½•ç‚¹+é€Ÿåº¦åŒ¹é…ï¼‰
        function mergeTrackData(tempData) {
            // å¯¹ä½ç½®æ•°æ®æŒ‰æ—¶é—´æ’åºï¼ˆä¿æŒåŸå§‹é¡ºåºï¼‰
            const sortedLocations = tempData.locations.sort((a, b) => new Date(a.time) - new Date(b.time));
            if (sortedLocations.length === 0) {
                throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆä½ç½®æ•°æ®');
            }

            // æ’åºè¾…åŠ©æ•°æ®ï¼ˆå¿ƒç‡ã€æµ·æ‹”ã€æ­¥é¢‘ï¼‰
            const sortedHR = tempData.heartRates.sort((a, b) => new Date(a.time) - new Date(b.time));
            const sortedAlt = tempData.altitudes.sort((a, b) => new Date(a.time) - new Date(b.time));
            const sortedCadence = tempData.cadences.sort((a, b) => new Date(a.time) - new Date(b.time));

            // å¤„ç†é€Ÿåº¦æ•°æ®ï¼šè®¡ç®—ç»å¯¹æ—¶é—´ï¼ˆè¿åŠ¨å¼€å§‹æ—¶é—´+ç›¸å¯¹æ—¶é—´ï¼‰å¹¶æ’åºï¼ˆæ–°å¢ï¼‰
            const activityStartTime = new Date(sortedLocations[0].time);
            const sortedSpeeds = tempData.speeds
                .map(speed => ({
                    // è®¡ç®—é€Ÿåº¦æ•°æ®çš„ç»å¯¹æ—¶é—´
                    time: new Date(activityStartTime.getTime() + speed.relativeTime * 1000).toISOString().replace(/\.\d{3}Z$/, 'Z'),
                    // è½¬æ¢ä¸ºkm/hï¼šdm/s â†’ m/sï¼ˆÃ·10ï¼‰â†’ km/hï¼ˆÃ—3.6ï¼‰
                    speedKmPerH: (speed.speedDmPerSec / 10) * 3.6
                }))
                .sort((a, b) => new Date(a.time) - new Date(b.time));

            // ä¸ºæ¯ä¸ªåŸå§‹ä½ç½®ç‚¹åŒ¹é…æœ€è¿‘çš„è¾…åŠ©æ•°æ®ï¼ˆæ‰©å¤§åŒ¹é…çª—å£åˆ°10ç§’ï¼‰
            sortedLocations.forEach(loc => {
                const point = {
                    time: loc.time,
                    lat: loc.lat,
                    lon: loc.lon,
                    alt: loc.alt || findNearestData(loc.time, sortedAlt, 'alt', 10000), // 10ç§’åŒ¹é…çª—å£
                    hr: findNearestData(loc.time, sortedHR, 'hr', 10000),
                    cadence: findNearestData(loc.time, sortedCadence, 'cadence', 10000),
                    speed: findNearestData(loc.time, sortedSpeeds, 'speedKmPerH', 10000) // æ–°å¢é€Ÿåº¦åŒ¹é…
                };

                trackData.points.push(point);
            });

            // è®¾ç½®èµ·æ­¢æ—¶é—´
            trackData.startTime = trackData.points[0].time;
            trackData.endTime = trackData.points[trackData.points.length - 1].time;
        }

        // æŸ¥æ‰¾æœ€è¿‘æ—¶é—´æˆ³çš„æ•°æ®ï¼ˆä¸ç”Ÿæˆæ–°ç‚¹ï¼Œä»…åŒ¹é…ï¼‰
        function findNearestData(targetTime, dataArray, field, maxDiff = 5000) {
            if (dataArray.length === 0) return null;

            const targetDate = new Date(targetTime);
            let nearestValue = null;
            let minDiff = Infinity;

            dataArray.forEach(item => {
                const diff = Math.abs(new Date(item.time) - targetDate);
                if (diff < minDiff && diff <= maxDiff) {
                    minDiff = diff;
                    nearestValue = item[field];
                }
            });

            return nearestValue;
        }

        // ç”ŸæˆGPXæ–‡ä»¶ï¼ˆä»…åŒ…å«åŸå§‹ä½ç½®ç‚¹+é€Ÿåº¦å­—æ®µï¼‰
        function generateGPX(filename) {
            // GPX XMLæ¨¡æ¿
            const gpxTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="åä¸ºè¿åŠ¨æ•°æ®è½¬GPXå·¥å…·" xmlns="http://www.topografix.com/GPX/1/1" xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v1" xmlns:gpxdata="http://www.cluetrust.com/XML/GPXDATA/1/0">
  <metadata>
    <name>${filename}</name>
    <time>${new Date().toISOString().replace(/\.\d{3}Z$/, 'Z')}</time>
    <desc>åä¸ºè¿åŠ¨å¥åº·åŸå§‹æ•°æ®è½¬æ¢ç”Ÿæˆï¼Œå…±${trackData.points.length}ä¸ªä½ç½®ç‚¹</desc>
    <author>
      <name>åä¸ºè¿åŠ¨æ•°æ®è½¬GPXå·¥å…·</name>
    </author>
  </metadata>
  <trk>
    <name>åä¸ºè¿åŠ¨è½¨è¿¹</name>
    <trkseg>
      ${generateTrackPoints()}
    </trkseg>
  </trk>
</gpx>`;

            // åˆ›å»ºBlobå¹¶ä¸‹è½½
            const blob = new Blob([gpxTemplate], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();

            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        // ç”Ÿæˆè½¨è¿¹ç‚¹XMLï¼ˆç§»é™¤RunCadence+æ–°å¢é€Ÿåº¦å­—æ®µï¼‰
        function generateTrackPoints() {
            return trackData.points.map(point => {
                let xml = `<trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">`;
                xml += `<time>${point.time}</time>`;

                // æ·»åŠ æµ·æ‹”ï¼ˆåŸå§‹æ•°æ®æˆ–åŒ¹é…åˆ°çš„æ•°æ®ï¼‰
                if (point.alt !== null && !isNaN(point.alt)) {
                    xml += `<ele>${point.alt.toFixed(1)}</ele>`;
                }

                // æ·»åŠ æ‰©å±•å­—æ®µï¼ˆå¿ƒç‡+æ­¥é¢‘+é€Ÿåº¦ï¼Œä»…ä¿ç•™å­˜åœ¨çš„æ•°æ®ï¼‰
                let extensions = [];
                if (point.hr !== null && point.hr > 0) {
                    extensions.push(`<gpxtpx:hr>${point.hr}</gpxtpx:hr>`);
                }
                if (point.cadence !== null && point.cadence > 0) {
                    // ä»…ä¿ç•™é€šç”¨æ­¥é¢‘å­—æ®µï¼Œç§»é™¤gpxtpx:RunCadence
                    extensions.push(`<gpxdata:cadence>${point.cadence}</gpxdata:cadence>`);
                }
                if (point.speed !== null && point.speed > 0) {
                    // æ–°å¢é€Ÿåº¦å­—æ®µï¼ˆå•ä½ï¼škm/hï¼‰
                    extensions.push(`<gpxdata:speed>${point.speed.toFixed(1)}</gpxdata:speed>`);
                }

                if (extensions.length > 0) {
                    xml += `<extensions><gpxtpx:TrackPointExtension>${extensions.join('')}</gpxtpx:TrackPointExtension></extensions>`;
                }

                xml += `</trkpt>`;
                return xml;
            }).join('\n      ');
        }

        // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        function showStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = type;
            statusEl.style.display = 'block';

            // 5ç§’åè‡ªåŠ¨éšè—æˆåŠŸçŠ¶æ€
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }

        // åˆå§‹åŒ–
        window.onload = initEventListeners;
    </script>
</body>
</html>